<!DOCTYPE html>
<!-- saved from url=(0044)./16_canvas.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <title>Drawing on Canvas :: Eloquent JavaScript</title>
  <link rel="stylesheet" href="./media/codemirror.css">
  <script src="./media/acorn_codemirror.js"></script>
  <link rel="stylesheet" href="./media/ejs.css">
  <script src="./media/sandbox.js"></script>
  <script src="./media/ejs.js"></script>
  <script>var chapNum = 16;var sandboxLoadFiles = ["code/chapter/15_game.js", "code/game_levels.js", "code/chapter/16_canvas.js"];</script>
</head>

<body><article>
<nav>
  <a href="./15_game.html" title="previous chapter">◀</a>
  <a href="./index.html" title="cover">◆</a>
  <a href="./17_http.html" title="next chapter">▶</a>
</nav>

<h1><div class="chap_num">Глава 16</div>Рисуване върху платно</h1>
<blockquote>
<p><a class="p_ident" id="p_ubdp8gf0Gn" href="./16_canvas.html#p_ubdp8gf0Gn"></a>Drawing е една измама.”</p>
 <footer>M.C. Escher, <cite>цитиран от Bruno Ernst в The Magic Mirror на Ешер</cite></footer>
</blockquote>
<p><a class="p_ident" id="p_rMRN8Q3Ilr" href="./16_canvas.html#p_rMRN8Q3Ilr"></a>Браузърът ни дава няколко начина за показване на графики. Най-простият се използва за позициониране на стилове и оцветяване на редови DOM елементи. Така може да стигнете доста далеч, както играта в <a href="./15_game.html#game">предната глава</a> показа. Чрез добавяне на полупрозрачни изображения за фон на разклоненията, можем да ги направим да изглеждат точно така, както ние искаме. Възможно е дори да се върти или наклони разклонение с помощта на <code>transform</code> стила.</p>
<p><a class="p_ident" id="p_4MfzfTYnsB" href="./16_canvas.html#p_4MfzfTYnsB"></a>Но можем да използваме DOM за нещо, за което не е бил първоначално проектиран. Някои задачи, като чертане на линия между произволни точки, са изключително неудобни с редовни HTML елементи.</p>
<p><a class="p_ident" id="p_ETEHgjW4XZ" href="./16_canvas.html#p_ETEHgjW4XZ"></a>Има две алтернативи. Първата е DOM базирана, като използва <em>Scalable Vector Graphics (SVG)</em> вместо HTML елементи. Мислете за SVG, като диалект за описване на документи, който се фокусира върху формите, а не върху текста. Можете да вградите SVG документ в HTML документ или да го включите с <code>&lt;img&gt;</code> таг.</p>
<p><a class="p_ident" id="p_wU9UQEILbC" href="./16_canvas.html#p_wU9UQEILbC"></a>Втората алтернатива се нарича <em>canvas</em> (платно). Платното е единичен DOM елемент, който капсулира картина. То осигурява програмен интерфейс за съставяне на фигури върху област взета от разклонение. Основната разлика между <em>canvas</em>  и SVG, е че в SVG е запазено оригиналното описание на формите, така че те да могат да бъдат местени или променяни по размер по всяко време. Докато платното от друга страна превръща формите в пиксели (цветни точки на изображението) и веднага след, като те са създадени не помни, какво представляват тези пиксели. Единственият начин да се движат формите по платното (или част от формите на <em>canvas</em>) е да изчистите платното и да прехвърлите формата на нова позиция.</p>
<h2><a class="h_ident" id="h_UPzm0CiZhQ" href="./16_canvas.html#h_UPzm0CiZhQ"></a>SVG</h2>
<p><a class="p_ident" id="p_gCxXcLPC1N" href="./16_canvas.html#p_gCxXcLPC1N"></a>Тази книга няма да набляга на подробности за SVG, но накратко ще обясним как става това. В <a href="./16_canvas.html#graphics_tradeoffs">края на главата</a> ще се върнем на компромисите, които трябва да се имат в предвид при вземане на решение, кой изготвящ механизъм е по-подходящ за дадено приложение.</p>
<p><a class="p_ident" id="p_aF1bihN0fO" href="./16_canvas.html#p_aF1bihN0fO"></a>Това е HTML документ с проста SVG картина в него:</p>
<pre data-language="text/html" class="snippet cm-s-default" data-sandbox="svg"><a class="c_ident" id="c_51NWnKIFCi" href="./16_canvas.html#c_51NWnKIFCi"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>Normal HTML here.<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">svg</span> <span class="cm-attribute">xmlns</span>=<span class="cm-string">"http://www.w3.org/2000/svg"</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">circle</span> <span class="cm-attribute">r</span>=<span class="cm-string">"50"</span> <span class="cm-attribute">cx</span>=<span class="cm-string">"50"</span> <span class="cm-attribute">cy</span>=<span class="cm-string">"50"</span> <span class="cm-attribute">fill</span>=<span class="cm-string">"red"</span><span class="cm-tag cm-bracket">/&gt;</span>
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">rect</span> <span class="cm-attribute">x</span>=<span class="cm-string">"120"</span> <span class="cm-attribute">y</span>=<span class="cm-string">"5"</span> <span class="cm-attribute">width</span>=<span class="cm-string">"90"</span> <span class="cm-attribute">height</span>=<span class="cm-string">"90"</span>
        <span class="cm-attribute">stroke</span>=<span class="cm-string">"blue"</span> <span class="cm-attribute">fill</span>=<span class="cm-string">"none"</span><span class="cm-tag cm-bracket">/&gt;</span>
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">svg</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_sJ+IuoXUNA" href="./16_canvas.html#p_sJ+IuoXUNA"></a>Атрибута <code>xmlns</code> променя елемента (и неговите деца) в различно <em>XML namespace</em> (пространство) от имена. Това пространство от имена идентифицирано с URL уточнява диалекта, на който в момента говорим. <code>&lt;circle&gt;</code> и <code>&lt;rect&gt;</code> таговете, които не съществуват в HTML, нямат значение за изготвянето на формите в SVG - те изготвят форми, използвайки стила и положението, определено от техните атрибути.</p>
<p><a class="p_ident" id="p_DcMLpWRkj0" href="./16_canvas.html#p_DcMLpWRkj0"></a>Тези маркери създават DOM елементи, точно като HTML тагове. Например, това променя <code>&lt;circle&gt;</code> елемента да бъде оцветен в циан вместо червено.</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="svg"><a class="c_ident" id="c_nTTh9qtCeV" href="./16_canvas.html#c_nTTh9qtCeV"></a><span class="cm-keyword">var</span> <span class="cm-variable">circle</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"circle"</span>);
<span class="cm-variable">circle</span>.<span class="cm-property">setAttribute</span>(<span class="cm-string">"fill"</span>, <span class="cm-string">"cyan"</span>);</pre>
<h2><a class="h_ident" id="h_QXPPgw0nn4" href="./16_canvas.html#h_QXPPgw0nn4"></a>Canvas  елемент</h2>
<p><a class="p_ident" id="p_81TEgZtPp7" href="./16_canvas.html#p_81TEgZtPp7"></a><em>Canvas</em>  графики могат да се правят върху <code>&lt;canvas&gt;</code> елемент. Можем да дадем на такъв елемент <code>width</code> и <code>height</code> атрибути за определяне на размера му в пиксели.</p>
<p><a class="p_ident" id="p_oQeTfkBH6v" href="./16_canvas.html#p_oQeTfkBH6v"></a>Новото платно е празно, което означава, че е напълно прозрачно и по този начин се появява, като празно пространство в документа.</p>
<p><a class="p_ident" id="p_r+b1t0y8Si" href="./16_canvas.html#p_r+b1t0y8Si"></a>Тага <code>&lt;canvas&gt;</code> е предназначен за подкрепа на различни стилове на рисуване. За да получим достъп до действителния интерфейс на една рисунка, първо трябва да създадем обстановка, която е обект чиито методи предоставят интерфейс за чертане. В момента има два широко подкрепяни стилове: <code>"2d"</code> - за двуизмерни графики и <code>"webgl"</code> - за триизмерна графика през интерфейса на  OpenGL.</p>
<p><a class="p_ident" id="p_JaC7mTUVQ0" href="./16_canvas.html#p_JaC7mTUVQ0"></a>Тази книга няма да обсъжда WebGL. Ще се придържаме към двете измерения. Но ако се интересувате от триизмерна графика ви препоръчвам да разгледате  WebGL. Той осигурява много директен интерфейс към съвременния графичен хардуер и по този начин ви позволява да направите ефективно дори сложни сцени, използвайки JavaScript.</p>
<p><a class="p_ident" id="p_GM4b1ASHzf" href="./16_canvas.html#p_GM4b1ASHzf"></a>Контекста е създаден през <code>getContext</code> метода на <code>&lt;canvas&gt;</code> елемента.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_jWP86QSU3M" href="./16_canvas.html#c_jWP86QSU3M"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>Before canvas.<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">canvas</span> <span class="cm-attribute">width</span>=<span class="cm-string">"120"</span> <span class="cm-attribute">height</span>=<span class="cm-string">"60"</span><span class="cm-tag cm-bracket">&gt;&lt;/</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>After canvas.<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">canvas</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"canvas"</span>);
  <span class="cm-keyword">var</span> <span class="cm-variable">context</span> <span class="cm-operator">=</span> <span class="cm-variable">canvas</span>.<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);
  <span class="cm-variable">context</span>.<span class="cm-property">fillStyle</span> <span class="cm-operator">=</span> <span class="cm-string">"red"</span>;
  <span class="cm-variable">context</span>.<span class="cm-property">fillRect</span>(<span class="cm-number">10</span>, <span class="cm-number">10</span>, <span class="cm-number">100</span>, <span class="cm-number">50</span>);
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_fv4PQSHT32" href="./16_canvas.html#p_fv4PQSHT32"></a>След създаване на контекст обект, примерът чертае червен правоъгълник 100 пиксела на 50 пиксела, с координати - горен ляв ъгъл (10, 10).</p>
<p><a class="p_ident" id="p_e1SRsTstnD" href="./16_canvas.html#p_e1SRsTstnD"></a>Точно както в HTML (и SVG), координатната система поставя платното на точка (0, 0) в гония ляв ъгъл и положителната ос у слиза от там. Така че, (10, 10) е 10 пиксела по надолу и по надясно от горния ляв ъгъл.</p>
<h2 id="fill_stroke"><a class="h_ident" id="h_pcnyueRl1y" href="./16_canvas.html#h_pcnyueRl1y"></a>Запълване  и  очертания</h2>
<p><a class="p_ident" id="p_UvxB22/zji" href="./16_canvas.html#p_UvxB22/zji"></a>В интерфейса на платното, формата може да бъде <em>filled</em> (запълнена), което означава, че на площта е даден цвят и модел или може да бъде <em>stroked</em> (очертана), което означава, че линията рисува неговия ръб. Същата терминология използва и SVG.</p>
<p><a class="p_ident" id="p_jXutP8Kp6D" href="./16_canvas.html#p_jXutP8Kp6D"></a>Метода <code>fillRect</code> запълва правоъгълника. Той взема първо х и у координатите на горния ляв ъгъл на правоъгълника, а след това неговата ширина и височина. Метода <code>strokeRect</code> е подобен и чертае очертанията на правоъгълника.</p>
<p><a class="p_ident" id="p_a+mohoFrQD" href="./16_canvas.html#p_a+mohoFrQD"></a>Метода <em>neither</em> взема някои допълнителни параметри. Цвят на пълнежа, дебелина на очертанията и т.н. той не се определя от един аргумент на метода (както може да се очаква), а по-скоро от свойствата на контекста на обекта.</p>
<p><a class="p_ident" id="p_qwtIen1h5e" href="./16_canvas.html#p_qwtIen1h5e"></a>Свойството <code>fillStyle</code> променя начина на запълване на формата. Може да се настрои със <em>string</em>, който определя цвят и може да се използва всеки цвят, който се разбира със CSS.</p>
<p><a class="p_ident" id="p_z2EgIJKmOE" href="./16_canvas.html#p_z2EgIJKmOE"></a>Свойството <code>strokeStyle</code> работи по подобен начин, но определя цвета използван за очертаваща линия. Ширината на тази линия се определя от свойството <code>lineWidth</code>, което може да съдържа всяко положително число.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_SjVWfvP4XI" href="./16_canvas.html#c_SjVWfvP4XI"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;&lt;/</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">cx</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"canvas"</span>).<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">strokeStyle</span> <span class="cm-operator">=</span> <span class="cm-string">"blue"</span>;
  <span class="cm-variable">cx</span>.<span class="cm-property">strokeRect</span>(<span class="cm-number">5</span>, <span class="cm-number">5</span>, <span class="cm-number">50</span>, <span class="cm-number">50</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">lineWidth</span> <span class="cm-operator">=</span> <span class="cm-number">5</span>;
  <span class="cm-variable">cx</span>.<span class="cm-property">strokeRect</span>(<span class="cm-number">135</span>, <span class="cm-number">5</span>, <span class="cm-number">50</span>, <span class="cm-number">50</span>);
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_AIygWrCmAA" href="./16_canvas.html#p_AIygWrCmAA"></a>Когато няма определен атрибут <code>width</code> или <code>height</code>, както в предишния пример, елемента на платното получава ширина по-подразбиране от 300 пиксела и височина от 150 пиксела.</p>
<h2><a class="h_ident" id="h_E+fhFyL32D" href="./16_canvas.html#h_E+fhFyL32D"></a>Paths (път)</h2>
<p><a class="p_ident" id="p_EjhhpUs4B/" href="./16_canvas.html#p_EjhhpUs4B/"></a>Paths (път)  е поредица от линии. Интерфейса на 2d платното използва един особен подход за описване на такъв път. Той е направен изцяло чрез странични ефекти. Paths не са стойности, които могат да се съхраняват и подават наоколо. Вместо това, ако искате да направите нещо с пътя, можете да направите поредица от извиквания на метод, с които да опишете своята форма.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_RrsnV8j3mk" href="./16_canvas.html#c_RrsnV8j3mk"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;&lt;/</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">cx</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"canvas"</span>).<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">beginPath</span>();
  <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-variable">y</span> <span class="cm-operator">=</span> <span class="cm-number">10</span>; <span class="cm-variable">y</span> <span class="cm-operator">&lt;</span> <span class="cm-number">100</span>; <span class="cm-variable">y</span> <span class="cm-operator">+=</span> <span class="cm-number">10</span>) {
    <span class="cm-variable">cx</span>.<span class="cm-property">moveTo</span>(<span class="cm-number">10</span>, <span class="cm-variable">y</span>);
    <span class="cm-variable">cx</span>.<span class="cm-property">lineTo</span>(<span class="cm-number">90</span>, <span class="cm-variable">y</span>);
  }
  <span class="cm-variable">cx</span>.<span class="cm-property">stroke</span>();
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_CWuGebDoSl" href="./16_canvas.html#p_CWuGebDoSl"></a>Този пример създава път с няколко на брой  хоризонтални линии сегменти и след това използва <code>stroke</code> метод. Всеки сегмент е създаден с <code>lineTo</code>, от където започва текущата позиция на пътя. Тази позиция обикновено е края на последния сегмент, освен ако не е извикана <code>moveTo</code>. В такъв случай следващият сегмент ще започне в позицията подадена от <code>moveTo</code>.</p>
<p><a class="p_ident" id="p_/C3/H/w2FX" href="./16_canvas.html#p_/C3/H/w2FX"></a>При запълване на пътя (с помощта на <code>fill</code> метода) всяка форма се запълва отделно. Пътят може да съдържа множество форми - всяка от които започва с <code>moveTo</code>. Но пътят трябва да бъде затворен (което означава, че неговото начало и край са едно и също местоположение), преди да може да бъде запълнен. Ако пътя не е затворен, се добавя допълнителна линия от края до началото на пътя и формата се запълва.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_a6T1eLJBay" href="./16_canvas.html#c_a6T1eLJBay"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;&lt;/</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">cx</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"canvas"</span>).<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">beginPath</span>();
  <span class="cm-variable">cx</span>.<span class="cm-property">moveTo</span>(<span class="cm-number">50</span>, <span class="cm-number">10</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">lineTo</span>(<span class="cm-number">10</span>, <span class="cm-number">70</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">lineTo</span>(<span class="cm-number">90</span>, <span class="cm-number">70</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">fill</span>();
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_9unYw61//h" href="./16_canvas.html#p_9unYw61//h"></a>Този пример чертае запълнен триъгълник. Имайте в предвид, че само две от страните на триъгълника са изрично изготвени. Третата, от долния десен ъгъл обратно към началото се подразбира и няма да бъде там, когато се очертава пътя.</p>
<p><a class="p_ident" id="p_6TyHPpw704" href="./16_canvas.html#p_6TyHPpw704"></a>Вие също може да използвате метода <code>closePath</code> изрично да затвори пътя, чрез добавяне на действителен сегмент линия обратно към началото на пътя. Този сегмент е съставен, когато се очератава пътя.</p>
<h2><a class="h_ident" id="h_B8g7k6vws+" href="./16_canvas.html#h_B8g7k6vws+"></a>Curves (криви линии)</h2>
<p><a class="p_ident" id="p_xee0Jzlsic" href="./16_canvas.html#p_xee0Jzlsic"></a>Пътя може да съдържа криви линии. Те са за съжаление, малко по-ангажиращи, от колкото правите линии.</p>
<p><a class="p_ident" id="p_q2PxOrpPav" href="./16_canvas.html#p_q2PxOrpPav"></a>Метода <code>quadraticCurveTo</code> чертае крива до дадена точка. За определяне на кривината на линията, е дадена една контролна точка, както и точка дестинация. Представете си, че тази контролна точка привлича линията и по този начин я изкривява. Линията не минава през контролната точка. По-скоро, посоката на линията от нейната начална и крайна точка, ще бъде такава, че да съвпадне с линията до контролната точка. Следващият пример илюстрира това.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_+OifyNljo7" href="./16_canvas.html#c_+OifyNljo7"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;&lt;/</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">cx</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"canvas"</span>).<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">beginPath</span>();
  <span class="cm-variable">cx</span>.<span class="cm-property">moveTo</span>(<span class="cm-number">10</span>, <span class="cm-number">90</span>);
  <span class="cm-comment">// control=(60,10) goal=(90,90)</span>
  <span class="cm-variable">cx</span>.<span class="cm-property">quadraticCurveTo</span>(<span class="cm-number">60</span>, <span class="cm-number">10</span>, <span class="cm-number">90</span>, <span class="cm-number">90</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">lineTo</span>(<span class="cm-number">60</span>, <span class="cm-number">10</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">closePath</span>();
  <span class="cm-variable">cx</span>.<span class="cm-property">stroke</span>();
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_OIjzl6Dc9Y" href="./16_canvas.html#p_OIjzl6Dc9Y"></a>Ние чертаем квадратна крива от ляво на дясно с (60,10), като контролна точка, а след това правим две отсечки, които минават през контролната точка и обратно до началото на линията. Резултата донякъде прилича на емблема на <em>Star Trek</em>. Можете да видите ефекта на контролната точка: лиите идващи от долните ъгли започват в посоката на контролната точка и след това изкривяват към целата си.</p>
<p><a class="p_ident" id="p_Nd10AmdUxD" href="./16_canvas.html#p_Nd10AmdUxD"></a> Метода <code>bezierCurveTo</code> чертае подобни криви. Но вместо една контролна точка, той използва 2 за всяка от крайните точки на линията. Това е скица, която илюстрира поведението на подобна крива.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_54UmXjaHEO" href="./16_canvas.html#c_54UmXjaHEO"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;&lt;/</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">cx</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"canvas"</span>).<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">beginPath</span>();
  <span class="cm-variable">cx</span>.<span class="cm-property">moveTo</span>(<span class="cm-number">10</span>, <span class="cm-number">90</span>);
  <span class="cm-comment">// control1=(10,10) control2=(90,10) goal=(50,90)</span>
  <span class="cm-variable">cx</span>.<span class="cm-property">bezierCurveTo</span>(<span class="cm-number">10</span>, <span class="cm-number">10</span>, <span class="cm-number">90</span>, <span class="cm-number">10</span>, <span class="cm-number">50</span>, <span class="cm-number">90</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">lineTo</span>(<span class="cm-number">90</span>, <span class="cm-number">10</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">lineTo</span>(<span class="cm-number">10</span>, <span class="cm-number">10</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">closePath</span>();
  <span class="cm-variable">cx</span>.<span class="cm-property">stroke</span>();
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_UVt0ID9CaV" href="./16_canvas.html#p_UVt0ID9CaV"></a>Двете контролни точки определят посоката на двата края на кривата. Колкото са по далеч от своята кореспондираща точка, толкова повече кривата ще е “изпъкнала” в тази посока.</p>
<p><a class="p_ident" id="p_tMRY3uv3sU" href="./16_canvas.html#p_tMRY3uv3sU"></a>С такива криви може да бъде трудно да се работи, не винаги е ясно, как да намерим контролните точки, които осигуряват формата, която търсим. Понякога може да се изчисли, а понякога ще трябва да се търси подходяща  стойност с метода на проба-грешка.</p>
<p><a class="p_ident" id="p_A4ndRHX5Et" href="./16_canvas.html#p_A4ndRHX5Et"></a><em>Arcs</em>-фрагментите на окръжности са по-лесни. Метода <code>arcTo</code> взема не по-малко от 5 аргумента. Първите четири аргумента действат малко, като аргументите на <code>quadraticCurveTo</code>. Първата двойка определя контролната точка, а втората двойка дестинацията на линията. Петият аргумент осигурява радиуса на дъгата. Метода концептуално проектира и ъгъл - линията отива до контролната точка и после до точката на дестинацията и с процента на ъгъла оформя част от кръга с дадения радиус. Метода <code>arcTo</code> чертае заоблената част, както и линията от началната точка до началото на заоблената част.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_6HNaUmfESZ" href="./16_canvas.html#c_6HNaUmfESZ"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;&lt;/</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">cx</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"canvas"</span>).<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">beginPath</span>();
  <span class="cm-variable">cx</span>.<span class="cm-property">moveTo</span>(<span class="cm-number">10</span>, <span class="cm-number">10</span>);
  <span class="cm-comment">// control=(90,10) goal=(90,90) radius=20</span>
  <span class="cm-variable">cx</span>.<span class="cm-property">arcTo</span>(<span class="cm-number">90</span>, <span class="cm-number">10</span>, <span class="cm-number">90</span>, <span class="cm-number">90</span>, <span class="cm-number">20</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">moveTo</span>(<span class="cm-number">10</span>, <span class="cm-number">10</span>);
  <span class="cm-comment">// control=(90,10) goal=(90,90) radius=80</span>
  <span class="cm-variable">cx</span>.<span class="cm-property">arcTo</span>(<span class="cm-number">90</span>, <span class="cm-number">10</span>, <span class="cm-number">90</span>, <span class="cm-number">90</span>, <span class="cm-number">80</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">stroke</span>();
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_+oDzi4kZW+" href="./16_canvas.html#p_+oDzi4kZW+"></a>Метода <code>arcTo</code> не чертае линия от края на заоблената част до целевата позиция, въпреки че думата <em>to</em> в неговото име загатва, че го прави. Можем да го свържем, като извикаме <code>lineTo</code> с координатите на същата цел за да добавим частта от линията.</p>
<p><a class="p_ident" id="p_amjPveUnsp" href="./16_canvas.html#p_amjPveUnsp"></a>За да начертаем кръг можем да използваме четири извиквания на <code>arcTo</code> (всяко по 90 градуса). Но метода <code>arc</code> осигурява по-лесен начин. Той взема чифт координати - център на дъгата, радиус и след това начало и край на ъгъла.</p>
<p><a class="p_ident" id="p_R0hMJ8VOzu" href="./16_canvas.html#p_R0hMJ8VOzu"></a>Тези последните два периметъра позволяват да се изготви само част от кръг. Ъглите се измерват в радиани, а не в градуси. Това означава, че пълен кръг има ъгъл 2π или <code>2 * Math.PI</code>, което е около 6.28. Ъгълът започва да се измерва от точка в дясно от центъра на кръга в посока по часовниковата стрелка. Можем да използваме за старт 0 и край по-голям 2π (да речем 7) за да направим пълен кръг.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_24IzNZRzqE" href="./16_canvas.html#c_24IzNZRzqE"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;&lt;/</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">cx</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"canvas"</span>).<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">beginPath</span>();
  <span class="cm-comment">// center=(50,50) radius=40 angle=0 to 7</span>
  <span class="cm-variable">cx</span>.<span class="cm-property">arc</span>(<span class="cm-number">50</span>, <span class="cm-number">50</span>, <span class="cm-number">40</span>, <span class="cm-number">0</span>, <span class="cm-number">7</span>);
  <span class="cm-comment">// center=(150,50) radius=40 angle=0 to ½π</span>
  <span class="cm-variable">cx</span>.<span class="cm-property">arc</span>(<span class="cm-number">150</span>, <span class="cm-number">50</span>, <span class="cm-number">40</span>, <span class="cm-number">0</span>, <span class="cm-number">0.5</span> <span class="cm-operator">*</span> <span class="cm-variable">Math</span>.<span class="cm-property">PI</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">stroke</span>();
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_NhI3gukqbY" href="./16_canvas.html#p_NhI3gukqbY"></a>Получената картина съдържа линия на дясно от пълния кръг (първото извикване на <code>arc</code>) и после в дясно четвърт кръг(второто извикване на <code>arc</code>). Подобно на метода за пътя, линията прекарана с arc е свързана с предишния сегмент по подразбиране. Ще трябва да извикате <code>moveTo</code> или да започнете нов път, ако искате да избегнете това.</p>
<h2 id="pie_chart"><a class="h_ident" id="h_9yOdkmATfT" href="./16_canvas.html#h_9yOdkmATfT"></a>Рисуване  на  кръгова  диаграма</h2>
<p><a class="p_ident" id="p_Rd++tqzkHn" href="./16_canvas.html#p_Rd++tqzkHn"></a>Представете си, че току-що сте почнали работа в EconomiCorp Inc и вашата първа задача е да направите кръгова диаграма на резултатите от техните изследвания за удовлетвореността на клиентите.</p>
<p><a class="p_ident" id="p_NOg95U8NVA" href="./16_canvas.html#p_NOg95U8NVA"></a>Променливата <code>results</code> съдържа масив от обекти, които представляват отговорите от проучването.</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="pie"><a class="c_ident" id="c_Wu/ylZx+Sb" href="./16_canvas.html#c_Wu/ylZx+Sb"></a><span class="cm-keyword">var</span> <span class="cm-variable">results</span> <span class="cm-operator">=</span> [
  {<span class="cm-property">name</span>: <span class="cm-string">"Satisfied"</span>, <span class="cm-property">count</span>: <span class="cm-number">1043</span>, <span class="cm-property">color</span>: <span class="cm-string">"lightblue"</span>},
  {<span class="cm-property">name</span>: <span class="cm-string">"Neutral"</span>, <span class="cm-property">count</span>: <span class="cm-number">563</span>, <span class="cm-property">color</span>: <span class="cm-string">"lightgreen"</span>},
  {<span class="cm-property">name</span>: <span class="cm-string">"Unsatisfied"</span>, <span class="cm-property">count</span>: <span class="cm-number">510</span>, <span class="cm-property">color</span>: <span class="cm-string">"pink"</span>},
  {<span class="cm-property">name</span>: <span class="cm-string">"No comment"</span>, <span class="cm-property">count</span>: <span class="cm-number">175</span>, <span class="cm-property">color</span>: <span class="cm-string">"silver"</span>}
];</pre>
<p><a class="p_ident" id="p_P3SJQbINGf" href="./16_canvas.html#p_P3SJQbINGf"></a>За да направим кръговата диаграма, ние рисуваме парчета от пай, всяко съставено от дъга и чифт линии към центъра на тази дъга. Можем да изчислим ъгъла на всяка дъга, като разделим пълния кръг (2π) на общия брой от отговорите и след това умножим този номер по броя на хората от даден избор.</p>
<pre data-language="text/html" class="snippet cm-s-default" data-sandbox="pie"><a class="c_ident" id="c_wLkuRg8oTT" href="./16_canvas.html#c_wLkuRg8oTT"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">canvas</span> <span class="cm-attribute">width</span>=<span class="cm-string">"200"</span> <span class="cm-attribute">height</span>=<span class="cm-string">"200"</span><span class="cm-tag cm-bracket">&gt;&lt;/</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">cx</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"canvas"</span>).<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);
  <span class="cm-keyword">var</span> <span class="cm-variable">total</span> <span class="cm-operator">=</span> <span class="cm-variable">results</span>.<span class="cm-property">reduce</span>(<span class="cm-keyword">function</span>(<span class="cm-def">sum</span>, <span class="cm-def">choice</span>) {
    <span class="cm-keyword">return</span> <span class="cm-variable-2">sum</span> <span class="cm-operator">+</span> <span class="cm-variable-2">choice</span>.<span class="cm-property">count</span>;
  }, <span class="cm-number">0</span>);
  <span class="cm-comment">// Start at the top</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">currentAngle</span> <span class="cm-operator">=</span> <span class="cm-operator">-</span><span class="cm-number">0.5</span> <span class="cm-operator">*</span> <span class="cm-variable">Math</span>.<span class="cm-property">PI</span>;
  <span class="cm-variable">results</span>.<span class="cm-property">forEach</span>(<span class="cm-keyword">function</span>(<span class="cm-def">result</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">sliceAngle</span> <span class="cm-operator">=</span> (<span class="cm-variable-2">result</span>.<span class="cm-property">count</span> <span class="cm-operator">/</span> <span class="cm-variable">total</span>) <span class="cm-operator">*</span> <span class="cm-number">2</span> <span class="cm-operator">*</span> <span class="cm-variable">Math</span>.<span class="cm-property">PI</span>;
    <span class="cm-variable">cx</span>.<span class="cm-property">beginPath</span>();
    <span class="cm-comment">// center=100,100, radius=100</span>
    <span class="cm-comment">// from current angle, clockwise by slice's angle</span>
    <span class="cm-variable">cx</span>.<span class="cm-property">arc</span>(<span class="cm-number">100</span>, <span class="cm-number">100</span>, <span class="cm-number">100</span>,
           <span class="cm-variable">currentAngle</span>, <span class="cm-variable">currentAngle</span> <span class="cm-operator">+</span> <span class="cm-variable-2">sliceAngle</span>);
    <span class="cm-variable">currentAngle</span> <span class="cm-operator">+=</span> <span class="cm-variable-2">sliceAngle</span>;
    <span class="cm-variable">cx</span>.<span class="cm-property">lineTo</span>(<span class="cm-number">100</span>, <span class="cm-number">100</span>);
    <span class="cm-variable">cx</span>.<span class="cm-property">fillStyle</span> <span class="cm-operator">=</span> <span class="cm-variable-2">result</span>.<span class="cm-property">color</span>;
    <span class="cm-variable">cx</span>.<span class="cm-property">fill</span>();
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_e5+MpAPZp1" href="./16_canvas.html#p_e5+MpAPZp1"></a>Но диаграмата не ни казва, какво означава, което не е много полезно. Имаме нужда да вкараме текст във платното.</p>
<h2><a class="h_ident" id="h_wzKMObDin3" href="./16_canvas.html#h_wzKMObDin3"></a>Текст</h2>
<p><a class="p_ident" id="p_/MkzAT+yJW" href="./16_canvas.html#p_/MkzAT+yJW"></a>2D контекста на платното за рисуване осигурява методите <code>fillText</code> и <code>strokeText</code>. Последния е полезен за очертаване на букви, но обикновено <code>fillText</code> е този, който ни трябва. Той запълва даден текст с текущия <code>fillColor</code>.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_Q1AmUAb2Hj" href="./16_canvas.html#c_Q1AmUAb2Hj"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;&lt;/</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">cx</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"canvas"</span>).<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">font</span> <span class="cm-operator">=</span> <span class="cm-string">"28px Georgia"</span>;
  <span class="cm-variable">cx</span>.<span class="cm-property">fillStyle</span> <span class="cm-operator">=</span> <span class="cm-string">"fuchsia"</span>;
  <span class="cm-variable">cx</span>.<span class="cm-property">fillText</span>(<span class="cm-string">"I can draw text, too!"</span>, <span class="cm-number">10</span>, <span class="cm-number">50</span>);
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_n79D894g2i" href="./16_canvas.html#p_n79D894g2i"></a>Можем да определим размера, стила и шрифта със свойството <code>font</code>. Този пример само дава размера на шрифта и <em>family name</em>. Можем да добавим <code>italic</code> или <code>bold</code> в началото на <em>string</em>-а за да изберем стил.</p>
<p><a class="p_ident" id="p_3LlDU7wt/M" href="./16_canvas.html#p_3LlDU7wt/M"></a>Последните два аргумента на <code>fillText</code> (и <code>strokeText</code>) осигуряват място, където се изготвя шрифта. По подразбиране, те показват позицията на началото на азбучната основа на текста, това на коя линия стоят буквите, без да брои части за манипулиране, като <em>j</em> или <em>p</em>. Можем да променим хоризонталното положение, като настроим <code>textAlign</code> свойството да е <code>"end"</code> или <code>"center"</code> и вертикалното положение, като зададем на <code>textBaseline</code> да е <code>"top"</code>, <code>"middle"</code> или <code>"bottom"</code>.</p>
<p><a class="p_ident" id="p_/4NicYFaZd" href="./16_canvas.html#p_/4NicYFaZd"></a>Ще се върнем към нашата кръгова диаграма и проблемът с етикетиране на резените в <a href="./16_canvas.html#exercise_pie_chart">упражненията</a> на края на главата.</p>
<h2><a class="h_ident" id="h_CehxyY/vO5" href="./16_canvas.html#h_CehxyY/vO5"></a>Снимки (images)</h2>
<p><a class="p_ident" id="p_y7aK+8CMcM" href="./16_canvas.html#p_y7aK+8CMcM"></a>В компютърната графика често се прави разграничение между векторни и растерни графики. Първото е това, което правихме до сега в тази глава - уточняване на картина, като и се дава логическо описание на формите. Растерните графики, от друга страна не определят действителните форми, а работят с точкови данни (растери на цветни точки).</p>
<p><a class="p_ident" id="p_qlIKv8QV+7" href="./16_canvas.html#p_qlIKv8QV+7"></a>Метода <code>drawImage</code> ни позволява да изготвим пикселни данни върху платното. Тези пикселни данни могат да произхождат от  един <code>&lt;img&gt;</code> елемент или от друго платно, нито пък да бъдат видими в самия документ. Следващият пример създава самостоятелен <code>&lt;img&gt;</code> елемент и зарежда файл с изображение в него. Но не можем веднага за започнем да ползваме тази снимка, понеже браузърът не може да я донесе все още. За да направим това, трябва да регистрираме <code>"load"</code> за боравене със събития и да направим чертежа, след като изображението е заредено.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_OAnOFm8i7l" href="./16_canvas.html#c_OAnOFm8i7l"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;&lt;/</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">cx</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"canvas"</span>).<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);
  <span class="cm-keyword">var</span> <span class="cm-variable">img</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">createElement</span>(<span class="cm-string">"img"</span>);
  <span class="cm-variable">img</span>.<span class="cm-property">src</span> <span class="cm-operator">=</span> <span class="cm-string">"img/hat.png"</span>;
  <span class="cm-variable">img</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"load"</span>, <span class="cm-keyword">function</span>() {
    <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">x</span> <span class="cm-operator">=</span> <span class="cm-number">10</span>; <span class="cm-variable-2">x</span> <span class="cm-operator">&lt;</span> <span class="cm-number">200</span>; <span class="cm-variable-2">x</span> <span class="cm-operator">+=</span> <span class="cm-number">30</span>)
      <span class="cm-variable">cx</span>.<span class="cm-property">drawImage</span>(<span class="cm-variable">img</span>, <span class="cm-variable-2">x</span>, <span class="cm-number">10</span>);
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_RxRhSVTbGY" href="./16_canvas.html#p_RxRhSVTbGY"></a>По подразбиране <code>drawImage</code> ще изготви изображението в оригиналния му размер. Можем също така да му дадем два допълнителни аргумента за промяна на ширината и височината.</p>
<p><a class="p_ident" id="p_/bLIqvw4R4" href="./16_canvas.html#p_/bLIqvw4R4"></a>Когато на <code>drawImage</code> са дадени девет аргумента, може да се използва за да се направи само един фрагмент от изображението. От втория до петия аргумент посочват правоъгълника (Х , У , ширина , височина) на изображението източник, което трябва да бъде копирано, а от шести до девети аргумент посочват правоъгълника (на платното), в който трябва да се копира изображението.</p>
<p><a class="p_ident" id="p_xKlo8wmmgJ" href="./16_canvas.html#p_xKlo8wmmgJ"></a>Това може да се използва за опаковане на множество <em>sprites</em> (спрайтове - елементи на снимка) в един файл с изображение, а след това да се направи само частта от която се нуждаем. Например, имаме тази картина съдържаща един герой в няколко пози.</p>
<div class="image">
  <img src="./media/player_big.png" alt="Various poses of a game character">
</div>
<p><a class="p_ident" id="p_u8W4Vqh39a" href="./16_canvas.html#p_u8W4Vqh39a"></a>С редуващи се пози, можем да покажем анимация, която прилича на ходене на героя.</p>
<p><a class="p_ident" id="p_vwSjUDbC98" href="./16_canvas.html#p_vwSjUDbC98"></a>За да анимираме тази снимка на платното, <code>clearRect</code> метода ще ни е полезен. Той прилича на <code>fillRect</code> но вместо да оцветява правоъгълника, той го прави прозрачен, премахва предварително изготвените пиксели.</p>
<p><a class="p_ident" id="p_VcrdBA3T8z" href="./16_canvas.html#p_VcrdBA3T8z"></a>Ние знаем, че всеки спрайт (всяка под-картинка), е 24 пиксела широка и 30 пиксела висока. Следният код зарежда изображението и след това създава интервал (повтарящ се таймер) за да изготви следващия кадър.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_w48FwMDvG4" href="./16_canvas.html#c_w48FwMDvG4"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;&lt;/</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">cx</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"canvas"</span>).<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);
  <span class="cm-keyword">var</span> <span class="cm-variable">img</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">createElement</span>(<span class="cm-string">"img"</span>);
  <span class="cm-variable">img</span>.<span class="cm-property">src</span> <span class="cm-operator">=</span> <span class="cm-string">"img/player.png"</span>;
  <span class="cm-keyword">var</span> <span class="cm-variable">spriteW</span> <span class="cm-operator">=</span> <span class="cm-number">24</span>, <span class="cm-variable">spriteH</span> <span class="cm-operator">=</span> <span class="cm-number">30</span>;
  <span class="cm-variable">img</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"load"</span>, <span class="cm-keyword">function</span>() {
    <span class="cm-keyword">var</span> <span class="cm-def">cycle</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>;
    <span class="cm-variable">setInterval</span>(<span class="cm-keyword">function</span>() {
      <span class="cm-variable">cx</span>.<span class="cm-property">clearRect</span>(<span class="cm-number">0</span>, <span class="cm-number">0</span>, <span class="cm-variable">spriteW</span>, <span class="cm-variable">spriteH</span>);
      <span class="cm-variable">cx</span>.<span class="cm-property">drawImage</span>(<span class="cm-variable">img</span>,
                   <span class="cm-comment">// source rectangle</span>
                   <span class="cm-variable-2">cycle</span> <span class="cm-operator">*</span> <span class="cm-variable">spriteW</span>, <span class="cm-number">0</span>, <span class="cm-variable">spriteW</span>, <span class="cm-variable">spriteH</span>,
                   <span class="cm-comment">// destination rectangle</span>
                   <span class="cm-number">0</span>,               <span class="cm-number">0</span>, <span class="cm-variable">spriteW</span>, <span class="cm-variable">spriteH</span>);
      <span class="cm-variable-2">cycle</span> <span class="cm-operator">=</span> (<span class="cm-variable-2">cycle</span> <span class="cm-operator">+</span> <span class="cm-number">1</span>) <span class="cm-operator">%</span> <span class="cm-number">8</span>;
    }, <span class="cm-number">120</span>);
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_FwoYTH1Pg7" href="./16_canvas.html#p_FwoYTH1Pg7"></a>Променливата <code>cycle</code> следи нашата позиция в анимацията. С всяка рамка тя се увеличава се връща обратно в 0-7 диапазона с помощта на оператора за остатък. Тази променлива се използва за изчисляване на х-координатите на спрайта за текущата поза в картината.</p>
<h2><a class="h_ident" id="h_3BwjEnWhbh" href="./16_canvas.html#h_3BwjEnWhbh"></a>Трансформация</h2>
<p><a class="p_ident" id="p_b00lbwHiev" href="./16_canvas.html#p_b00lbwHiev"></a>Но ако искаме нашия герой да ходи на ляво вместо на дясно? Можем да добавим още един набор от спрайтове, разбира се. Но също така може да възложим на платното да направи снимката обратно.</p>
<p><a class="p_ident" id="p_JnX4LFnuKL" href="./16_canvas.html#p_JnX4LFnuKL"></a>Извиквайки <code>scale</code> метода ще доведе до нещо изготвено след това да бъде намалено. Този метод взема два параметъра, един да създаде хоризонтален мащаб и един за задаване на вертикална скала.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_jcUQ4xDEVZ" href="./16_canvas.html#c_jcUQ4xDEVZ"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;&lt;/</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">cx</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"canvas"</span>).<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">scale</span>(<span class="cm-number">3</span>, <span class="cm-number">.5</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">beginPath</span>();
  <span class="cm-variable">cx</span>.<span class="cm-property">arc</span>(<span class="cm-number">50</span>, <span class="cm-number">50</span>, <span class="cm-number">40</span>, <span class="cm-number">0</span>, <span class="cm-number">7</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">lineWidth</span> <span class="cm-operator">=</span> <span class="cm-number">3</span>;
  <span class="cm-variable">cx</span>.<span class="cm-property">stroke</span>();
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_u+8/LLl96H" href="./16_canvas.html#p_u+8/LLl96H"></a>Мащабирането ще вземе всичко за  рисувания двойник, включително ширината на линията, която трябва да бъде разтегната или стеснена, както е посочено. Мащабиране с отрицателна сума ще обърне картинката. Огледалното обръщане се случва в точка (0, 0), което означава, че също ще обърне посоката на координатната система. Когато се прилага хоризонтално мащабиране с използване на -1, формата начертана на позиция х 100 , ще се прехвърли на позиция -100.</p>
<p><a class="p_ident" id="p_bZnJ+aZtFS" href="./16_canvas.html#p_bZnJ+aZtFS"></a>Така че, за да обърнем една картина, не можем просто да добавим <code>cx.scale(-1, 1)</code>, тъй като това би преместило нашата картина извън платното, където тя няма да се вижда. Може да регулираме координатите дадени на <code>drawImage</code> да компенсира това чрез изтегляне на образа в позиция х -50 вместо 0. Друго решение, което не изисква код, който да променя мащаба на рисунката, е да се коригира оста, около която мащабирането се случва.</p>
<p><a class="p_ident" id="p_LbiF7s9yt4" href="./16_canvas.html#p_LbiF7s9yt4"></a>Има няколко други метода освен <code>scale</code> , които влияят на координатната система на платното. Можем да завъртим в последствие начертаните форми с <code>rotate</code> метода и да ги преместим с <code>translate</code> метода. Заинтригуващо и объркващо е, че тези трансформации се натупват, което означава, че всяка следваща се случва в сравнение с предишната трансформация.</p>
<p><a class="p_ident" id="p_mkNUtuNxcG" href="./16_canvas.html#p_mkNUtuNxcG"></a>Така че, ако се транслира с 10 хоризонтални пиксела два пъти, всичко ще бъде изтеглено на 20 пиксела надясно. Ние първо трябва да преместим центъра на координатната система на (50, 50) и след това да завъртим с 20 градуса (0.1π в радиани), така че въртенето да се случи в точка (50, 50).</p>
<div class="image">
  <img src="./media/transform.svg" alt="Stacking transformations">
</div>
<p><a class="p_ident" id="p_TGBwm05/cn" href="./16_canvas.html#p_TGBwm05/cn"></a>Но ако първо завъртим с 20 градуса и след това транслираме с (50, 50) транслацията ще се случи в завъртяна координатна система и по този начин ще се произведе различна ориентация. Редът, в който трябва да се случва трансформацията е приложна материя.</p>
<p><a class="p_ident" id="p_9a1O8aEtUA" href="./16_canvas.html#p_9a1O8aEtUA"></a>За да обърнем картината около вертикалната линия в дадено х- положение можем да направим следното:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_81ITeF67ab" href="./16_canvas.html#c_81ITeF67ab"></a><span class="cm-keyword">function</span> <span class="cm-variable">flipHorizontally</span>(<span class="cm-def">context</span>, <span class="cm-def">around</span>) {
  <span class="cm-variable-2">context</span>.<span class="cm-property">translate</span>(<span class="cm-variable-2">around</span>, <span class="cm-number">0</span>);
  <span class="cm-variable-2">context</span>.<span class="cm-property">scale</span>(<span class="cm-operator">-</span><span class="cm-number">1</span>, <span class="cm-number">1</span>);
  <span class="cm-variable-2">context</span>.<span class="cm-property">translate</span>(<span class="cm-operator">-</span><span class="cm-variable-2">around</span>, <span class="cm-number">0</span>);
}</pre>
<p><a class="p_ident" id="p_qob4Y7lZ5I" href="./16_canvas.html#p_qob4Y7lZ5I"></a>Ние преместваме оста у , където искаме да бъде нашето огледало, за да приложим огледалното отражение и накрая преместваме оста у обратно в нейното определено място в огледалната система. Следната картинка обяснява, защото това работи:</p>
<div class="image">
  <img src="./media/mirror.svg" alt="Mirroring around a vertical line">
</div>
<p><a class="p_ident" id="p_AGahdKv9Zv" href="./16_canvas.html#p_AGahdKv9Zv"></a>Това показва координатната система преди и след, отразявайки я през централната линия. Ако се направи триъгълник в положение  х-позиция, по подразбиране това е мястото, където е триъгълник 1. Извикването на <code>flipHorizontally</code> първо прави транслация на дясно, което ни отвежда до триъгълник 2. След мащабирането, обръща триъгълника обратно в позиция 3. Но това не е мястото, където трябва да бъде отразено от дадената линия. Второто извикване на <code>translate</code> поправя това - то анулира първоначалната транслация и прави триъгълник 4 да се появи точно там, където трябва.</p>
<p><a class="p_ident" id="p_akkrexzSeV" href="./16_canvas.html#p_akkrexzSeV"></a>Сега можем да нарисуваме огледален герой на позиция (100, 0) с обръщане на картината около вертикалния център на героя.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_v9+6Eb8JBI" href="./16_canvas.html#c_v9+6Eb8JBI"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;&lt;/</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">cx</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"canvas"</span>).<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);
  <span class="cm-keyword">var</span> <span class="cm-variable">img</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">createElement</span>(<span class="cm-string">"img"</span>);
  <span class="cm-variable">img</span>.<span class="cm-property">src</span> <span class="cm-operator">=</span> <span class="cm-string">"img/player.png"</span>;
  <span class="cm-keyword">var</span> <span class="cm-variable">spriteW</span> <span class="cm-operator">=</span> <span class="cm-number">24</span>, <span class="cm-variable">spriteH</span> <span class="cm-operator">=</span> <span class="cm-number">30</span>;
  <span class="cm-variable">img</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"load"</span>, <span class="cm-keyword">function</span>() {
    <span class="cm-variable">flipHorizontally</span>(<span class="cm-variable">cx</span>, <span class="cm-number">100</span> <span class="cm-operator">+</span> <span class="cm-variable">spriteW</span> <span class="cm-operator">/</span> <span class="cm-number">2</span>);
    <span class="cm-variable">cx</span>.<span class="cm-property">drawImage</span>(<span class="cm-variable">img</span>, <span class="cm-number">0</span>, <span class="cm-number">0</span>, <span class="cm-variable">spriteW</span>, <span class="cm-variable">spriteH</span>,
                 <span class="cm-number">100</span>, <span class="cm-number">0</span>, <span class="cm-variable">spriteW</span>, <span class="cm-variable">spriteH</span>);
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<h2><a class="h_ident" id="h_Z+iS7LhRr9" href="./16_canvas.html#h_Z+iS7LhRr9"></a>Съхраняване  и  изчистване  на трансформации</h2>
<p><a class="p_ident" id="p_Az5iI5GbrT" href="./16_canvas.html#p_Az5iI5GbrT"></a>Натрупването на трансформации е наоколо. Всичко останало чертаем след изготвянето на огледалния символ и го съпоставяме. Това може да е проблем.</p>
<p><a class="p_ident" id="p_4R4LetOdqr" href="./16_canvas.html#p_4R4LetOdqr"></a>Възможно е да запишем текущата трансформация, някои правят така рисуват и трансформират, а след това възстановяват старата трансформация. Това обикновено е правилното нещо, което трябва да направи дадена функция, която трябва да трансформира временно координатната система. Първо запазваме трансформационния код, който извиканата функция използва. След това функцията върши нещо (използвайки съществуващата трансформация ), евентуално добавяне на още трансформации. И на края се връща към трансформацията, с която сме започнали.</p>
<p><a class="p_ident" id="p_65OomGfaeV" href="./16_canvas.html#p_65OomGfaeV"></a>Методите <code>save</code> и <code>restore</code> в контекста на 2D върху платното, извършват този вид управление на трансформация. Те концептуално запазват натрупванията на трансформации. Когато извикаме <code>save</code> текущото състояние се вкарва в стека, а когато се извика <code>restore</code> състоянието на върха на стека се изважда и се използва, като контекст на настоящата трансформация.</p>
<p><a class="p_ident" id="p_+U4XOiej4f" href="./16_canvas.html#p_+U4XOiej4f"></a>Функцията <code>branch</code> в следващия пример илюстрира, какво може да направим с функция, която променя трансформацията и след това призовава друга функция (в този случай себе си), която продължава  рисуването в дадената трансформация.</p>
<p><a class="p_ident" id="p_2U+6WbJ0Or" href="./16_canvas.html#p_2U+6WbJ0Or"></a>Тази функция чертае <em>treelike</em> (дървовидна) фигура с чертаеща линия, премествайки центъра на координатната система в края на линията и извикваща себе си два пъти - първо завърта на ляво, а след това на дясно. Всяко извикване намалява дължината на изготвянето на клона и рекурсията спира, когато дължината падне под 8.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_Dj0p46rTuu" href="./16_canvas.html#c_Dj0p46rTuu"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">canvas</span> <span class="cm-attribute">width</span>=<span class="cm-string">"600"</span> <span class="cm-attribute">height</span>=<span class="cm-string">"300"</span><span class="cm-tag cm-bracket">&gt;&lt;/</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">cx</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"canvas"</span>).<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);
  <span class="cm-keyword">function</span> <span class="cm-variable">branch</span>(<span class="cm-def">length</span>, <span class="cm-def">angle</span>, <span class="cm-def">scale</span>) {
    <span class="cm-variable">cx</span>.<span class="cm-property">fillRect</span>(<span class="cm-number">0</span>, <span class="cm-number">0</span>, <span class="cm-number">1</span>, <span class="cm-variable-2">length</span>);
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">length</span> <span class="cm-operator">&lt;</span> <span class="cm-number">8</span>) <span class="cm-keyword">return</span>;
    <span class="cm-variable">cx</span>.<span class="cm-property">save</span>();
    <span class="cm-variable">cx</span>.<span class="cm-property">translate</span>(<span class="cm-number">0</span>, <span class="cm-variable-2">length</span>);
    <span class="cm-variable">cx</span>.<span class="cm-property">rotate</span>(<span class="cm-operator">-</span><span class="cm-variable-2">angle</span>);
    <span class="cm-variable">branch</span>(<span class="cm-variable-2">length</span> <span class="cm-operator">*</span> <span class="cm-variable-2">scale</span>, <span class="cm-variable-2">angle</span>, <span class="cm-variable-2">scale</span>);
    <span class="cm-variable">cx</span>.<span class="cm-property">rotate</span>(<span class="cm-number">2</span> <span class="cm-operator">*</span> <span class="cm-variable-2">angle</span>);
    <span class="cm-variable">branch</span>(<span class="cm-variable-2">length</span> <span class="cm-operator">*</span> <span class="cm-variable-2">scale</span>, <span class="cm-variable-2">angle</span>, <span class="cm-variable-2">scale</span>);
    <span class="cm-variable">cx</span>.<span class="cm-property">restore</span>();
  }
  <span class="cm-variable">cx</span>.<span class="cm-property">translate</span>(<span class="cm-number">300</span>, <span class="cm-number">0</span>);
  <span class="cm-variable">branch</span>(<span class="cm-number">60</span>, <span class="cm-number">0.5</span>, <span class="cm-number">0.8</span>);
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_Fr9r9ZmPHu" href="./16_canvas.html#p_Fr9r9ZmPHu"></a>Ако извикванията на <code>save</code> и <code>restore</code> не бяха направени, второто рекурсивно извикване на <code>branch</code> ще се окаже в позицията и въртенето на първото извикване. То няма да бъде свързано към сегашното дърво, а по-скоро към най-вътрешния, най-десния клон на дървото съставено от първото извикване. Получената форма може да бъде интересна, но това не е рисунка на дърво.</p>
<h2 id="canvasdisplay"><a class="h_ident" id="h_TOqgrv5vzl" href="./16_canvas.html#h_TOqgrv5vzl"></a>Обратно  в  играта</h2>
<p><a class="p_ident" id="p_v/iifj4dhd" href="./16_canvas.html#p_v/iifj4dhd"></a>Сега вече знаем достатъчно за платното за рисуване, за да можем да работим върху базовото платно на дисплей системата на играта от <a href="./15_game.html#game">предишната глава</a>. Новият дисплей вече няма да показва само цветни кутии. Вместо това ще използваме <code>drawImage</code> да рисуваме картини, които представляват елементи на играта.</p>
<p><a class="p_ident" id="p_dy1myCUsaF" href="./16_canvas.html#p_dy1myCUsaF"></a>Първо ще определим типа на обекта на <code>CanvasDisplay</code> подкрепящ същия интерфейс, както <code>DOMDisplay</code> от <a href="./15_game.html#domdisplay">Глава 15</a>, а именно методите <code>drawFrame</code> и <code>clear</code>.</p>
<p><a class="p_ident" id="p_H/XEh6pFg7" href="./16_canvas.html#p_H/XEh6pFg7"></a>Този обект съдържа малко повече информация от колкото <code>DOMDisplay</code>. Вместо да използва позицията за скролване на своя DOM елемент, той проследява собствения си демонстрационен прозорец, който ни казва, каква част от нивото гледаме в момента. Той също така проследява времето и употребата му, за да реши коя анимационна рамка да използва. И най-накрая, поддържа <code>flipPlayer</code> свойството, така че дори когато играчът стои на едно място, е с лице обърнато в посоката на последното преместване.</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="game"><a class="c_ident" id="c_HHQyVLbj+1" href="./16_canvas.html#c_HHQyVLbj+1"></a><span class="cm-keyword">function</span> <span class="cm-variable">CanvasDisplay</span>(<span class="cm-def">parent</span>, <span class="cm-def">level</span>) {
  <span class="cm-keyword">this</span>.<span class="cm-property">canvas</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">createElement</span>(<span class="cm-string">"canvas"</span>);
  <span class="cm-keyword">this</span>.<span class="cm-property">canvas</span>.<span class="cm-property">width</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">min</span>(<span class="cm-number">600</span>, <span class="cm-variable-2">level</span>.<span class="cm-property">width</span> <span class="cm-operator">*</span> <span class="cm-variable">scale</span>);
  <span class="cm-keyword">this</span>.<span class="cm-property">canvas</span>.<span class="cm-property">height</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">min</span>(<span class="cm-number">450</span>, <span class="cm-variable-2">level</span>.<span class="cm-property">height</span> <span class="cm-operator">*</span> <span class="cm-variable">scale</span>);
  <span class="cm-variable-2">parent</span>.<span class="cm-property">appendChild</span>(<span class="cm-keyword">this</span>.<span class="cm-property">canvas</span>);
  <span class="cm-keyword">this</span>.<span class="cm-property">cx</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">canvas</span>.<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);

  <span class="cm-keyword">this</span>.<span class="cm-property">level</span> <span class="cm-operator">=</span> <span class="cm-variable-2">level</span>;
  <span class="cm-keyword">this</span>.<span class="cm-property">animationTime</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>;
  <span class="cm-keyword">this</span>.<span class="cm-property">flipPlayer</span> <span class="cm-operator">=</span> <span class="cm-atom">false</span>;

  <span class="cm-keyword">this</span>.<span class="cm-property">viewport</span> <span class="cm-operator">=</span> {
    <span class="cm-property">left</span>: <span class="cm-number">0</span>,
    <span class="cm-property">top</span>: <span class="cm-number">0</span>,
    <span class="cm-property">width</span>: <span class="cm-keyword">this</span>.<span class="cm-property">canvas</span>.<span class="cm-property">width</span> <span class="cm-operator">/</span> <span class="cm-variable">scale</span>,
    <span class="cm-property">height</span>: <span class="cm-keyword">this</span>.<span class="cm-property">canvas</span>.<span class="cm-property">height</span> <span class="cm-operator">/</span> <span class="cm-variable">scale</span>
  };

  <span class="cm-keyword">this</span>.<span class="cm-property">drawFrame</span>(<span class="cm-number">0</span>);
}

<span class="cm-variable">CanvasDisplay</span>.<span class="cm-property">prototype</span>.<span class="cm-property">clear</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>() {
  <span class="cm-keyword">this</span>.<span class="cm-property">canvas</span>.<span class="cm-property">parentNode</span>.<span class="cm-property">removeChild</span>(<span class="cm-keyword">this</span>.<span class="cm-property">canvas</span>);
};</pre>
<p><a class="p_ident" id="p_blt6VbEw4l" href="./16_canvas.html#p_blt6VbEw4l"></a>Брояча <code>animationTime</code> е причината, поради която подадохме размерът на стъпката на <code>drawFrame</code> в
<a href="./15_game.html#domdisplay">Глава 15</a>, въпреки че <code>DOMDisplay</code> не го използва. Нашата нова <code>drawFrame</code> функция използва брояча за проследяване на времето, така че да може да превключваме между анимационните рамки основани на текущото време.</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="game"><a class="c_ident" id="c_L5SVcjdikr" href="./16_canvas.html#c_L5SVcjdikr"></a><span class="cm-variable">CanvasDisplay</span>.<span class="cm-property">prototype</span>.<span class="cm-property">drawFrame</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">step</span>) {
  <span class="cm-keyword">this</span>.<span class="cm-property">animationTime</span> <span class="cm-operator">+=</span> <span class="cm-variable-2">step</span>;

  <span class="cm-keyword">this</span>.<span class="cm-property">updateViewport</span>();
  <span class="cm-keyword">this</span>.<span class="cm-property">clearDisplay</span>();
  <span class="cm-keyword">this</span>.<span class="cm-property">drawBackground</span>();
  <span class="cm-keyword">this</span>.<span class="cm-property">drawActors</span>();
};</pre>
<p><a class="p_ident" id="p_hwAtbz1fs3" href="./16_canvas.html#p_hwAtbz1fs3"></a>Другите които ползват проследяването на времето са методът за актуализиране на изгледа на текущата позиция на играчите, чертане на фона, изпълването на цялото платно с фонов цвят и актьорите върху него. Имайте в предвид, че това е различен подход от този в <a href="./15_game.html#domdisplay">Глава 15</a>, където чертаем фона веднъж и скролваме опакования DOM елемент за да го преместим.</p>
<p><a class="p_ident" id="p_sX9ENmCEO9" href="./16_canvas.html#p_sX9ENmCEO9"></a>Защото формите на платното са само пиксели и след като ги начертаем няма начин да ги преместим (или отстраним). Единствения начин да се актуализира дисплея на платното е да го изчистим и преначертаем сцената отново.</p>
<p><a class="p_ident" id="p_Kn4mJDmduk" href="./16_canvas.html#p_Kn4mJDmduk"></a>Методът <code>updateViewport</code> е подобен на <code>DOMDisplay</code>-скрол метода <code>scrollPlayerIntoView</code>. Той проверява дали играчът е твърде близо до ръба на екрана и движи изгледа, когато случаят е такъв.</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="game"><a class="c_ident" id="c_MzrEz+RF51" href="./16_canvas.html#c_MzrEz+RF51"></a><span class="cm-variable">CanvasDisplay</span>.<span class="cm-property">prototype</span>.<span class="cm-property">updateViewport</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>() {
  <span class="cm-keyword">var</span> <span class="cm-def">view</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">viewport</span>, <span class="cm-def">margin</span> <span class="cm-operator">=</span> <span class="cm-variable-2">view</span>.<span class="cm-property">width</span> <span class="cm-operator">/</span> <span class="cm-number">3</span>;
  <span class="cm-keyword">var</span> <span class="cm-def">player</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">level</span>.<span class="cm-property">player</span>;
  <span class="cm-keyword">var</span> <span class="cm-def">center</span> <span class="cm-operator">=</span> <span class="cm-variable-2">player</span>.<span class="cm-property">pos</span>.<span class="cm-property">plus</span>(<span class="cm-variable-2">player</span>.<span class="cm-property">size</span>.<span class="cm-property">times</span>(<span class="cm-number">0.5</span>));

  <span class="cm-keyword">if</span> (<span class="cm-variable-2">center</span>.<span class="cm-property">x</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">view</span>.<span class="cm-property">left</span> <span class="cm-operator">+</span> <span class="cm-variable-2">margin</span>)
    <span class="cm-variable-2">view</span>.<span class="cm-property">left</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">max</span>(<span class="cm-variable-2">center</span>.<span class="cm-property">x</span> <span class="cm-operator">-</span> <span class="cm-variable-2">margin</span>, <span class="cm-number">0</span>);
  <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">center</span>.<span class="cm-property">x</span> <span class="cm-operator">&gt;</span> <span class="cm-variable-2">view</span>.<span class="cm-property">left</span> <span class="cm-operator">+</span> <span class="cm-variable-2">view</span>.<span class="cm-property">width</span> <span class="cm-operator">-</span> <span class="cm-variable-2">margin</span>)
    <span class="cm-variable-2">view</span>.<span class="cm-property">left</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">min</span>(<span class="cm-variable-2">center</span>.<span class="cm-property">x</span> <span class="cm-operator">+</span> <span class="cm-variable-2">margin</span> <span class="cm-operator">-</span> <span class="cm-variable-2">view</span>.<span class="cm-property">width</span>,
                         <span class="cm-keyword">this</span>.<span class="cm-property">level</span>.<span class="cm-property">width</span> <span class="cm-operator">-</span> <span class="cm-variable-2">view</span>.<span class="cm-property">width</span>);
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">center</span>.<span class="cm-property">y</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">view</span>.<span class="cm-property">top</span> <span class="cm-operator">+</span> <span class="cm-variable-2">margin</span>)
    <span class="cm-variable-2">view</span>.<span class="cm-property">top</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">max</span>(<span class="cm-variable-2">center</span>.<span class="cm-property">y</span> <span class="cm-operator">-</span> <span class="cm-variable-2">margin</span>, <span class="cm-number">0</span>);
  <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">center</span>.<span class="cm-property">y</span> <span class="cm-operator">&gt;</span> <span class="cm-variable-2">view</span>.<span class="cm-property">top</span> <span class="cm-operator">+</span> <span class="cm-variable-2">view</span>.<span class="cm-property">height</span> <span class="cm-operator">-</span> <span class="cm-variable-2">margin</span>)
    <span class="cm-variable-2">view</span>.<span class="cm-property">top</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">min</span>(<span class="cm-variable-2">center</span>.<span class="cm-property">y</span> <span class="cm-operator">+</span> <span class="cm-variable-2">margin</span> <span class="cm-operator">-</span> <span class="cm-variable-2">view</span>.<span class="cm-property">height</span>,
                        <span class="cm-keyword">this</span>.<span class="cm-property">level</span>.<span class="cm-property">height</span> <span class="cm-operator">-</span> <span class="cm-variable-2">view</span>.<span class="cm-property">height</span>);
};</pre>
<p><a class="p_ident" id="p_qSUMwlAFeW" href="./16_canvas.html#p_qSUMwlAFeW"></a>Извикванията на <code>Math.max</code> и <code>Math.min</code> гарантират, че демонстрационния прозорец не показва пространството извън нивото. <code>Math.max(x, 0)</code> гарантира, че полученият брой не е по-малък то нула. <code>Math.min</code> по подобен начин, подсигурява стойността да стои под определената граница.</p>
<p><a class="p_ident" id="p_uxQ4EAtiQh" href="./16_canvas.html#p_uxQ4EAtiQh"></a>При спиране на дисплея, ще използваме по-различен цвят в зависимост от това дали играча печели (по-светло) или губи (по-тъмно).</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="game"><a class="c_ident" id="c_o8QL4qiSHv" href="./16_canvas.html#c_o8QL4qiSHv"></a><span class="cm-variable">CanvasDisplay</span>.<span class="cm-property">prototype</span>.<span class="cm-property">clearDisplay</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>() {
  <span class="cm-keyword">if</span> (<span class="cm-keyword">this</span>.<span class="cm-property">level</span>.<span class="cm-property">status</span> <span class="cm-operator">==</span> <span class="cm-string">"won"</span>)
    <span class="cm-keyword">this</span>.<span class="cm-property">cx</span>.<span class="cm-property">fillStyle</span> <span class="cm-operator">=</span> <span class="cm-string">"rgb(68, 191, 255)"</span>;
  <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-keyword">this</span>.<span class="cm-property">level</span>.<span class="cm-property">status</span> <span class="cm-operator">==</span> <span class="cm-string">"lost"</span>)
    <span class="cm-keyword">this</span>.<span class="cm-property">cx</span>.<span class="cm-property">fillStyle</span> <span class="cm-operator">=</span> <span class="cm-string">"rgb(44, 136, 214)"</span>;
  <span class="cm-keyword">else</span>
    <span class="cm-keyword">this</span>.<span class="cm-property">cx</span>.<span class="cm-property">fillStyle</span> <span class="cm-operator">=</span> <span class="cm-string">"rgb(52, 166, 251)"</span>;
  <span class="cm-keyword">this</span>.<span class="cm-property">cx</span>.<span class="cm-property">fillRect</span>(<span class="cm-number">0</span>, <span class="cm-number">0</span>,
                   <span class="cm-keyword">this</span>.<span class="cm-property">canvas</span>.<span class="cm-property">width</span>, <span class="cm-keyword">this</span>.<span class="cm-property">canvas</span>.<span class="cm-property">height</span>);
};</pre>
<p><a class="p_ident" id="p_TjOnlogmqf" href="./16_canvas.html#p_TjOnlogmqf"></a>За да начертаем задния план, ще използваме плочите, които са видими в текущия демонстрационен прозорец, използвайки същия подход използван в <code>obstacleAt</code> в <a href="./15_game.html#viewport">предишната глава</a>.</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="game"><a class="c_ident" id="c_IWmtRFoUx5" href="./16_canvas.html#c_IWmtRFoUx5"></a><span class="cm-keyword">var</span> <span class="cm-variable">otherSprites</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">createElement</span>(<span class="cm-string">"img"</span>);
<span class="cm-variable">otherSprites</span>.<span class="cm-property">src</span> <span class="cm-operator">=</span> <span class="cm-string">"img/sprites.png"</span>;

<span class="cm-variable">CanvasDisplay</span>.<span class="cm-property">prototype</span>.<span class="cm-property">drawBackground</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>() {
  <span class="cm-keyword">var</span> <span class="cm-def">view</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">viewport</span>;
  <span class="cm-keyword">var</span> <span class="cm-def">xStart</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">floor</span>(<span class="cm-variable-2">view</span>.<span class="cm-property">left</span>);
  <span class="cm-keyword">var</span> <span class="cm-def">xEnd</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">ceil</span>(<span class="cm-variable-2">view</span>.<span class="cm-property">left</span> <span class="cm-operator">+</span> <span class="cm-variable-2">view</span>.<span class="cm-property">width</span>);
  <span class="cm-keyword">var</span> <span class="cm-def">yStart</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">floor</span>(<span class="cm-variable-2">view</span>.<span class="cm-property">top</span>);
  <span class="cm-keyword">var</span> <span class="cm-def">yEnd</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">ceil</span>(<span class="cm-variable-2">view</span>.<span class="cm-property">top</span> <span class="cm-operator">+</span> <span class="cm-variable-2">view</span>.<span class="cm-property">height</span>);

  <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">y</span> <span class="cm-operator">=</span> <span class="cm-variable-2">yStart</span>; <span class="cm-variable-2">y</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">yEnd</span>; <span class="cm-variable-2">y</span><span class="cm-operator">++</span>) {
    <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">x</span> <span class="cm-operator">=</span> <span class="cm-variable-2">xStart</span>; <span class="cm-variable-2">x</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">xEnd</span>; <span class="cm-variable-2">x</span><span class="cm-operator">++</span>) {
      <span class="cm-keyword">var</span> <span class="cm-def">tile</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">level</span>.<span class="cm-property">grid</span>[<span class="cm-variable-2">y</span>][<span class="cm-variable-2">x</span>];
      <span class="cm-keyword">if</span> (<span class="cm-variable-2">tile</span> <span class="cm-operator">==</span> <span class="cm-atom">null</span>) <span class="cm-keyword">continue</span>;
      <span class="cm-keyword">var</span> <span class="cm-def">screenX</span> <span class="cm-operator">=</span> (<span class="cm-variable-2">x</span> <span class="cm-operator">-</span> <span class="cm-variable-2">view</span>.<span class="cm-property">left</span>) <span class="cm-operator">*</span> <span class="cm-variable">scale</span>;
      <span class="cm-keyword">var</span> <span class="cm-def">screenY</span> <span class="cm-operator">=</span> (<span class="cm-variable-2">y</span> <span class="cm-operator">-</span> <span class="cm-variable-2">view</span>.<span class="cm-property">top</span>) <span class="cm-operator">*</span> <span class="cm-variable">scale</span>;
      <span class="cm-keyword">var</span> <span class="cm-def">tileX</span> <span class="cm-operator">=</span> <span class="cm-variable-2">tile</span> <span class="cm-operator">==</span> <span class="cm-string">"lava"</span> <span class="cm-operator">?</span> <span class="cm-variable">scale</span> : <span class="cm-number">0</span>;
      <span class="cm-keyword">this</span>.<span class="cm-property">cx</span>.<span class="cm-property">drawImage</span>(<span class="cm-variable">otherSprites</span>,
                        <span class="cm-variable-2">tileX</span>,         <span class="cm-number">0</span>, <span class="cm-variable">scale</span>, <span class="cm-variable">scale</span>,
                        <span class="cm-variable-2">screenX</span>, <span class="cm-variable-2">screenY</span>, <span class="cm-variable">scale</span>, <span class="cm-variable">scale</span>);
    }
  }
};</pre>
<p><a class="p_ident" id="p_exCLyNQQL6" href="./16_canvas.html#p_exCLyNQQL6"></a>Плочите, които не са празни (нула) са съставени с <code>drawImage</code>. Изображението <code>otherSprites</code> съдържа снимките, използвани за други елементи на играча. То съдържа от ляво на дясно, плочите на стената, на лавата и спрайт на монетата.</p>
<div class="image">
  <img src="./media/sprites_big.png" alt="Sprites for our game">
</div>
<p><a class="p_ident" id="p_1R4HdSFR8E" href="./16_canvas.html#p_1R4HdSFR8E"></a>Основата на плочите е 20 на 20 пиксела, тъй като ще използваме същия мащаб, както в <code>DOMDisplay</code>. По този начин се компенсира отместването на плочите за лавата с 20 (стойността на <code>scale</code> променливата) и отместването на стените с 0.</p>
<p><a class="p_ident" id="p_KIwkr/Frrz" href="./16_canvas.html#p_KIwkr/Frrz"></a>Ние не се притесняваме за изчакването на зареждането на спрайта. Извикването на <code>drawImage</code> с образ, който все още не е зареден, просто няма да прави нищо. По този начин, може да не успее да направи играта правилно първите няколко кадъра, докато изображението все още се зарежда, но това не е сериозен проблем. Тъй като ние продължаваме да актуализираме екрана и правилната сцена ще се появи веднага, след като зареждането приключи.</p>
<p><a class="p_ident" id="p_/1DXjZpAsq" href="./16_canvas.html#p_/1DXjZpAsq"></a>Символът за ходене показан по-рано, ще се използва за представяне на играча. Кода на чертането трябва да избере правилната посока на спрайта и се базира на текущите движения на играча. Първите осем спрайта съдържат анимацията на ходенето. Когато играча се движи по протежение на пода, ние преминаваме през тях на базата на размерите на дисплей - <code>animationTime</code> свойството. Това се измерва в секунди, и ние искаме да се движи в рамките на 12 кадъра в секунда, така че времето се умножава по 12 първо. Когато играчът стои на място, ние не ползваме деветия спрайт. По време на скока, като се позоваваме на факта, че вертикалната скорост не е нула  използваме деветия най-десен спрайт.</p>
<p><a class="p_ident" id="p_wuDMxn8vbx" href="./16_canvas.html#p_wuDMxn8vbx"></a>Тъй като спрайтовете са малко по-широки от обекта на играча - 24 вместо 16 пиксела, за да се позволи известно пространство за ръцете и краката, метода трябва да коригира х-координата и ширината от дадените размери (<code>playerXOverlap</code>).</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="game"><a class="c_ident" id="c_+F2ZqW5kde" href="./16_canvas.html#c_+F2ZqW5kde"></a><span class="cm-keyword">var</span> <span class="cm-variable">playerSprites</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">createElement</span>(<span class="cm-string">"img"</span>);
<span class="cm-variable">playerSprites</span>.<span class="cm-property">src</span> <span class="cm-operator">=</span> <span class="cm-string">"img/player.png"</span>;
<span class="cm-keyword">var</span> <span class="cm-variable">playerXOverlap</span> <span class="cm-operator">=</span> <span class="cm-number">4</span>;

<span class="cm-variable">CanvasDisplay</span>.<span class="cm-property">prototype</span>.<span class="cm-property">drawPlayer</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">x</span>, <span class="cm-def">y</span>, <span class="cm-def">width</span>,
                                              <span class="cm-def">height</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">sprite</span> <span class="cm-operator">=</span> <span class="cm-number">8</span>, <span class="cm-def">player</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">level</span>.<span class="cm-property">player</span>;
  <span class="cm-variable-2">width</span> <span class="cm-operator">+=</span> <span class="cm-variable">playerXOverlap</span> <span class="cm-operator">*</span> <span class="cm-number">2</span>;
  <span class="cm-variable-2">x</span> <span class="cm-operator">-=</span> <span class="cm-variable">playerXOverlap</span>;
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">player</span>.<span class="cm-property">speed</span>.<span class="cm-property">x</span> <span class="cm-operator">!=</span> <span class="cm-number">0</span>)
    <span class="cm-keyword">this</span>.<span class="cm-property">flipPlayer</span> <span class="cm-operator">=</span> <span class="cm-variable-2">player</span>.<span class="cm-property">speed</span>.<span class="cm-property">x</span> <span class="cm-operator">&lt;</span> <span class="cm-number">0</span>;

  <span class="cm-keyword">if</span> (<span class="cm-variable-2">player</span>.<span class="cm-property">speed</span>.<span class="cm-property">y</span> <span class="cm-operator">!=</span> <span class="cm-number">0</span>)
    <span class="cm-variable-2">sprite</span> <span class="cm-operator">=</span> <span class="cm-number">9</span>;
  <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">player</span>.<span class="cm-property">speed</span>.<span class="cm-property">x</span> <span class="cm-operator">!=</span> <span class="cm-number">0</span>)
    <span class="cm-variable-2">sprite</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">floor</span>(<span class="cm-keyword">this</span>.<span class="cm-property">animationTime</span> <span class="cm-operator">*</span> <span class="cm-number">12</span>) <span class="cm-operator">%</span> <span class="cm-number">8</span>;

  <span class="cm-keyword">this</span>.<span class="cm-property">cx</span>.<span class="cm-property">save</span>();
  <span class="cm-keyword">if</span> (<span class="cm-keyword">this</span>.<span class="cm-property">flipPlayer</span>)
    <span class="cm-variable">flipHorizontally</span>(<span class="cm-keyword">this</span>.<span class="cm-property">cx</span>, <span class="cm-variable-2">x</span> <span class="cm-operator">+</span> <span class="cm-variable-2">width</span> <span class="cm-operator">/</span> <span class="cm-number">2</span>);

  <span class="cm-keyword">this</span>.<span class="cm-property">cx</span>.<span class="cm-property">drawImage</span>(<span class="cm-variable">playerSprites</span>,
                    <span class="cm-variable-2">sprite</span> <span class="cm-operator">*</span> <span class="cm-variable-2">width</span>, <span class="cm-number">0</span>, <span class="cm-variable-2">width</span>, <span class="cm-variable-2">height</span>,
                    <span class="cm-variable-2">x</span>,              <span class="cm-variable-2">y</span>, <span class="cm-variable-2">width</span>, <span class="cm-variable-2">height</span>);

  <span class="cm-keyword">this</span>.<span class="cm-property">cx</span>.<span class="cm-property">restore</span>();
};</pre>
<p><a class="p_ident" id="p_gswQ2kj9pD" href="./16_canvas.html#p_gswQ2kj9pD"></a>Метода <code>drawPlayer</code> се извиква с <code>drawActors</code>, който изготвя всички участници в играта.</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="game"><a class="c_ident" id="c_aB4vicy3VE" href="./16_canvas.html#c_aB4vicy3VE"></a><span class="cm-variable">CanvasDisplay</span>.<span class="cm-property">prototype</span>.<span class="cm-property">drawActors</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>() {
  <span class="cm-keyword">this</span>.<span class="cm-property">level</span>.<span class="cm-property">actors</span>.<span class="cm-property">forEach</span>(<span class="cm-keyword">function</span>(<span class="cm-def">actor</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">width</span> <span class="cm-operator">=</span> <span class="cm-variable-2">actor</span>.<span class="cm-property">size</span>.<span class="cm-property">x</span> <span class="cm-operator">*</span> <span class="cm-variable">scale</span>;
    <span class="cm-keyword">var</span> <span class="cm-def">height</span> <span class="cm-operator">=</span> <span class="cm-variable-2">actor</span>.<span class="cm-property">size</span>.<span class="cm-property">y</span> <span class="cm-operator">*</span> <span class="cm-variable">scale</span>;
    <span class="cm-keyword">var</span> <span class="cm-def">x</span> <span class="cm-operator">=</span> (<span class="cm-variable-2">actor</span>.<span class="cm-property">pos</span>.<span class="cm-property">x</span> <span class="cm-operator">-</span> <span class="cm-keyword">this</span>.<span class="cm-property">viewport</span>.<span class="cm-property">left</span>) <span class="cm-operator">*</span> <span class="cm-variable">scale</span>;
    <span class="cm-keyword">var</span> <span class="cm-def">y</span> <span class="cm-operator">=</span> (<span class="cm-variable-2">actor</span>.<span class="cm-property">pos</span>.<span class="cm-property">y</span> <span class="cm-operator">-</span> <span class="cm-keyword">this</span>.<span class="cm-property">viewport</span>.<span class="cm-property">top</span>) <span class="cm-operator">*</span> <span class="cm-variable">scale</span>;
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">actor</span>.<span class="cm-property">type</span> <span class="cm-operator">==</span> <span class="cm-string">"player"</span>) {
      <span class="cm-keyword">this</span>.<span class="cm-property">drawPlayer</span>(<span class="cm-variable-2">x</span>, <span class="cm-variable-2">y</span>, <span class="cm-variable-2">width</span>, <span class="cm-variable-2">height</span>);
    } <span class="cm-keyword">else</span> {
      <span class="cm-keyword">var</span> <span class="cm-def">tileX</span> <span class="cm-operator">=</span> (<span class="cm-variable-2">actor</span>.<span class="cm-property">type</span> <span class="cm-operator">==</span> <span class="cm-string">"coin"</span> <span class="cm-operator">?</span> <span class="cm-number">2</span> : <span class="cm-number">1</span>) <span class="cm-operator">*</span> <span class="cm-variable">scale</span>;
      <span class="cm-keyword">this</span>.<span class="cm-property">cx</span>.<span class="cm-property">drawImage</span>(<span class="cm-variable">otherSprites</span>,
                        <span class="cm-variable-2">tileX</span>, <span class="cm-number">0</span>, <span class="cm-variable-2">width</span>, <span class="cm-variable-2">height</span>,
                        <span class="cm-variable-2">x</span>,     <span class="cm-variable-2">y</span>, <span class="cm-variable-2">width</span>, <span class="cm-variable-2">height</span>);
    }
  }, <span class="cm-keyword">this</span>);
};</pre>
<p><a class="p_ident" id="p_PD+LPXwCgk" href="./16_canvas.html#p_PD+LPXwCgk"></a>При изготвянето на нещо, което не е играч, ние гледаме неговият вид, за да открием офсета на правилния спрайт. Плочите за лава се намират с офсет 20, а спрайта на монетата се намира с офсет 40 (два пъти скалата).</p>
<p><a class="p_ident" id="p_e6Z9O4bib+" href="./16_canvas.html#p_e6Z9O4bib+"></a>Ние трябва да извадим позицията на изгледа, когато изчисляваме положението на актьора, тъй като точка (0, 0) на нашето платно съответства на горния ляв ъгъл на изгледа, а не на горния ляв ъгъл на нивото. Можем също да използваме транслация за това. Така или иначе работи.</p>
<p><a class="p_ident" id="p_4VReSkKraV" href="./16_canvas.html#p_4VReSkKraV"></a>Показания следващ малък документ, свързва новия дисплей в <code>runGame</code>:</p>
<pre data-language="text/html" class="snippet cm-s-default" data-sandbox="game" data-focus="true"><a class="c_ident" id="c_VOS8HEBUxB" href="./16_canvas.html#c_VOS8HEBUxB"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">body</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
    <span class="cm-variable">runGame</span>(<span class="cm-variable">GAME_LEVELS</span>, <span class="cm-variable">CanvasDisplay</span>);
  <span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">body</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<h2 id="graphics_tradeoffs"><a class="h_ident" id="h_T6CfghQSfx" href="./16_canvas.html#h_T6CfghQSfx"></a>Избор  на  графични  интерфейси</h2>
<p><a class="p_ident" id="p_hiYOCc2tar" href="./16_canvas.html#p_hiYOCc2tar"></a>Винаги, когато имате нужда от генериране на графики в браузъра, можете да избирате между обикновен HTML, SVG и canvas (платно). Няма най-добър вариант, който да работи във всички ситуации. Всеки вариант има силни и слаби страни.</p>
<p><a class="p_ident" id="p_O7BQaYbnwn" href="./16_canvas.html#p_O7BQaYbnwn"></a>Обикновен HTML има предимството, че е прост. Той също така се интегрира добре с текст. И двата- SVG и canvas ви позволяват да изготвите текст, но те няма да ви помогнат да позиционирате този текст или го увиете, когато заеме повече от един ред. В HTML базиран на картина е лесно да се включат блокове текст.</p>
<p><a class="p_ident" id="p_6uH6l730WJ" href="./16_canvas.html#p_6uH6l730WJ"></a>SVG може да се използва за производство на чисти графики, които изглеждат добре на всяко ниво на увеличение. Той е по труден за  използване  от обикновен HTML, но е много по-мощен.</p>
<p><a class="p_ident" id="p_J5B7lFXtzE" href="./16_canvas.html#p_J5B7lFXtzE"></a>И двата - SVG  и  HTML изграждат структура от данни (DOM), които представляват картината. Това прави възможно да се променя, след като елементите са изготвени. Ако трябва да се промени на няколко пъти малка част от голямата  картина в отговор на това, което потребителя прави или част от анимацията, правенето на това в платното може да бъде ненужно скъпо. DOM също ни позволява да регистрираме манипулатори за събития на мишката за всеки елемент от картината (дори форми, изготвени с SVG). Но не може да направите това с <em>canvas</em>.</p>
<p><a class="p_ident" id="p_7N4OSlG5eS" href="./16_canvas.html#p_7N4OSlG5eS"></a>Но пиксело-ориентирания подход на <em>canvas</em> може да бъде предимство при изготвянето на огромно количество дребни елементи. Фактът, че не се изгражда структура от данни, а само многократно обръща върху същата повърхност пикселите, платното ни дава по-ниска цена на формата.</p>
<p><a class="p_ident" id="p_6P4A05RVAk" href="./16_canvas.html#p_6P4A05RVAk"></a>Има ефекти, като например рендерирането на един пиксел в даден момент (например използвайки <em>ray tracer</em>) или <em>postprocessing</em> изображение с JavaScript (замъгляване или изкривяване), което може да бъде обработено реалистично само с пиксел базирана техника.</p>
<p><a class="p_ident" id="p_lecWO5A8ae" href="./16_canvas.html#p_lecWO5A8ae"></a>В някои случаи може да искаме да комбинираме няколко от тези техники. Например, може да направим графика с SVG или платно, но да покажем текстова информация чрез позициониране на HTML елемента в горната част на картинката.</p>
<p><a class="p_ident" id="p_nXWEbGkTBm" href="./16_canvas.html#p_nXWEbGkTBm"></a>За не взискателни  приложения, наистина няма толкова значение, кой интерфейс ще изберем. <a href="./16_canvas.html#canvasdisplay">Вторият дисплей</a> който построихме за нашата игра в тази глава, може да бъде приложен с помощта на някоя от тези три графични технологии, тъй като не е необходимо да се направи текст, да се взаимодейства с мишката или да работи с изключително голямо количество елементи.</p>
<h2><a class="h_ident" id="h_ErccPg/l98" href="./16_canvas.html#h_ErccPg/l98"></a>Резюме</h2>
<p><a class="p_ident" id="p_tJH36yWkVt" href="./16_canvas.html#p_tJH36yWkVt"></a>В тази глава обсъдихме техники за рисуване на графики в браузъра, като се фокусирахме на <code>&lt;canvas&gt;</code> елементите.</p>
<p><a class="p_ident" id="p_zTR1kU1R2F" href="./16_canvas.html#p_zTR1kU1R2F"></a>Разклонението на платното представлява област в документ, който нашата програма може да разчита. Този чертеж се осъществява чрез контекста на графичен обект създаден с <code>getContext</code> метода.</p>
<p><a class="p_ident" id="p_77n8vdtsoS" href="./16_canvas.html#p_77n8vdtsoS"></a>Интерфейса на 2D чертането ни позволява да запълним или очертаем различни форми. Контекста на свойството <code>fillStyle</code> определя, как да запълним тези форми. Свойствата <code>strokeStyle</code> и <code>lineWidth</code> контролират начина на чертане на линиите.</p>
<p><a class="p_ident" id="p_p9lwBrZeDB" href="./16_canvas.html#p_p9lwBrZeDB"></a>Правоъгълници и части от текст могат да се направят с едно извикване на метод. Методите <code>fillRect</code> and <code>strokeRect</code> чертаят правоъгълници, а методите <code>fillText</code> и <code>strokeText</code> изготвят текста. За да изградим определени форми първо трябва да изградим път (<em>path</em>).</p>
<p><a class="p_ident" id="p_+WESqzV0sH" href="./16_canvas.html#p_+WESqzV0sH"></a>С извикването на <code>beginPath</code> започва новия път. Редица други методи добавят линии и криви на текущия път. Например <code>lineTo</code> за добавяне на права линия. Когато един път е завършен, той може да бъде запълнен със <code>fill</code> метод или очертан със <code>stroke</code> метода.</p>
<p><a class="p_ident" id="p_DjIq4BWBzl" href="./16_canvas.html#p_DjIq4BWBzl"></a>Преместването на пиксели от изображението или друго платно върху нашето платно се извършва с <code>drawImage</code> метода. По подразбиране, този метод се основава на цялото изображение - източник, но като му дадем повече параметри, можем да копираме определена област от изображението. Ние използвахме това в нашата игра, като копирахме няколко индивидуални пози от изображението в играта, изображението съдържа много такива пози.</p>
<p><a class="p_ident" id="p_EWHXtIfgMN" href="./16_canvas.html#p_EWHXtIfgMN"></a>Трансформациите ни позволяват да направим форма в няколко посоки. Контекста на 2D чертежа има текуща трансформация, която може да бъде променена с методите <code>translate</code>, <code>scale</code> и <code>rotate</code>. Това ще се отрази на всички следващи операции на чертането. Състоянието на трансформацията може да бъде съхранено със <code>save</code> метода и възстановено със <code>restore</code> метода.</p>
<p><a class="p_ident" id="p_CiZHyGysLU" href="./16_canvas.html#p_CiZHyGysLU"></a>При изготвянето на анимация върху платното, метода <code>clearRect</code> може да се използва за да се изчисти част от платното, преди да се  преначертае.</p>
<h2><a class="h_ident" id="h_TcUD2vzyMe" href="./16_canvas.html#h_TcUD2vzyMe"></a>Упражнения</h2>
<h3><a class="h_ident" id="h_sZheOHQF5N" href="./16_canvas.html#h_sZheOHQF5N"></a>Фигури</h3>
<p><a class="p_ident" id="p_ML2Sk/PrfT" href="./16_canvas.html#p_ML2Sk/PrfT"></a>Напишете програма , която чертае следните форми на платното.</p>
<div class="olist arabic"><ol class="arabic">
<li>
<p><a class="p_ident" id="p_jg9BlkxnI6" href="./16_canvas.html#p_jg9BlkxnI6"></a>
Трапец (правоъгълник, който е по-широк от едната страна) 
</p>
</li>
<li>
<p><a class="p_ident" id="p_TsmIPWkWaZ" href="./16_canvas.html#p_TsmIPWkWaZ"></a>
Червен диамант(правоъгълник  завъртян на 45 градуса или ¼π радиана)
</p>
</li>
<li>
<p><a class="p_ident" id="p_rB8lM2f3nJ" href="./16_canvas.html#p_rB8lM2f3nJ"></a>
Линия зиг-заг
</p>
</li>
<li>
<p><a class="p_ident" id="p_giU72/tC1m" href="./16_canvas.html#p_giU72/tC1m"></a>
Спирала, съставена от 100 праволинейни сегмента.
</p>
</li>
<li>
<p><a class="p_ident" id="p_BaFPNufkG9" href="./16_canvas.html#p_BaFPNufkG9"></a>
Жълта звезда
</p>
</li>
</ol></div>
<div class="image">
  <img src="./media/exercise_shapes.png" alt="The shapes to draw">
</div>
<p><a class="p_ident" id="p_rGwDFrV/8d" href="./16_canvas.html#p_rGwDFrV/8d"></a>При изготвянето на последните две, може да прегледате обяснението на <code>Math.cos</code> и <code>Math.sin</code> в <a href="./13_dom.html#sin_cos">Глава 13</a>, където се описва как да получим координатите на кръг с помоща на тези две функции.</p>
<p><a class="p_ident" id="p_8n4Hu9tdGs" href="./16_canvas.html#p_8n4Hu9tdGs"></a>Аз препоръчвам да създадете функция за всяка форма. Като и подаване на позиция и по желание други свойства, като например размери или броя на точките, като параметри. Алтернативата, която е хард-кодови номера върху целия код, има тенденцията да направи кода ненужно труден за четене и промяна.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_QMiBHdgh/Q" href="./16_canvas.html#c_QMiBHdgh/Q"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">canvas</span> <span class="cm-attribute">width</span>=<span class="cm-string">"600"</span> <span class="cm-attribute">height</span>=<span class="cm-string">"200"</span><span class="cm-tag cm-bracket">&gt;&lt;/</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">cx</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"canvas"</span>).<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);

  <span class="cm-comment">// Your code here.</span>
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<div class="solution"><div class="solution-text">
<p><a class="p_ident" id="p_Up+HOpbg2b" href="./16_canvas.html#p_Up+HOpbg2b"></a>Трапеца (1) може лесно да се направи с помощта на пътя. Изберете подходящ център на координатите и добавете всеки от четирите ъгъла около него.</p>
<p><a class="p_ident" id="p_BsQmhM5bK3" href="./16_canvas.html#p_BsQmhM5bK3"></a>Диамантът (2) може да се направи по лесен начин с пътя или интересен начин с <code>rotate</code> трансформация. За да използвате ротация, ще трябва да се приложи  трик, подобен на това, което правихме в <code>flipHorizontally</code> функцията. Защото искаме да се завърти около центъра на правоъгълника, а не около точка (0, 0), за целта първо трябва да се транслират там, след това завъртаме и после превеждаме обратно.</p>
<p><a class="p_ident" id="p_br/BxkXFdB" href="./16_canvas.html#p_br/BxkXFdB"></a>За зиг-заг (3) е непрактично да се пише ново извикване към <code>lineTo</code> за всяка отсечка. Вместо това използвайте цикъл. Може да начертаете всяка итерация, или две отсечки (дясна и лява) или една, като в този случай трябва да използвате четност (<code>% 2</code>) за индекса на цикъла, за да определите дали да отиде наляво или надясно.</p>
<p><a class="p_ident" id="p_NIAmRwoOih" href="./16_canvas.html#p_NIAmRwoOih"></a>За спиралата (4) също ще трябва един цикъл. Ако се направи поредица от точки и всяка точка се движи в кръг около центъра на на спиралата, ще получите кръг. Но ако по време на цикъла променяте градуса на кръга, в който поставяте текущата точка и обикаляте повече от един път, резултатът ще е една спирала.</p>
<p><a class="p_ident" id="p_TOvDefGKYH" href="./16_canvas.html#p_TOvDefGKYH"></a>Изобразената звезда (5) е изградена от <code>quadraticCurveTo</code> линии. Но също така може да се начертае с прави линии. Разделяте кръг на осем части или парче за всяка точка, където искате вашата звезда да има лъч. Чертаете линии между тези точки, като ги правите curve към центъра на звездата. С <code>quadraticCurveTo</code>, можете да използвате центъра, като контролен пункт.</p>
</div></div>
<h3 id="exercise_pie_chart"><a class="h_ident" id="h_bJrtZj5liF" href="./16_canvas.html#h_bJrtZj5liF"></a>Диаграма на пай</h3>
<p><a class="p_ident" id="p_5/ovyOQpmP" href="./16_canvas.html#p_5/ovyOQpmP"></a>По-рано в <a href="./16_canvas.html#pie_chart">тази глава</a>, видяхме един пример, който начерта кръгова диаграма. Променете тази програма, така че името на всяка категория се показва до частта, която тя представлява. Опитайте се да намерите приятен на вид начин автоматично да позиционира този текст, което ще работи и за други набори от данни също така добре. Може да се предположи, че категориите не са по-малки от 5 на 100 (това е да не се наблъскват един куп малки такива едно до друго).</p>
<p><a class="p_ident" id="p_nTwqKbJWIc" href="./16_canvas.html#p_nTwqKbJWIc"></a>Можете отново да използвате <code>Math.sin</code> и <code>Math.cos</code>, както е описано в предишното упражнение.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_HyVapEe7cw" href="./16_canvas.html#c_HyVapEe7cw"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">canvas</span> <span class="cm-attribute">width</span>=<span class="cm-string">"600"</span> <span class="cm-attribute">height</span>=<span class="cm-string">"300"</span><span class="cm-tag cm-bracket">&gt;&lt;/</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">cx</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"canvas"</span>).<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);
  <span class="cm-keyword">var</span> <span class="cm-variable">total</span> <span class="cm-operator">=</span> <span class="cm-variable">results</span>.<span class="cm-property">reduce</span>(<span class="cm-keyword">function</span>(<span class="cm-def">sum</span>, <span class="cm-def">choice</span>) {
    <span class="cm-keyword">return</span> <span class="cm-variable-2">sum</span> <span class="cm-operator">+</span> <span class="cm-variable-2">choice</span>.<span class="cm-property">count</span>;
  }, <span class="cm-number">0</span>);

  <span class="cm-keyword">var</span> <span class="cm-variable">currentAngle</span> <span class="cm-operator">=</span> <span class="cm-operator">-</span><span class="cm-number">0.5</span> <span class="cm-operator">*</span> <span class="cm-variable">Math</span>.<span class="cm-property">PI</span>;
  <span class="cm-keyword">var</span> <span class="cm-variable">centerX</span> <span class="cm-operator">=</span> <span class="cm-number">300</span>, <span class="cm-variable">centerY</span> <span class="cm-operator">=</span> <span class="cm-number">150</span>;
  <span class="cm-comment">// Add code to draw the slice labels in this loop.</span>
  <span class="cm-variable">results</span>.<span class="cm-property">forEach</span>(<span class="cm-keyword">function</span>(<span class="cm-def">result</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">sliceAngle</span> <span class="cm-operator">=</span> (<span class="cm-variable-2">result</span>.<span class="cm-property">count</span> <span class="cm-operator">/</span> <span class="cm-variable">total</span>) <span class="cm-operator">*</span> <span class="cm-number">2</span> <span class="cm-operator">*</span> <span class="cm-variable">Math</span>.<span class="cm-property">PI</span>;
    <span class="cm-variable">cx</span>.<span class="cm-property">beginPath</span>();
    <span class="cm-variable">cx</span>.<span class="cm-property">arc</span>(<span class="cm-variable">centerX</span>, <span class="cm-variable">centerY</span>, <span class="cm-number">100</span>,
           <span class="cm-variable">currentAngle</span>, <span class="cm-variable">currentAngle</span> <span class="cm-operator">+</span> <span class="cm-variable-2">sliceAngle</span>);
    <span class="cm-variable">currentAngle</span> <span class="cm-operator">+=</span> <span class="cm-variable-2">sliceAngle</span>;
    <span class="cm-variable">cx</span>.<span class="cm-property">lineTo</span>(<span class="cm-variable">centerX</span>, <span class="cm-variable">centerY</span>);
    <span class="cm-variable">cx</span>.<span class="cm-property">fillStyle</span> <span class="cm-operator">=</span> <span class="cm-variable-2">result</span>.<span class="cm-property">color</span>;
    <span class="cm-variable">cx</span>.<span class="cm-property">fill</span>();
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<div class="solution"><div class="solution-text">
<p><a class="p_ident" id="p_HdZ8krVlO9" href="./16_canvas.html#p_HdZ8krVlO9"></a>Ще трябва да извикате <code>fillText</code> и да определите контекста на свойствата <code>textAlign</code> и <code>textBaseline</code> по някакъв начин, така че текста да се озовава там, където желаете.</p>
<p><a class="p_ident" id="p_+9lrfaiHeA" href="./16_canvas.html#p_+9lrfaiHeA"></a>Един разумен начин за позициониране на текста е да се постави на линия идваща от центъра на кръга през средата на парчето. Вие не искате да поставите текста директно върху страната на парчето, а по-скоро да го изнесете от нея на даден брой пиксели.</p>
<p><a class="p_ident" id="p_kM123YG/Z7" href="./16_canvas.html#p_kM123YG/Z7"></a>Ъгълът на тази линия е <code>currentAngle + 0.5 * sliceAngle</code>. Следният код устанвовява позицията на тази линия на 120 пиксела от центъра.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_A0rK11DEAl" href="./16_canvas.html#c_A0rK11DEAl"></a><span class="cm-keyword">var</span> <span class="cm-variable">middleAngle</span> <span class="cm-operator">=</span> <span class="cm-variable">currentAngle</span> <span class="cm-operator">+</span> <span class="cm-number">0.5</span> <span class="cm-operator">*</span> <span class="cm-variable">sliceAngle</span>;
<span class="cm-keyword">var</span> <span class="cm-variable">textX</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">cos</span>(<span class="cm-variable">middleAngle</span>) <span class="cm-operator">*</span> <span class="cm-number">120</span> <span class="cm-operator">+</span> <span class="cm-variable">centerX</span>;
<span class="cm-keyword">var</span> <span class="cm-variable">textY</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">sin</span>(<span class="cm-variable">middleAngle</span>) <span class="cm-operator">*</span> <span class="cm-number">120</span> <span class="cm-operator">+</span> <span class="cm-variable">centerY</span>;</pre>
<p><a class="p_ident" id="p_O8MP7v4Gfr" href="./16_canvas.html#p_O8MP7v4Gfr"></a>За стойност на "средата" на <code>textBaseline</code> е подходящо използването на този подход. Какво да използваме за <code>textAlign</code> зависи от външната страна на кръга, където сме. От лявата страна, трябва да бъде <code>"right"</code>, а от дясната <code>"left"</code>, така че текста да е разположен далече от пая.</p>
<p><a class="p_ident" id="p_BmCLUHGaC3" href="./16_canvas.html#p_BmCLUHGaC3"></a>Ако не сте сигурни как да разберете, коя страна на даден ъгъл  от окръжността е, погледнете обяснението на <code>Math.cos</code> в предишното упражнение. Косинуса на ъгъл ни казва, коя х-координата отговаря, което от своя страна ни казва точно на коя страна от кръга сме.</p>
</div></div>
<h3><a class="h_ident" id="h_IoBBN8CiQ5" href="./16_canvas.html#h_IoBBN8CiQ5"></a>Подскачаща топка</h3>
<p><a class="p_ident" id="p_QtPClJ4kuI" href="./16_canvas.html#p_QtPClJ4kuI"></a>Използвайте техниката <code>requestAnimationFrame</code>, която видяхме в 
<a href="./13_dom.html#animationFrame">Глава 13 </a> и
<a href="./15_game.html#runAnimation">Глава 15</a>, за да направите кутия с подскачаща топка в нея. Топката се движи с постоянна скорост и отскача от клетките на стените на решетката, когато ги удари.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_BlVpc3CK9m" href="./16_canvas.html#c_BlVpc3CK9m"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">canvas</span> <span class="cm-attribute">width</span>=<span class="cm-string">"400"</span> <span class="cm-attribute">height</span>=<span class="cm-string">"400"</span><span class="cm-tag cm-bracket">&gt;&lt;/</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">cx</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"canvas"</span>).<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);

  <span class="cm-keyword">var</span> <span class="cm-variable">lastTime</span> <span class="cm-operator">=</span> <span class="cm-atom">null</span>;
  <span class="cm-keyword">function</span> <span class="cm-variable">frame</span>(<span class="cm-def">time</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable">lastTime</span> <span class="cm-operator">!=</span> <span class="cm-atom">null</span>)
      <span class="cm-variable">updateAnimation</span>(<span class="cm-variable">Math</span>.<span class="cm-property">min</span>(<span class="cm-number">100</span>, <span class="cm-variable-2">time</span> <span class="cm-operator">-</span> <span class="cm-variable">lastTime</span>) <span class="cm-operator">/</span> <span class="cm-number">1000</span>);
    <span class="cm-variable">lastTime</span> <span class="cm-operator">=</span> <span class="cm-variable-2">time</span>;
    <span class="cm-variable">requestAnimationFrame</span>(<span class="cm-variable">frame</span>);
  }
  <span class="cm-variable">requestAnimationFrame</span>(<span class="cm-variable">frame</span>);

  <span class="cm-keyword">function</span> <span class="cm-variable">updateAnimation</span>(<span class="cm-def">step</span>) {
    <span class="cm-comment">// Your code here.</span>
  }
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<div class="solution"><div class="solution-text">
<p><a class="p_ident" id="p_v5+QhLhJAT" href="./16_canvas.html#p_v5+QhLhJAT"></a>Кутията лесно може да се направи с <code>strokeRect</code> и дефиниране на променлива, която държи размера, ако е квадрат или две променливи, ако ширината и височината на вашата кутия се различават. За да създадете кръг на топка, започнете с пътя, като извикате <code>arc(x, y, radius, 0, 7)</code>, което създава дъга, като се започне от нула до повече от цял кръг и го запълни.</p>
<p><a class="p_ident" id="p_wlBTN9ml9f" href="./16_canvas.html#p_wlBTN9ml9f"></a>За да моделирате позицията на топката и скоростта, може да използвате <code>Vector</code> типа от <a href="./15_game.html#vector">Глава 15</a>(който е на разположение на тази страница). Дайте му начална скорост, за предпочитане такава, която не чисто вертикална или хоризонтална и за всеки кадър, се умножи тази скорост по изминалия период от време. Когато топката стигне твърде близо до вертикалната стена, обърнете х-компонента на неговата скорост. По същия начин обърнете y-компонента, когато стигне хоризонталната стена.</p>
<p><a class="p_ident" id="p_1wITPL6e42" href="./16_canvas.html#p_1wITPL6e42"></a>За намиране на нова позиция на топката и скоростта, използвайте <code>clearRect</code> за изтриване на сцената и за прехвърляне на новата позиция.</p>
</div></div>
<h3><a class="h_ident" id="h_3ePcd0S4v0" href="./16_canvas.html#h_3ePcd0S4v0"></a>Precomputed   mirroring</h3>
<p><a class="p_ident" id="p_onlMAFaFji" href="./16_canvas.html#p_onlMAFaFji"></a>Едно несполучливо нещо за трансформациите е, че забавят чертежа на растерните изображения. За векторни графики ефекта е по-сериозен, тъй като само няколко точки (например, в центъра на кръг) трябва да се трансформират, след което може да се чертае нормално. За растерно изображение, позицията на всеки пиксел трябва да се трансформира и макар, че браузърите може да станат по-умни в бъдеще, това по настоящем причинява измеримо увеличение на времето, необходимо за изготвяне на растерна графика.</p>
<p><a class="p_ident" id="p_b50ouk4znE" href="./16_canvas.html#p_b50ouk4znE"></a>В игра, като нашата където сме рисували само един трансформиран спрайт, това е без значение. Но представете си, че трябва да се направят стотици герои или хиляди въртящи се частици от експлозия.</p>
<p><a class="p_ident" id="p_WgNsgEoaNe" href="./16_canvas.html#p_WgNsgEoaNe"></a>Помислете за начин, който да ни позволи да рисуваме обърнат символ без зареждане на допълнителни файлове с изображения и без да се налага да правим трансформация с извикването на <code>drawImage</code> за всеки кадър.</p>
<div class="solution"><div class="solution-text">
<p><a class="p_ident" id="p_NmNTuxj7Ml" href="./16_canvas.html#p_NmNTuxj7Ml"></a>Ключът към решението е факта, че можем да използваме елемента на платното, като източник на изображение, като се използва <code>drawImage</code>. Възможно е да се създаде допълнителен елемент <code>&lt;canvas&gt;</code>, без го добавяме към документа и да изготвим нашите обърнати спрайтове в него, на веднъж. При изготвянето на действителната конструкция, ние просто ще копираме вече обърнатите спрайтове на главното платно.</p>
<p><a class="p_ident" id="p_MbtRzmupcp" href="./16_canvas.html#p_MbtRzmupcp"></a>Ще се изискват някакви <em>required</em>, защото изображенията не се зареждат веднага. Ние правим обърнатия чертеж само веднъж и ако го направим преди да се зареди снимката, той няма да прави нищо. Манипулатора  <code>"load"</code> може да се използва върху изображението за изготвяне на обърнати изображения към допълнителното платно. Това платно може да се използва, като източник на чертеж веднага (то просто ще бъде празно, докато не се начертае символ върху него).</p>
</div></div>
<nav>
  <a href="./15_game.html" title="previous chapter">◀</a>
  <a href="./index.html" title="cover">◆</a>
  <a href="./17_http.html" title="next chapter">▶</a>
</nav>
</article>
</body></html>
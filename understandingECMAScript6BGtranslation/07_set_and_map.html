<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Sets and Maps :: Understanding ECMAScript 6</title>
	<link rel="stylesheet" href="font.css">
</head>
<body>
	<nav>
	<a href="./06_simbols.html" title="previous chapter">◀</a>
  <a href="./index.html" title="cover">◆</a>
  <a href="08_iterators_and_generators.html" title="next chapter">▶</a>
</nav>
	<header id="header" class="">
		<h1><div class="head-num">Глава 7</div>Sets и Maps</h1>
		<p>За повечето от историята на JavaScript е имало само един вид колекции, представени от <em>Array</em> типа. Масивите се използват в  JavaScript точно като масивите на другите езици, но и като <em>queues</em> и <em>stacks</em>. Тъй като, масивите използват само цифрови индекси, програмистите използват не-масиви обекти, когато са необходими не-цифрови индекси. Това доведе до потребителски реализации на <em>sets</em> и <em>maps</em>.</p>
		<p><em>Set</em> е даден списък от стойности, които не могат да сдържат дубликати. Обикновено няма достъп до отделните елементи в <em>set</em>, както се прави в масив. Вместо това, много по-често се проверява, за да се види дали една стойност е на лице. <em>Map</em> е колекция от ключове, които се преобразуват в конкретни стойности. Като така, всеки елемент от <em>map</em> се съхранява с две парчета от данни и стойностите се извличат чрез определяне на ключ, който да чете от тях. <em>Maps</em> често се използват, като кеш - съхраняване на данни, кото бързо да се изтеглят по-късно.</p>
		<p>Докато ECMAScript 5 формално няма <em>sets</em> и <em>maps</em>, програмистите са успели да заобиколят това ограничение използвайки не-масиви обекти.</p>
	</header><!-- /header -->
	<article>
		<h3>Sets и Maps в ECMAScript 5</h3>
		<p>В ECMAScript 5 и по-рано, разработчиците имитират <em>sets</em> и <em>maps</em> чрез използване на свойства на обекти, като:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">let</span> set = <span class="code">Object</span>.create(<span class="code">null</span>);

set.foo = <span class="code">true</span>;

<span class="comment">// проверка за съществуване</span>
<span class="code">if</span> (set.foo) {

    <span class="comment">// направи нещо</span>
}	
			</pre></dd>
		</dl>
		<p>Променливата <em>set</em> в този пример е обект с прототип <em>null</em>, което гарантира, че няма наследени свойства на обекта. Това е често срещан подход в ECMAScript 5, който използва обектни свойства, като уникални стойности, които трябва да бъдат проверени. Свойствата се добавят и определят на <em>true</em> така, че лесно да могат да се използват в условни конструкции (например, <em>if</em> изявлението в този пример) за да видим дали стойността е налице. Единствената разлика между обект използван, като <em>set</em> и обект използван, като <em>map</em> е начина на съхранение на стойността. Например:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">let</span> map = <span class="code">Object</span>.create(<span class="code">null</span>);

map.foo = "bar";

<span class="comment">// извличане на стойност</span>
<span class="code">let</span> value = map.foo;

console.log(value);         // "bar"
			</pre></dd>
		</dl>
		<p>Този пример използва един обект, като <em>map</em> за съхраняване на <em>string</em> стойност "bar" под ключ "foo". За разлика от <em>sets</em>, <em>maps</em> се използват предимно за извличане на информация (а не само за проверка за съществуване на ключа).</p>
		<h3>Проблеми</h3>
		<p>Докато подхода за използване на обекти, като <em>sets</em> и <em>maps</em> работи добре в прости ситуации, той може да стане по-сложен, когато се сблъска с ограниченията за свойства на обекта. Тъй като, всички обектни свойства трябва да са <em>strings</em>, ние трябва да сме сигурни, че няма два ключа, които да оценяват същия <em>string</em>. Помислете за следното:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">let</span> map = <span class="code">Object</span>.create(<span class="code">null</span>);

map[5] = "foo";

console.log(map["5"]);      // "foo"
			</pre></dd>
		</dl>
		<p>Този пример задава цифрово свойство 5 към стойност "foo". Вътрешно, цифровата стойност се превръща в <em>string</em>, така <em>map["5"]</em> и <em>map[5]</em> всъщност са референция към едно и също свойство. Това може да причини проблеми, когато ключовете могат да бъдат числа и <em>strings</em>. Друг проблем е, когато се използват обекти, като ключове:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">let</span> map = <span class="code">Object</span>.create(<span class="code">null</span>),
    key1 = {},
    key2 = {};

map[key1] = "foo";

console.log(map[key2]);     // "foo"
			</pre></dd>
		</dl>
		<p>Тука, <em>map[key2]</em> се позовава на същата стойност, като <em>map[key1]</em>. Всеки обект, <em>key1</em> и </em>key2</em> се преобразуват в <em>strings</em>, защото обектните свойства трябва да са <em>strings</em>. По подразбиране <em>string</em> представянето за обекти е "[object Object]", така че <em>key1</em> и <em>key2</em> се конвертират в <em>string</em>.</p>
		<p>Друг проблем се отнася конкретно до maps с ключ, чиято стойност е <em>falsy</em>. Стойността <em>falsy</em> автоматично се превръща във <em>false</em> когато се използва в ситуации, при които се изисква булева стойност, като условие за <em>if</em> изявление. Това само по себе си не е проблем, стига да сте внимателни за това как да използвате стойности. Например:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">let</span> map = <span class="code">Object</span>.create(<span class="code">null</span>);

map.count = 1;

<span class="comment">// проверка за наличие на "count" или не нулева стойност</span>
<span class="code">if</span> (map.count) {
    // ...
}
			</pre></dd>
		</dl>
		<p>Този код има известна неяснота по отношение на използването на <em>map.count</em>, това е <em>if</em> изявлението предназначено да провери за наличието на <em>map.count</em> или дали стойността е не нулева. Кода вътре в <em>if</em> изявлението ще се изпълни защото стойността 1 е истина. Обаче, ако <em>map.count</em> е 0 или <em>map.count</em> не съществува, кодът вътре в <em>if</em> изявлението няма да бъде изпълнен.</p>
		<p>Това е труден проблем за идентифициране и отстраняване на грешки, когато това се случи в големи приложения и основна причина, поради която ECMAScript 6 добавя <em>sets</em> и <em>maps</em> в езика.</p>
		<h3>Sets в ECMAScript 6</h3>
		<p>ECMAScript 6 добавя <em>Set</em> тип, който е подреден списък от стойности без дубликати. <em>Sets</em> позволява бърз достъп до данните, съдържащи се в рамката му, добавяйки по-ефективен начин за проследяване на дискретни стойности. <em>Set</em> се създава с помощта на <em>new Set()</em> и елементи се добавят към <em>set</em> използвайки <em>add()</em> метод. Можем да видим, колко елемента са в <em>set</em> използвайки <em>size</em> свойство.</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">let</span> set = <span class="code">new</span> Set();
set.add(5);
set.add("5");

console.log(set.size);    // 2
			</pre></dd>
		</dl>
		<p><em>Sets</em> не коригира стойностите за определяне на типа, те са едни и същи. Така че, един <em>set</em> може да съдържа, както номер 5 така и <em>string</em> "5" (вътрешно сравнението се прави с помощта на <em>Object.is()</em>, който бе обсъден в <a href="./04_object_function.html #object-is ">Глава 4</a>). Това означава, че може да добавите множество обекти, към <em>set</em> и те ще останат различни:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">let</span> set = <span class="code">new</span> Set(),
    key1 = {},
    key2 = {};

set.add(key1);
set.add(key2);

console.log(set.size);    // 2
			</pre></dd>
		</dl>
		<p>Защото, <em>key1</em> и <em>key2</em> не се преобразуват в <em>strings</em> и те се броят за два уникални елемента в <em>set</em>.</p>
		<p>Ако <em>add()</em> метода се извика повече от веднъж с една и съща стойност, всички извиквания след първото са ефективно игнорирани:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">let</span> set = <span class="code">new</span> Set();
set.add(5);
set.add("5");
set.add(5);     <span class="comment">// дублирането се игнорира</span>

console.log(set.size);    // 2
			</pre></dd>
		</dl>
		<p>Можем да инициализираме <em>set</em> използвайки масив и <em>Set</em> конструктора ще гарантира, че се използват само уникални стойности:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">let</span> set = <span class="code">new</span> Set([1, 2, 3, 4, 5, 5, 5, 5]);
console.log(set.size);    // 5
			</pre></dd>
		</dl>
		<p>В този пример, масив с комплект числа се използва за инициализиране на <em>set</em>. Броя 5 се появява само веднъж в <em>set</em> въпреки, че изглежда четири пъти в масива. Тази функционалност го прави лесен за конвертиране на съществуващ код или JSON структурите да използват <em>sets</em>.</p>
		<dl>
			<dd><div class="info">
         <img src="./img/info.jpg" alt="info">
       </div><strong><em>Set</em> конструктора всъщност приема всеки <em>iterable</em> обект, като аргумент. Масивите работят, защото те са <em>iterable</em> по подразбиране, също като <em>sets</em> и <em>maps</em>. <em>Set</em> конструктора използва итератор за извличане на стойности от аргумента. <a href="08_iterators_and_generators.html #iterable"><em>Iterables</em></a> и <a href="08_iterators_and_generators.html #iterators">итераторите</a> са разгледани в <a href="08_iterators_and_generators.html">Глава 8</a>.</strong></dd>
		</dl>
		<p>Можете да тествате за да видите, кои стойности са в <em>set</em> използвайки <em>has()</em> метод:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">let</span> set = <span class="code">new</span> Set();
set.add(5);
set.add("5");

console.log(set.has(5));    // true
console.log(set.has(6));    // false
			</pre></dd>
		</dl>
		<p>Възможно е да се премахне стойност от <em>set</em> с помощта на <em>delete()</em> метода или да се премахнат всички стойности от <em>set</em> с помощта на <em>clear()</em> метода:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">let</span> set = <span class="code">new</span> Set();
set.add(5);
set.add("5");

console.log(set.has(5));    // true

set.<span class="code">delete</span>(5);

console.log(set.has(5));    // false
console.log(set.size);      // 1

set.clear();

console.log(set.has("5"));  // false
console.log(set.size);      // 0
			</pre></dd>
		</dl>
		<p>Всичко това е само един много лесен механизъм за проследяване на уникални подредени стойности. Обаче, ако искате да добавите елемент в <em>set</em> и след това да изпълните някоя операция върху всеки елемент, е момента в който метода <em>forEach()</em> идва на помощ.</p>
		<h3>Метода  forEach()</h3>
		<p>Ако използвате масиви за работа тогава вече може да сте запознати с <em>forEach()</em> метода. ECMAScript 5 добавя <em>forEach()</em> за масиви, за да се създаде по-лесен начин за работа върху всеки елемент в масив, без създаване на <em>for</em> цикъл. Метода се оказа популярен сред програмистите и така един и същи метод е наличен и за <em>sets</em> и работи по същия начин.</p>
		<p>Метода <em>forEach()</em> е подаден на функция за обратно извикване и приема три аргумента.</p>
		<dl>
			<dd>
			 <ol>
				<li>Стойността от следващата позиция в <em>set</em>.</li>
				<li>Същата стойност, като първия аргумент.</li>
				<li><em>Set</em> от който чете стойността.</li>
			 </ol>
			</dd>
		</dl>
		<p>Странна разлика между <em>set</em> версията на <em>forEach()</em> и версията за масив, е че първия и втория аргумент на функцията за обратно извикване са едни и същи. Въпреки, че това изглежда, като грешка има добра причина за това поведение.</p>
		<p>Другите обекти, които имат <em>forEach()</em> методи, масиви и <em>maps</em> подават три аргумента към техните функции за обратно извикване. Първите два аргумента за масиви и <em>maps</em> са стойност и ключ (цифровия индекс за масиви). <em>Sets</em> нямат ключове, така че бихме могли да направим функцията за обратно извикване да приема два аргумента (които ще я направят различна от другите) или да се намери начин да се запази функцията за обратно извикване да приема три аргумента. Взетото решение е за последното и така <em>sets</em> разглежда всяка стойност едновременно, като ключ и стойност. Като такива, първият и вторият аргумент са винаги едни и същи в <em>forEach()</em> за <em>sets</em>, за да се запази същата функционалност в съответствие с другите <em>forEach()</em> методи за масиви и <em>maps</em>.</p>
		<p>Освен разликата с аргументите, използването на <em>forEach()</em> е основно същото, както за <em>set</em> така и за масиви.</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">let</span> set = <span class="code">new</span> Set([1, 2]);

set.forEach(<span class="code">function</span>(value, key, ownerSet) {
    console.log(key + " " + value);
    console.log(ownerSet === set);
});
			</pre></dd>
		</dl>
		<p>Това е изхода:</p>
		<dl>
			<dd>
				<pre class="highlight">
				<br>1 1 <br>true <br>2 2 <br>true</p>
			    </pre>
			</dd>
		</dl>
	    <p>Също, като при масиви, можете да подадете <em>this</em> стойност, като втори аргумент на <em>forEach()</em>, ако имате нужда да използвате <em>this</em> в вашата функция за обратно извикване:</p>
	    <dl>
	    	<dd><pre class="highlight">
<span class="code">let</span> set = <span class="code">new</span> Set([1, 2]),
    processor = {
        output(value) {
            console.log(value);
        },
        process(dataSet) {
            dataSet.forEach(<span class="code">function</span>(value) {
                <span class="code">this</span>.output(value);
            }, <span class="code">this</span>);
        }
    };

processor.process(set);
	    	</pre></dd>
	    </dl>
	    <p>В този пример, метода <em>processor.process()</em> извиква <em>forEach()</em> върху <em>set</em> и подава <em>this</em>, като стойност за обратно извикване. Това е необходимо, така че <em>this.output()</em> правилно ще реши по отношение на <em>processor.output()</em>. Може да използвате функция стрела, за да получите същия ефект, без да подавате втори аргумент:</p>
	    <dl>
	    	<dd><pre class="highlight">
<span class="code">let</span> set = <span class="code">new</span> Set([1, 2]),
    processor = {
        output(value) {
            console.log(value);
        },
        process(dataSet) {
            dataSet.forEach((value) => <span class="code">this</span>.output(value));
        }
    };

processor.process(set);
	    	</pre></dd>
	    </dl>
	    <p>Функицята стрела в този пример, чете <em>this</em> от съдържащата функция и така правилно решава <em>this.output()</em> по отношение на <em>processor.output()</em>.</p>
	    <p>Имайте в предвид, че <em>sets</em> са чудесни стойности за проследяване и <em>forEach()</em> ви позволява да работите върху всяка стойност последователно, но не можете да получите случаен достъп до стойност съдържаща се в <em>set</em>, тъй както можете в масив. Ако трябва да направите това, тогава най-добрия вариант е да превърнете <em>set</em> в масив.</p>
	    <h3 id="spreads">Конвертиране в масив</h3>
	    <p>Конвертирането на масив в <em>set</em> е лесно, защото можем да подадем масива на <em>Set</em> конструктора. Също така е лесно да конвертираме <em>set</em> обратно в масив, използвайки оператора <em>spread</em>.  Оператора <em>spread (...)</em> беше обсъден в <a href="./03_function.html #spread">Глава 3</a>, като начин да се разделят елементите в масив на отделни функционални параметри. Можем също да използваме оператора <em>spread</em> върху <em>iterable</em> обекти, също като <em>sets</em>, който да ги конвертира в масив. Например:</p>
	    <dl>
	    	<dd><pre class="highlight">
<span class="code">let</span> set = new Set([1, 2, 3, 3, 3, 4, 5]),
    array = [...set];

console.log(array);             // [1,2,3,4,5]
	    	</pre></dd>
	    </dl>
	    <p>Тука, <em>set</em> е зареден първоначално с масив, който съдържа дубликати. <em>Set</em> премахва дубликатите и след това елементите се поставят в нов масив, използвайки оператора <em>spread</em>. Самия <em>set</em> все още съдържа същите елементи, те просто са копирани в нов масив. Този подход е полезен, когато вече имаме масив и искаме да създадем масив без дубликати. Например:</p>
	    <dl>
	    	<dd><pre class="highlight">
<span class="code">function</span> eliminateDuplicates(items) {
    <span class="code">return</span> [...<span class="code">new</span> Set(items)];
}

<span class="code">let</span> numbers = [1, 2, 3, 3, 3, 4, 5],
    noDuplicates = eliminateDuplicates(numbers);

console.log(noDuplicates);      // [1,2,3,4,5]
	    	</pre></dd>
	    </dl>
	    <p>Във функцията <em>eliminateDuplicates()</em>, <em>set</em> е само временен посредник, използван за филтриране на дублирани стойности преди създаването на нов масив, който няма дубликати.</p>
	    <h3>Weak  Sets</h3>
	    <p><em>Set</em> алтернативно може да се нарече силен комплект, заради начина по който съхранява референции на обекти. Един обект съхраняван в <em>Set</em> е ефективно същото, като съхраняването на този обект в променлива, което означава, че докато съществува тази препратка, променливата не може да бъде почистена от <em>garbage</em> (боклука) за да освободите памет. Например:</p>
	    <dl>
	    	<dd><pre class="highlight">
<span class="code">let</span> set = new Set(),
    key = {};

set.add(key);
console.log(set.size);      // 1

<span class="comment">// премахване на оригиналната референция</span>
key = <span class="code">null</span>;

console.log(set.size);      // 1

<span class="comment">// вземане на оригиналната референция обратно</span>
key = [...set][0];
	    	</pre></dd>
	    </dl>
	    <p>В този пример, настройване на ключа към <em>null</em>, изчиства една препратка на обекта, но друга остава вътре в <em>set</em>. Така че, можем да извлечем тази стойност чрез конвертиране на <em>set</em> в масив, използвайки оператора <em>spread</em> и да получим достъп до първия елемент. Това работи добре за повечето приложения, но понякога е по-добре за референциите в <em>set</em> да изчезнат, когато и всички други референции изчезнат. Например, ако вашия JavaScript се изпълнява на уеб-страница и искате да следите DOM елементите (които, могат да бъдат премахнати от друг скрипт) вие не искате вашия код да държи последната референция към DOM елемент - това се нарича загуба на памет.</p>
	    <p><em>Weak set</em> е вид набор, който съхранява само <em>weak</em> референции на обекти (той не може да съхранява примитивни стойности). <em>Weak</em> референция към обект е тази, която не възпрепятства <em>garbage collector</em> (събирача на боклук) ако това е единствената останала препратка. <em>Weak sets</em> се създава с помощта на <em>WeakSet</em> конструктора и има <em>add(), has()</em> и <em>delete()</em> методи. Ето един пример:</p>
	    <dl>
	    	<dd><pre class="highlight">
<span class="code">let</span> set = <span class="code">new</span> WeakSet(),
    key = {};

<span class="comment">// добавяне на обект към set</span>
set.add(key);

console.log(set.has(key));      // true

set.<span class="code">delete</span>(key);

console.log(set.has(key));      // false
	    	</pre></dd>
	    </dl>
	    <p>Използването на <em>weak set</em> прилича на използването на редовен <em>set</em>. Можем да добавяме, премахваме и проверяваме в <em>weak set</em>. Можем също така да изпращаме <em>weak set</em> със стойности подадени <em>iterable</em> към конструктора:</p>
	    <dl>
	    	<dd><pre class="highlight">
<span class="code">let</span> key1 = {},
    key2 = {},
    set = <span class="code">new</span> WeakSet([key1, key2]);

console.log(set.has(key1));     // true
console.log(set.has(key2));     // true
	    	</pre></dd>
	    </dl>
	    <p>В този пример, масива се подава на <em>WeakSet</em> конструктора. Тъй като, този масив съдържа два обекта, тези обекти са добавени в <em>weak set</em>. Имайте в предвид, че ще бъде хвърлена грешка ако масивът съдържа някакви стойности, които не са обект.</p>
	    <h3>Ключови разлики</h3>
	    <p>Най-голямата разлика между <em>weak sets</em> и редовен <em>sets</em> е <em>weak</em> референция държана в стойността на обекта. Ето един пример, какво означава това:</p>
	    <dl>
	    	<dd><pre class="highlight-overflow">
<span class="code">let</span> set = <span class="code">new</span> WeakSet(),
    key = {};

<span class="comment">// добавяне на обект към set</span>
set.add(key);

console.log(set.has(key));      // true

<span class="comment">// премахване на последната силна референция към ключа, като също премахва и от weak set</span>
key = null;
	    	</pre></dd>
	    </dl>
	    <p>След изпълнението на този код, референцията към ключа в <em>weak set</em> вече не е достъпна. Не е възможно да се провери неговото премахване, защото ще трябва една препратка на този обект да се подаде към <em>has()</em>. Това може да направи тестването на <em>weak sets</em> малко объркващо, но вие може да се доверите, че препратката е била правилно отстранена от JavaScript машината.</p>
	    <p>От тези примери, може да се види, че <em>weak sets</em> споделя някои характеристики с редовния <em>sets</em>. Основни разлика са:</p>
	    <dl>
	    	<dd>
	    		<ol>
	    			<li>Методите <em>add(), has()</em> и <em>delete()</em> хвърлят грешка, когато им се подава не-обект.</li>
	    			<li><em>Weak sets</em> не са <em>iterables</em> и следователно не могат да се използват в <em>for</em> цикъл.</li>
	    			<li><em>Weak sets</em> не излагат никакви итератори (като <em>keys()</em> и <em>values()</em>), така, че няма начин програмно да се определи съдържанието на <em>weak set</em>.</li>
	    			<li><em>Weak sets</em> не разполагат с <em>forEach()</em> метод.</li>
	    		</ol>
	    	</dd>
	    </dl>
	    <p>Привидно ограничената функционалност на <em>weak sets</em> е необходима за правилно справяне с паметта. По принцип, ако имате нужда само да следите препратки на обекти, тогава трябва да използвате <em>weak set</em> вместо редовния <em>set</em>.</p>
	    <p><em>Sets</em> дават нов начин да се справим със списък от стойности, но те не са полезни, когато трябва да се асоциира допълнителна информация с тези стойности. Ето защо, ECMAScript 6 добавя <em>maps</em>.</p>
	    <h3>Maps в ECMAScript 6</h3>
	    <p>ECMAScript 6 <em>Map</em> типа е подреден списък от двойки ключ-стойност, където ключа и стойността могат да бъдат от всякакъв тип. Ключовете се разглеждат, като едни и същи с помощта на <em>Object.is()</em>, така че може да имате ключ от 5 и ключ от "5", нищо, че са различни видове. Това е доста по различно, отколкото при използване на обектни свойства, като ключове, които винаги коригираме в <em>string</em> стойности.</p>
	    <p>Елементи се добавят към maps с помощта на <em>set()</em> метод и подаване на ключ и стойност за асоцииране с ключа. След това можем да извлечем стойност чрез подаване на ключа към <em>get()</em>. Например:</p>
	    <dl>
	    	<dd><pre class="highlight">
<span class="code">let</span> map = <span class="code">new</span> Map();
map.set("title", "Understanding ES6");
map.set("year", 2016);

console.log(map.get("title"));      // "Understanding ES6"
console.log(map.get("year"));       // 2016
	    	</pre></dd>
	    </dl>
	    <p>В този пример, се съхраняват две двойки ключ-стойности. Ключа "title" съхранява <em>string</em>, докато ключа "year" съхранява номер. Те по-късно са възстановени с помощта на <em>get()</em>. Ако ключа не съществува, <em>map</em> връща специалната стойност <em>undefined</em> в отговор на извикването на <em>get()</em>.</p>
	    <p>Можем също да използваме обекти, като ключове, нещо, което е невъзможно при използване на обектни свойства. Ето един пример:</p>
	    <dl>
	    	<dd><pre class="highlight">
<span class="code">let</span> map = <span class="code">new</span> Map(),
    key1 = {},
    key2 = {};

map.set(key1, 5);
map.set(key2, 42);

console.log(map.get(key1));         // 5
console.log(map.get(key2));         // 42	    		
	    	</pre></dd>
	    </dl>
	    <p>Този код използва обекти <em>key1</em> и <em>key2</em>, като ключове в <em>map</em> за съхраняване на две различни стойности. Тъй като тези ключове не са коригирани в друга форма, всеки обект се счита за уникален. Това ни позволява да свържем допълнителни данни към обект, без да променяме самия обект.</p>
	    <h3>Map методи</h3>
	    <p><em>Maps</em> споделят няколко метода с <em>sets</em> и умишлено се дава възможност на <em>maps</em> и <em>sets</em> да взаимодействат по подобни начини. Има три метода на разположение за <em>maps</em> и <em>sets</em>:</p>
	    <dl>
	    	<dd>
	    		<ol>
	    			<li><strong>has(key) </strong>- показва дали даден ключ съществува в <em>map</em></li>
	    			<li><strong>delete(key) </strong>- изтрива ключ и свързаната стойност от <em>map</em></li>
	    			<li><strong>clear() </strong>- изтрива всички ключове и стойности от <em>map</em></li>
	    		</ol>
	    	</dd>
	    </dl>
	    <p>В допълнение, <em>maps</em> имат <em>size</em> свойство, което показва, колко двойки ключ-стойности съдържа. Ето един пример:</p>
	    <dl>
	    	<dd><pre class="highlight">
<span class="code">let</span> map = <span class="code">new</span> Map();
map.set("name", "Nicholas");
map.set("age", 25);

console.log(map.size);          // 2

console.log(map.has("name"));   // true
console.log(map.get("name"));   // "Nicholas"

console.log(map.has("age"));    // true
console.log(map.get("age"));    // 25

map.<span class="code">delete</span>("name");
console.log(map.has("name"));   // false
console.log(map.get("name"));   // undefined
console.log(map.size);          // 1

map.clear();
console.log(map.has("name"));   // false
console.log(map.get("name"));   // undefined
console.log(map.has("age"));    // false
console.log(map.get("age"));    // undefined
console.log(map.size);          // 0
	    	</pre></dd>
	    </dl>
	    <p>Както при <em>sets, size</em> свойството винаги съдържа броя на двойките ключ-стойности в <em>map</em>. Този пример започва с два ключа "name" и "age", така че <em>has()</em> връща <em>true</em>, когато е подаден ключ. След това  "name" се отстранява с помощта на <em>delete()</em>, така че, <em>has()</em> връща <em>false</em>, когато е подадено "name" и <em>size</em> свойството показва един елемент по-малко. Метода <em>clear()</em> след това премахва останалите ключове и <em>has()</em> връща <em>false</em> за всички ключове, а <em>size</em> (размера) е 0.</p>
	    <p>Метода <em>clear()</em> е бърз начин за премахване на голямо количество данни от <em>map</em>, но има и начин за добавяне на много данни в <em>map</em> на един път.</p>
	    <h3>Map инициализация</h3>
	    <p>Също като <em>sets</em>, можем да инициализираме <em>map</em> с подаване на масив от данни към <em>Map</em> конструктора. Всеки елемент в масива, трябва да бъде сам по себе си масив, където първия елемент е ключът, а втория стойността. Целия <em>map</em>, следователно е масив от тези два под-масива, например:</p>
	    <dl>
	    	<dd><pre class="highlight">
<span class="code">let</span> map = <span class="code">new</span> Map([ ["name", "Nicholas"], ["age", 25]]);

console.log(map.has("name"));   // true
console.log(map.get("name"));   // "Nicholas"
console.log(map.has("age"));    // true
console.log(map.get("age"));    // 25
console.log(map.size);          // 2
	    	</pre></dd>
	    </dl>
	    <p>Ключовете "name" и "age" се добавят в <em>map</em> чрез инициализация в конструктора. Понеже масива от масиви изглежда малко странно, не е необходимо да си представяме точно ключове, тъй като те могат да бъдат всякакъв тип данни. Съхраняването на тези ключове в масив е единствения начин да се гарантира, че те не са коригирани в друг тип данни преди съхранението.</p>
	    <h3>Метода forEach</h3>
	    <p>Метода <em>forEach()</em> за <em>maps</em> е подобен на <em>forEach()</em> за <em>sets</em> и масиви, в който тя приема функция за обратно извикване, която получава три аргумента:</p>
	    <dl>
	    	<dd>
	    		<ol>
	    			<li>Стойността на следващата позиция в <em>map</em></li>
	    			<li>Ключът за тази стойност</li>
	    			<li><em>Map</em> от който се чете стойността</li>
	    		</ol>
	    	</dd>
	    </dl>
	    <p>Аргументите за обратно извикване по-точно съответстват на <em>forEach()</em> поведение за масиви, където първия аргумент е стойността и втория е ключът (цифров индекс в масива). Ето един пример:</p>
	    <dl>
	    	<dd><pre class="highlight">
<span class="code">let</span> map = <span class="code">new</span> Map([ ["name", "Nicholas"], ["age", 25]]);

map.forEach(<span class="code">function</span>(value, key, ownerMap) {
    console.log(key + " " + value);
    console.log(ownerMap === map);
});	
	    	</pre></dd>
	    </dl>
	    <p>Това е изхода:</p>
	    <dl>
	    	<dd><pre class="highlight">
	    		<p>name Nicholas <br>true <br>age 25 <br>true</p>
	    	</pre></dd>
	    </dl>
	    <p>Обратното повикване получава всяка двойка ключ-стойност в реда на тяхното вмъкване, който е малко по-различно от масиви, където обратното повикване получава всеки елемент в реда на цифровия индекс.</p>
	    <dl>
	    	<dd><div class="info">
         <img src="./img/info.jpg" alt="info">
       </div><strong>Можем също така да представим втори аргумент на <em>forEach()</em> за да зададем <em>this</em> стойност вътре във функцията за обранто извикване. Това поведение е същото, както при <em>set</em> версията на <em>forEach()</em>.</strong></dd>
	    </dl>
	    <h3>Weak Maps</h3>
	    <p><em>Weak maps</em> са <em>maps</em>, както <em>weak sets</em> са <em>sets</em>, което е начин за съхраняване на <em>weak</em> обект препратки. В <em>weak maps</em>, всеки ключ трябва да бъде обект (и ще бъде хвърлена грешка ако се опитате да използвате ключ не-обект) и тези референции на обекти се събират <em>weakly</em>, така че да не пречи на <em>garbage collector</em>. Когато няма други препратки към <em>weak map</em> ключа, двойката ключ-стойност се изважда от <em>weak map</em>.</p>
	    <p>Най-добрият пример за използване на <em>weak maps</em> е да се създаде обект, свързан с конкретен DOM елемент в уеб-страница. Например, някои JavaScript библиотеки за уеб-страници поддържат един потребителски обект за всеки DOM елемент, който е посочен чрез библиотеката и мапнат е съхранен вътрешно в кеша на обектите.  Най-трудната част от този подход е да се определи, кога DOM елемента вече не съществува в уеб-страницата, така че библиотеката да може да премахне свързания обект (и най-важното, не задържа препратката на DOM елемента и по този начин да предизвика загуба на памет). Използването на <em>weak map</em> ще позволи на библиотеката да свърже един потребителски обект с всеки DOM елемент и след това автоматично да унищожи този обект, когато  DOM елемента не съществува вече.</p>
	    <dl>
	    	<dd></dd>
	    </dl><div class="info">
         <img src="./img/info.jpg" alt="info">
       </div><strong>Важно е да се отбележи, че само слаби <em>weak map</em> ключове, а не <em>weak map</em> стойности, са <em>weak</em> референции. Ако един обект се съхранява, като <em>weak map</em> стойност, това ще попречи на <em>garbage collector</em>, ако всички други референции са премахнати.</strong></dd>
	    </dl>
	    <h3>Използване на Weak Maps</h3>
	    <p>В ECMAScript 6 <em>WeakMap</em> типа е неподреден списък от двойки ключ-стойности, където ключа трябва да бъде не нулев обект, а стойността може да бъде всякакъв тип. Интерфейса за <em>WeakMap</em> е много подобен на този за <em>Map</em>, където <em>set()</em> и <em>get()</em> се използват за добавяне и извличане на данни съответно.</p>
	    <dl>
	    	<dd><pre class="highlight">
<span class="code">let</span> map = <span class="code">new</span> WeakMap(),
    element = <span class="code">document</span>.querySelector(".element");

map.set(element, "Original");

<span class="code">let</span> value = map.get(element);
console.log(value);             // "Original"

<span class="comment">// премахване на елемент</span>
element.parentNode.removeChild(element);
element = null;

<span class="comment">// the weak map е празен в този момент</span>
	    	</pre></dd>
	    </dl>
	    <p>В този пример, се съхранява една двойка ключ-стойност. Ключът е DOM елемент, който се използва за съхраняване на съответната <em>string</em> стойност. След това тази стойност се извлича чрез преминаване през DOM елемента с <em>get()</em>. Ако DOM елемента след това се премахне от документа и променливата референция е настроена на <em>null</em>, тогава данните се отстраняват от <em>weak map</em>.</p>
	    <p>Подобно на <em>weak sets</em>, няма начин да се провери дали <em>weak map</em> е празен, защото няма <em>size</em> свойство. Понеже няма останали препратки към ключа, не можем да използваме <em>get()</em> да се опита да извлече стойността. <em>Weak map</em> е отрязал достъпа до стойността на този ключ и когато <em>garbage collector</em> заработи паметта ще бъде празна.</p>
	    <h3>Инициализация на Weak Map</h3>
	    <p><em>Weak maps</em> могат да се инициализират по същия начин, като редовните <em>maps</em>: чрез подаване на масив от масиви към <em>WeakMap</em> конструктора. Да повторим още веднъж, всеки елемент в масива трябва да бъде сам по себе си масив с два елемента, където първият елемент е ключът (обект) и втория елемент е стойността (всички типове данни).</p>
	    <dl>
	    	<dd><pre class="highlight">
<span class="code">let</span> key1 = {},
    key2 = {},
    map = <span class="code">new</span> WeakMap([ [key1, "Hello"], [key2, 42]]);

console.log(map.has(key1));     // true
console.log(map.get(key1));     // "Hello"
console.log(map.has(key2));     // true
console.log(map.get(key2));     // 42
	    	</pre></dd>
	    </dl>
	    <p>Обектите <em>key1</em> и <em>key2</em> се използват, като ключове в <em>weak map</em> и те могат да бъдат достъпни с <em>get()</em> и <em>has()</em>. Грешка се хвърля, ако има ключ, който не е обект в данните подадени на <em>WeakMap</em>.</p>
	    <h3>Weak Map методи</h3>
	    <p><em>Weak maps</em> имат само няколко допълнителни метода на разположение, за да взаимодействат със своите елементи. Това са <em>has()</em> метод за да определи дали съществува даден ключ в <em>map</em> и <em>delete()</em> метод за премахване на специфична двойка ключ-стойност. Няма <em>clear()</em> метод, защото това изисква изброяване на ключове и както при <em>weak sets</em>, това също не е възможно за <em>weak maps</em>. Ето един пример:</p>
	    <dl>
	    	<dd><pre class="highlight">
<span class="code">let</span> map = <span class="code">new</span> WeakMap(),
    element = <span class="code">document</span>.querySelector(".element");

map.set(element, "Original");

console.log(map.has(element));   // true
console.log(map.get(element));   // "Original"

map.<span class="code">delete</span>(element);
console.log(map.has(element));   // false
console.log(map.get(element));   // undefined
	    	</pre></dd>
	    </dl>
	    <p>Тука, DOM елемента отново е използван, като ключ в <em>weak map</em>. Метода <em>has()</em> е подходящ за проверка, за да видим дали референцията в момента се използва, като ключ в <em>weak map</em>. Имайте в предвид, че това работи само, когато имате не-нулева референция за ключ. Ключът насилствено е премахнат от <em>weak map</em> с помощта на <em>delete()</em>, в която точка <em>has()</em> връща <em>false</em> и <em>get()</em> връща <em>undefined</em>.</p>
	    <h3>Частни обект данни</h3>
	    <p>Докато повечето разработчици обмислят основната употреба на случаи за <em>weak maps</em>, за асоцииране на данни с DOM елементи, има няколко възможни употреби (и няма съмнение, че има някои, които все още предстоят да бъдат открити). Една практическа употреба на <em>weak maps</em> е да съхранява данни, които са частни инстанции на обект.  Всички свойства на обекти са публични в ECMAScript 6 и ще трябва да използвате някои творчески идеи, за да направите достъпа до данните на обекта, но не достъп до всичко. Да разгледаме следващия пример:</p>
	    <dl>
	    	<dd><pre class="highlight">
<span class="code">function</span> Person(name) {
    this._name = name;
}

Person.prototype.getName = <span class="code">function</span>() {
    <span class="code">return this</span>._name;
};
	    	</pre></dd>
	    </dl>
	    <p>Този код използва общата конвенция от водеща долна черта, за да покаже, че този обект се счита за частен и не трябва да бъде променян извън инстанцията на обекта. Намерението е да се  използва <em>getName()</em> за да прочете <em>this._name</em> и да не позволи на тази стойност да бъде променяна. Обаче, няма нищо което да стои на пътя на някой да пише на <em>_name</em> свойството, така че да може да бъде презаписано умишлено или случайно.</p>
	    <p>Използвайки ECMAScript 5, беше възможно да се доближим до истински частни данни с помощта на модел, като този например:</p>
	    <dl>
	    	<dd><pre class="highlight-overflow">
<span class="code">let</span> Person = (<span class="code">function</span>() {

    <span class="code">let</span> privateData = {},
        privateId = 0;

    <span class="code">function</span> Person(name) {
        <span class="code">Object</span>.defineProperty(<span class="code">this</span>, "_id", { value: privateId++ });

        privateData[<span class="code">this</span>._id] = {
            name: name
        };
    }

    Person.prototype.getName = <span class="code">function</span>() {
        <span class="code">return</span> privateData[<span class="code">this</span>._id].name;
    };

    <span class="code">return</span> Person;
}());	
	    	</pre></dd>
	    </dl>
	    <p>Този пример увива дефиницията на <em>Person</em> с IIFE , която съдържа две частни променливи <em>privateData</em> и <em>privateId</em>. Обекта <em>privateData</em> съхранява лична информация за всеки отделен случай, докато <em>unique ID</em> се използва за генериране на уникално <em>ID</em> за всеки отделен случай. Когато <em>Person</em> конструктора се извика, се добавя свойството <em>_id</em>, така че да е <em>nonenumerable, nonconfigurable</em> и <em>nonwritable</em> (което означава, че не може случайно да бъде презаписана). След това, се прави запис в <em>privateData</em> обекта, който съответства на <em>ID</em> за инстанция на обект, това е когато се съхранява информация за името. По-късно в <em>getName()</em>, името може да бъде възстановено с <em>this._id</em>, като ключ в <em>privateData</em>. Понеже <em>privateData</em> не е достъпна извън IIFE, актуалните данни са в безопасност, въпреки че <em>this._id</em> е изложен публично. Големият проблем при този подход е, че данните в <em>privateData</em> винаги остават, защото няма начин да се знае, кога е унищожена инстанция на обект, което означава, че допълнителни данни винаги ще бъдат оставени в <em>privateData</em>. Този проблем може да бъде решен, чрез  използване на <em>weak map</em>:</p>
	    <dl>
	    	<dd><pre class="highlight">
<span class="code">let</span> Person = (<span class="code">function</span>() {

    <span class="code">let</span> privateData = <span class="code">new</span> WeakMap();

    <span class="code">function</span> Person(name) {
        privateData.set(<span class="code">this</span>, { name: name });
    }

    Person.prototype.getName = <span class="code">function</span>() {
        return privateData.get(<span class="code">this</span>).name;
    };

    <span class="code">return</span> Person;
}());	
	    	</pre></dd>
	    </dl>
	    <p>Тази версия на кода използва <em>weak map</em> за частни данни, вместо обект. Тъй като, самата инстанция обект може да се използва, като ключ, няма нужда да следите отделно <em>ID</em>. Когато <em>Person</em> конструктора се извика, се прави нов запис в <em>weak map</em> с ключ <em>this</em> и стойност от обект, който съдържа лична информация (в този случай, просто име). Тази информация е извлечена отвътре от <em>getName()</em> чрез преминаване на <em>this</em> през <em>privateData.get()</em> за да извлече обект от данни и достъп до свойството <em>name</em>. По този начин личната информация се пази в тайна и ще бъде унищожена, когато инстанцията на обекта е унищожена.</p>
	    <h3>Използване и ограничения</h3>
	    <p>При вземането на решение, дали да използвате <em>weak map</em> или редовен <em>map</em>, основният мотив е дали искате да използвате ключове обекти. Всеки път, когато вие ще използвате ключове обекти най-добрия избор е <em>weak map</em>. Това ще ви позволи да оптимизирате използването на паметта и да избегнете загуба на памет, като гарантирате, че допълнителните данни не се съхраняват на около след,  като вече не са достъпни.</p>
	    <p>Имайте в предвид, че <em>weak maps</em> дават много малка видимост в съдържанието им, така че не можете да използвате <em>forEach()</em>, <em>size</em> или <em>clear()</em> за управление на елементите. Ако имате нужда от някои възможности за инспекция, тогава редовния  <em>maps</em> е по-добрия избор. Само не забравяйте да държите под око използването на паметта.</p>
	    <p>Разбира се, ако искате да използвате само ключове не-обекти, тогава редовния <em>maps</em> е вашия избор.</p>
	</article>
	<footer>
		<h3>Обобщение</h3>
		<p>ECMAScript 6 официално въвежда <em>sets</em> и <em>maps</em> в езика. Преди това, програмистите често използват обекти за да имитират <em>sets</em> и <em>maps</em>, което често работи с проблеми поради ограниченията, свързани със свойствата на обекта.</p>
		<p><em>Sets</em> са неподредени списъци на уникални стойности. Стойностите се считат за уникални, ако те не са еквивалентни, съгласно <em>Object.is(). Sets</em> автоматично премахва дублиращите се стойности, така че може да се използва за филтриране на масив за дубликати и връщане на резултата. <em>Sets</em> не са подкласове на масиви, така че няма случаен достъп до техните стойности. Вместо това може да използвате <em>has()</em> метод, за да определите дали една стойност се съдържа в <em>set</em> и <em>size</em> свойство, за да разберете броя на стойностите включени в <em>set</em>. Има също така <em>forEach()</em> за обработка на всяка зададена стойност.</p>
		<p><em>Weak sets</em> са специален тип <em>set</em>, който може да съдържа само обекти. Обектите се съхраняват с <em>weak</em> референции, което означава, че те няма да блокират <em>garbage collection</em> ако това е единствената останала референция. Не възможно да се инспектира <em>weak set</em> съдържанието поради сложността на управление на паметта, така че най-добре да ги използвате само за проследяване на обекти, които трябва да бъдат групирани заедно.</p>
		<p><em>Maps</em> са неподредени двойки ключ-стойности, като ключа може да бъде всеки тип данни. Подобно на <em>sets</em>, дублираните ключове се определят от <em>Object.is()</em>, което означава, че можем да имаме цифров ключ 5 и <em>string</em> "5" като два отделни ключа. Всеки тип данни може да се използва, като стойност за асоцииране към ключ, използвайки <em>set()</em> и стойността по-късно може да бъде извлечена чрез използване на <em>get()</em>. <em>Maps</em> също имат <em>size</em> свойство и <em>forEach()</em> метод, за да се даде възможност за по-лесен достъп.</p>
		<p><em>Weak maps</em> са специален вид <em>map</em>, който може да има само ключове обекти. Както и при <em>weak sets</em>, тези референции на ключове обекти са <em>weak</em> и не пречат на <em>garbage collection</em> когато те са единствената останала референция. Когато ключа е изчистен свързаната с него стойност се премахва от <em>weak map</em>. Този аспект на управление на паметта прави <em>weak maps</em> уникално подходящи за съгласуване на допълнителна информация с обекти, чиито жизнен цикъл се управлява извън кода за достъп до тях.</p>
	</footer>
	<nav>
	<a href="./06_simbols.html" title="previous chapter">◀</a>
  <a href="./index.html" title="cover">◆</a>
  <a href="08_iterators_and_generators.html" title="next chapter">▶</a>
</nav>
</body>
</html>

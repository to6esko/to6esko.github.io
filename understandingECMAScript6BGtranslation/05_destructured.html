<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Destucturing за по-лесен достъп до данни :: Understanding ECMAScript 6</title>
	<link rel="stylesheet" href="font.css">
</head>
<body>
	<nav>
	<a href="./04_object_function.html" title="previous chapter">◀</a>
  <a href="./index.html" title="cover">◆</a>
  <a href="./06_simbols.html" title="next chapter">▶</a>
</nav>
	
	<header id="header" class="">
		<h1><div class="head-num">Глава 5</div>Destructuring за по-лесен достъп до данни</h1>
		<p>Обекти и масиви са най-често използваните означения в JavaScript и благодарение на популярния формат JSON <em>data</em>, те станаха особено важна част от езика. Това е честа практика да се определят обекти и масиви и след това системно да се извадят видовите информация от тези структури. ECMAScript 6 опростява тази задача чрез добавяне на <em>destucturing</em> (разграждане), което е процес на разчупване на структурата от данни на по-малки части. Тази глава ще ви покаже, как да извлечем полза от <em>destucturing</em> на обекти и масиви.</p>
		<h3>Защо destucturing е полезно?</h3>
		<p>В ECMAScript 5 и по-рано, извличането на необходима информация от обекти и масиви може да доведе до писане на много код, който изглежда по същия начин, само за да получите някои данни на локални променливи. Например:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">let</span> options = {
        repeat: <span class="code">true</span>,
        save: <span class="code">false</span>
    };

<span class="comment">// извлича данни от обекта</span>
<span class="code">let</span> repeat = options.repeat,
    save = options.save;
				
			</pre></dd>
		</dl>
		<p>Този код извлича стойностите на <em>repeat</em> и <em>save</em> от опциите на обекта и съхранява тези данни в локални променливи със същите имена. Докато този код изглежда прост, представете си, че имате голям брой променливи за присвояване, вие трябва да ги присвоите една по една. И ако имате данни с вложена структура, вместо да пресечете и намерите информацията, може да се наложи да копаете през цялата структура само за да намерите една част от данните.</p>
		<p>Ето защо, ECMAScript 6 добавя <em>destucturing</em> на обекти и масиви. Когато се начупи структурата от данни на по-малки части, получаването на информацията, която трябва от тях става много по-лесно. Много езици прилагат <em>destucturing</em> с минимално количество на синтаксиса, за да направят процеса по-лесен за използване. Изпълнението на ECMAScript 6 действително използва синтаксис, с който вече сте запознати: синтаксиса за обекти и масиви.</p>
	</header><!-- /header -->
	<article>
		<h3>Destucturing на обект</h3>
		<p>Синтаксиса за <em>destucturing</em> на обект използва обекта от лявата страна на операцията. Например:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">let</span> node = {
        type: "Identifier",
        name: "foo"
    };

<span class="code">let</span> { type, name } = node;

console.log(type);      // "Identifier"
console.log(name);      // "foo"
				
			</pre></dd>
		</dl>
		<p>В този код, стойността на <em>node.type</em> се съхранява в променливата <em>type</em>, а стойността на <em>node.name</em> се съхранява в променливата <em>name</em>. Този синтаксис е същия, като за инициализиране на свойствa на обект с краткия синтаксис представен в <a href="./04_object_function.html #shorthand">Глава 4</a>.</p>
		<p>Идентификаторите <em>type</em> и <em>name</em> са двете декларации на локални променливи и свойствата четат стойността от опциите на обекта.</p>
		<div class="aside">
		<h3>Не забравяйте инициализатора</h3>
		<p>Когато използваме <em>destucturing</em> за деклариране на променливи, използвайки <em>var, let</em> или <em>const</em>, ние трябва да предоставим инициализатор (стойността след знака за равенство).  Следващия код, всички изрази хвърлят синтактични грешки, поради липса на инициализатор:</p>
		<pre class="highlight">
// syntax error!
<span class="code">var</span> { type, name };

// syntax error!
<span class="code">let</span> { type, name };

// syntax error!
<span class="code">const</span> { type, name };
				
			</pre>
		<p>Докато <em>const</em> винаги изисква инициализатор, дори когато се използва за <em>nondestructured</em> променливи, <em>var</em> и <em>let</em> изискват да се инициализират само, когато се използват за <em>destucturing</em>.</p>
		</div>
		<h3>Destucturing на присвояване</h3>
		<p>Примерите за обектно <em>destucturing</em> до сега използваха декларации на променливи. Обаче, е възможно да се използва за <em>destucturing</em> на присвоявания. Например може да искаме да променим стойностите на променливите след, като те са определени, както следва:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">let</span> node = {
        type: "Identifier",
        name: "foo"
    },
    type = "Literal",
    name = 5;

<span class="comment">// задаване на различни стойности използвайки destucturing</span>
({ type, name } = node);

console.log(type);      // "Identifier"
console.log(name);      // "foo"
				
			</pre></dd>
		</dl>
		<p>В този пример <em>type</em> и <em>name</em> се инициализират със стойности, когато се декларират, а след това две променливи със същите имена се инициализират с различни стойности. Следващия ред използва присвояване за да промени тези стойности, чрез четенето им от <em>node</em> обекта. Имайте в предвид, че трябва да се сложат скоби около изявлението за присвояване. Това е така, защото във фигурните скоби се очаква да бъде блок изявление, а блок изявлението не може да се появи от лявата страна на присвояването. Скобите са сигнал, че следващите фигурни скоби не са изявление на блок и трябва да се тълкуват, като израз, позволявайки на присвояването да завърши.</p>
		<dl>
			<dd><div class="worning">
         <img src="./img/worning.jpg" alt="worning">
       </div><strong>Грешка се хвърля, когато дясната страна на <em>destucturing</em> израза за присвояване (израза след = ) се оцени на <em>null</em> или <em>undefined</em>. Това се случва, защото резултата на всеки опит да се прочете свойство на <em>null</em> или <em>undefined</em>, е грешка по време на работа.</strong></dd>
		</dl>
		<h3>Стойности по подразбиране</h3>
		<p>Когато използваме <em>destucturing</em> в изявлението за присвояване, ако зададем локална променлива с име на свойство, което не съществува в обекта, тази локална променлива присвоява стойност <em>undefined</em>. Например:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">let</span> node = {
        type: "Identifier",
        name: "foo"
    };

<span class="code">let</span> { type, name, value } = node;

console.log(type);      // "Identifier"
console.log(name);      // "foo"
console.log(value);     // undefined
				
			</pre></dd>
		</dl>
		<p>Този код определя допълнителна локална променлива, наречена <em>value</em> и се опитва да и зададе стойност. Обаче, такова съответно <em>value</em> свойство не съществува в <em>node</em> обекта, така че на променливата се дава стойност <em>undefined</em>, както се очаква.</p>
		<p>Може евентуално да се определи стойност по подразбиране, за да я използваме, когато определено свойство не съществува. За да направим това, трябва да поставим знака за равенство (=) след  името на свойството и да определим стойността по подразбиране, като това:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">let</span> node = {
        type: "Identifier",
        name: "foo"
    };

<span class="code">let</span> { type, name, value = true } = node;

console.log(type);      // "Identifier"
console.log(name);      // "foo"
console.log(value);     // true
				
			</pre></dd>
		</dl>
		<p>В този пример, на променливата <em>value</em> е дадено <em>true</em>, като стойност по подразбиране. Стойността по подразбиране се използва само, ако свойството липсва в <em>node</em> или има стойност <em>undefined</em>. Тъй като няма <em>node.value</em> свойство, променливата <em>value</em> използва стойността по подразбиране. Това работи подобно на стойностите на параметрите по подразбиране за функции, както е описано в <a href="./03_function.html #defaut">Глава 3</a>.</p>
		<h3>Присвояване на различни локални имена на променливи</h3>
		<p>До този момент, всеки пример за <em>destucturing</em> на присвояване, използва името на свойство на обекта, като локално име на променлива.  Например, стойността на <em>node.type</em> се съхранява в <em>type</em> променлива. Това работи добре, когато искаме да използваме същото име, но какво ще стане ако не го направим? ECMAScript 6 има разширен синтаксис, който ни позволява да присвоим локална променлива с различно име, този синтаксис прилича на дългия запис за инициализиране на обект литерал.</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">let</span> node = {
        type: "Identifier",
        name: "foo"
    };

<span class="code">let</span> { type: localType, name: localName } = node;

console.log(localType);     // "Identifier"
console.log(localName);     // "foo"
				
			</pre></dd>
		</dl>
		<p>Този код използва <em>destucturing</em> на присвояването, за да декларира <em>localType</em> и <em>localName</em> променливите, които съдържат стойностите от <em>node.type</em> и <em>node.name</em> свойствата, съответно. Синтаксиса <em>type: localType</em> казва да се прочете свойство с име <em>type</em> и да се съхрани стойността му в <em>localType</em> променливата. Този синтаксис е ефективно обратен на традиционния синтаксис за обект литерал, където името е от лявата страна на двуточието, а стойността е от дясната страна. В този случай, името е от дясната страна на двуточието, а местоположението на стойността се чете от ляво.</p>
		<p>Можем да добавим стойност по подразбиране, като използваме различно име на променлива. Знака за равенство и стойност по подразбиране все още се поставят след локалното име на променливата. Например:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">let</span> node = {
        type: "Identifier"
    };

<span class="code">let</span> { type: localType, name: localName = "bar" } = node;

console.log(localType);     // "Identifier"
console.log(localName);     // "bar"
				
			</pre></dd>
		</dl>
		<p>Тука, променливата <em>localName</em> има стойност по подразбиране "bar". Променливата присвоява тази стойност по подразбиране, защото няма <em>node.name</em> свойство.</p>
		<p>До сега видяхме, как да се справим с <em>destucturing</em> на даден обект, чиито свойства са примитивни стойности, но <em>destucturing</em>на обект, може да се използва за извличане на стойности от структури на вложени обекти.</p>
		<h3>Destucturing на вложени обекти</h3>
		<p>С помощта на синтаксис подобен за обект литерали, можем да навигираме в структура на вложени обекти, за да извлечем само информацията, която искаме. Ето един пример:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">let</span> node = {
        type: "Identifier",
        name: "foo",
        loc: {
            start: {
                line: 1,
                column: 1
            },
            end: {
                line: 1,
                column: 4
            }
        }
    };

<span class="code">let</span> { loc: { start }} = node;

console.log(start.line);        // 1
console.log(start.column);      // 1
				
			</pre></dd>
		</dl>
		<p>Схемата за <em>destucturing</em> в този пример използва фигурни скоби за да покаже, че моделът трябва да се спусне в свойството <em>loc</em> на <em>node</em> и да търси <em>start</em> свойството. Спомнете си от предния раздел, че винаги, когато има двуточие в модела за <em>destucturing</em>, това означава, че идентификатора преди двуточието дава мястото за инспектиране, а от дясната страна присвоява стойност. Когато има фигурни скоби след двуточието, показва, че дестинацията е вложена в друго ниво на обекта.</p>
		<p>Можем да отидем една стъпка напред и да използваме различно име за локална променлива, като това:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">let</span> node = {
        type: "Identifier",
        name: "foo",
        loc: {
            start: {
                line: 1,
                column: 1
            },
            end: {
                line: 1,
                column: 4
            }
        }
    };

// extract node.loc.start
<span class="code">let</span> { loc: { start: localStart }} = node;

console.log(localStart.line);   // 1
console.log(localStart.column); // 1
				
			</pre></dd>
		</dl>
		<p>В тази версия на кода, <em>node.loc.start</em> се съхранява в нова локална променлива, наречена <em>localStart</em>. Моделите на <em>destucturing</em> могат да бъдат вложени до произволно ниво на дълбочина с всички налични опции на разположение за всяко ниво.</p>
		<p>Обектното <em>destucturing</em> е много мощно и има много опции, но <em>destucturing</em> на масив предлага някои уникални възможности, които позволяват извличане на информация от масиви.</p>
		<div class="aside">
		<h3>Синтаксис Gotcha (клопка на езика)</h3>
		<p>Бъдете внимателни, когато използвате вложено <em>destucturing</em>, защото може по невнимание да създадете изявление, което няма никакъв ефект. Празните фигурни скоби са разрешени при <em>destucturing</em> на обект, но те не правят нищо. Например:</p>
		<pre class="highlight">
<span class="comment">// Няма обявени променливи!</span>
<span class="code">let</span> { loc: {} } = node;
				
			</pre>
		<p>Няма обявено обвързване в тази декларация. Понеже фигурните скоби в дясно от <em>loc</em> се използват за място на инспектиране, а не за създаване на обвързване. В този случай, най-вероятно имаме намерение да използваме  =  за да определим стойност по подразбиране, вместо да определим местоположение. Възможно е този синтаксис да бъде забранен в бъдеще, но за сега <em>gotcha</em> се грижи за това.</p>
		</div>
		<h3>Destucturing на масиви</h3>
		<p>Синтаксиса на <em>destucturing</em> на масиви е много подобен на синтаксиса на <em>destucturing</em> на обект литерали. Той просто използва масив литерал синтаксис, вместо обект литерал синтаксис. Разликата е, че <em>destucturing</em> на масиви работи с позиции в рамките на масива, а не с обявените свойства, които са налични в обекта. Например:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">let</span> colors = [ "red", "green", "blue" ];

<span class="code">let</span> [ firstColor, secondColor ] = colors;

console.log(firstColor);        // "red"
console.log(secondColor);       // "green"
				
			</pre></dd>
		</dl>
		<p>Тука, <em>destucturing</em> на масива вади стойностите "red" и "green" от <em>colors</em> масива и ги съхранява в <em>firstColor</em> и <em>secondColor</em> променливите. Тези стойности са избрани заради тяхната позиция в масива, като действителните имена на променливите могат да бъдат всичко. Всеки елемент, който не е споменат в модела на <em>destucturing</em> се игнорира. Имайте в предвид, че самия масив не се променя по никакъв начин.</p>
		<p>Можем също така да пропуснем елементи в схемата на <em>destucturing</em> и да предоставим само имената на променливите за елементите, които ни интересуват. Ако например, искаме третата стойност в масива, не е необходимо да представиме имената на променливите за първия и втория елемент. Ето как става това:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">let</span> colors = [ "red", "green", "blue" ];

<span class="code">let</span> [ , , thirdColor ] = colors;

console.log(thirdColor);        // "blue"
				
			</pre></dd>
		</dl>
		<p>Този код използва <em>destucturing</em> на присвояване за извличане на третия елемент в <em>colors</em>. Запетаите преди <em>thirdColor</em> в модела са запазени места за елементите в масива, които са преди него. С използването на този подход, можем лесно да избираме стойности от произволен брой слотове в средата на масив, без да е необходимо да се предоставят имена на променливи за тях.</p>
		<dl>
			<dd><div class="worning">
         <img src="./img/worning.jpg" alt="worning">
       </div><strong>Подобно на обектното <em>destucturing</em>, трябва винаги да се осигури инициализатор, когато се използва <em>destucturing</em>на масив с <em>var, let</em> или <em>const</em>.</strong></dd>
		</dl>
		<h3>Destucturing на присвояване</h3>
		<p>Можем да използваме <em>destucturing</em> на масив в контекста на присвояването, но за разлика от обектното <em>destucturing</em> не е необходимо да се обвива израза в скоби. Например:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">let</span> colors = [ "red", "green", "blue" ],
    firstColor = "black",
    secondColor = "purple";

[ firstColor, secondColor ] = colors;

console.log(firstColor);        // "red"
console.log(secondColor);       // "green"
				
			</pre></dd>
		</dl>
		<p><em>Destucturing</em> на присвояването в този код работи по подобен начин на миналия пример за <em>destucturing</em> на масив. Единствената разлика е, че <em>firstColor</em> и <em>secondColor</em> са вече дефинирани. През повечето време, това вероятно е всичко, което трябва да знаете за <em>destucturing</em> на присвояване за масиви, но има още нещо, което вероятно ще намерите за полезно.</p>
		<p><em>Destucturing</em> на присвояване за масиви има уникален случай на използване, което го прави по-лесен за сменяне на стойностите на две променливи. Смяната на стойност е обща операция в алгоритъм за сортиране, в ECMAScript 5 начина за смяна на променливи включва трета временна променлива, като този пример:</p>
		<dl>
			<dd><pre class="highlight">
<span class="comment">// Смяна на променлива в ECMAScript 5</span> 
<span class="code">let</span> a = 1,
    b = 2,
    tmp;

tmp = a;
a = b;
b = tmp;

console.log(a);     // 2
console.log(b);     // 1
				
			</pre></dd>
		</dl>
		<p>Междинната променлива <em>tmp</em> е необходима за да се разменят стойностите на <em>a</em> и <em>b</em>. Използването на <em>destucturing</em> на присвояване за масив, не изисква такава променлива. Ето как можем да сменим променливите в ECMAScript 6:</p>
		<dl>
			<dd><pre class="highlight">
<span class="comment">// Смяна на променлива в ECMAScript 6</span>
<span class="code">let</span> a = 1,
    b = 2;

[ a, b ] = [ b, a ];

console.log(a);     // 2
console.log(b);     // 1
				
			</pre></dd>
		</dl>
		<p><em>Destucturing</em> на присвояването за масив в този пример, изглежда като огледален образ. Лявата страна на присвяването (преди знака за равно) е модел за <em>destucturing</em>, точно както в другите примери за <em>destucturing</em> на масив. Дясната страна е масив литерал, който временно е създаден за размяната. <em>destucturing</em> се случва в временния масив, който има стойности <em>b</em> и <em>a</em> копирани в своята първа и втора позиция. Ефекта е, че тези променливи разменят стойностите.</p>
		<dl>
			<dd><div class="worning">
         <img src="./img/worning.jpg" alt="worning">
       </div><strong>Както <em>destucturing</em>на присвояване за обект, грешка се хвърля, когато дясната страна на израза на <em>destucturing</em> на присвояването се оценява на <em>null</em> или <em>undefined</em>.</strong>
   </dd>
</dl>
		<h3>Стойности по подразбиране</h3>
		<p><em>Destucturing</em> на присвояване за масиви, ни позволява да определим стойности по подразбиране за всяка позиция в масива, също. Стойността по подразбиране се използва, когато свойството на дадена позиция не съществува или има стойност <em>undefined</em>. Например:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">let</span> colors = [ "red" ];

<span class="code">let</span> [ firstColor, secondColor = "green" ] = colors;

console.log(firstColor);        // "red"
console.log(secondColor);       // "green"
				
			</pre></dd>
		</dl>
		<p>Този код за масива <em>colors</em> има само един елемент, така че няма нищо за съвпадение със <em>secondColor</em>. Тъй като има стойност по подразбиране <em>secondColor</em>, която е настроена на "green" вместо на <em>undefined</em>.</p>
		<h3>Вложен destucturing</h3>
		<p>Можем да <em>destucturing</em> вложени масиви, по начин подобен на <em>destucturing</em> на вложени обекти. Чрез вмъкване на друг модел масив в общия модел и <em>destucturing</em> ще слезе във вложения масив, като това:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">let</span> colors = [ "red", [ "green", "lightgreen" ], "blue" ];

// later

<span class="code">let</span> [ firstColor, [ secondColor ] ] = colors;

console.log(firstColor);        // "red"
console.log(secondColor);       // "green"
				
			</pre></dd>
		</dl>
		<p>Тука <em>secondColor</em> променливата се отнася до "green" стойността в <em>colors</em> масива. Този елемент се съдържа в рамките на втория масив, така че не са необходими допълнителни квадратни скоби около <em>secondColor</em> в модела за <em>destucturing</em>. Както при обектите, можем да влизаме в масиви произволно дълбоко.</p>
		<h3>Rest елементи</h3>
		<p>В <a href="./03_function.html">Глава 3</a> въведохме <a href="./03_function.html #rest"><em>rest</em></a> параметри за функции, <em>destucturing</em> на  масиви има подобна концепция, наречена <em>rest</em> елементи. <em>Rest</em> елементите използват три точковия  ...  синтаксис за присвояване на останалите елементи в масива с конкретна променлива. Ето един пример:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">let</span> colors = [ "red", "green", "blue" ];

<span class="code">let</span> [ firstColor, ...restColors ] = colors;

console.log(firstColor);        // "red"
console.log(restColors.length); // 2
console.log(restColors[0]);     // "green"
console.log(restColors[1]);     // "blue"
				
			</pre></dd>
		</dl>
		<p>Първият елемент в <em>colors</em> се присвоява от <em>firstColor</em>, а останалите (<em>rest</em>) са присвоени от новия <em>restColors</em> масив. Масива <em>restColors</em> следователно, има две позиции "green" и "blue". <em>Rest</em> елементите са полезни за извличане на определени елементи от масив и запазване на останалите налични елементи, но има и друга полезна употреба.</p>
		<p>Голям пропуск на JavaScript масивите е възможността лесно да създават клонинг. В ECMAScript 5, разработчиците, често използват <em>concat()</em> метода, като лесен начин за клониране на масив. Например:</p>
		<dl>
			<dd><pre class="highlight">
<span class="comment">// клониране на масив в ECMAScript 5</span>
<span class="code">var</span> colors = [ "red", "green", "blue" ];
<span class="code">var</span> clonedColors = colors.concat();

console.log(clonedColors);      //"[red,green,blue]"
				
			</pre></dd>
		</dl>
		<p>Докато <em>concat()</em> метода е предназначен да се слепят два масива заедно, извиквайки го без аргумент, връща клонинг на масива. В ECMAScript 6 можем да използваме <em>rest</em> елементите, за да постигнем същото нещо, чрез синтаксис, предназначен да функционира по същия начин. То работи по следния начин:</p>
		<dl>
			<dd><pre class="highlight">
<span class="comment">// клониране на масив в ECMAScript 6</span>
<span class="code">let</span> colors = [ "red", "green", "blue" ];
<span class="code">let</span> [ ...clonedColors ] = colors;

console.log(clonedColors);      //"[red,green,blue]"
				
			</pre></dd>
		</dl>
		<p>В този пример, <em>rest</em> елементите се използват за копиране на стойности от <em>colors</em> масива в <em>clonedColors</em> масива. Въпреки, че е въпрос на възприемане, дали тази техника прави намеренията на разработчика по-ясни от метода <em>concat()</em>, това е полезна информация, с която да бъдем наясно.</p>
		<dl>
			<dd><div class="worning">
         <img src="./img/worning.jpg" alt="worning">
       </div><strong><em>Rest</em> елементите трябва да са последното влизане в <em>destucturing</em> на масива и не могат да бъдат последвани от запетая.</strong></dd>
		</dl>
		<h3>Смесен destucturing</h3>
		<p><em>Destucturing</em> на обекти и масиви може да се използва за създаване на по-сложни изрази. По този начин, вие ще сте в състояние да извличате парчета с информация, която искате от всяко смесване на обекти и масиви. Например:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">let</span> node = {
        type: "Identifier",
        name: "foo",
        loc: {
            start: {
                line: 1,
                column: 1
            },
            end: {
                line: 1,
                column: 4
            }
        },
        range: [0, 3]
    };

<span class="code">let</span> {
    loc: { start },
    range: [ startIndex ]
} = node;

console.log(start.line);        // 1
console.log(start.column);      // 1
console.log(startIndex);        // 0
				
			</pre></dd>
		</dl>
		<p>Този код извлича <em>node.loc.start</em> и <em>node.range[0]</em> в <em>start</em> и <em>startIndex</em>, съответно. Имайте в предвид, че <em>loc:</em> и <em>range:</em> в модела на <em>destucturing</em> са само места, които съответстват на свойства в <em>node</em> обекта. Те не са част от <em>node</em>, който не може да бъде извлечен чрез <em>destucturing</em>, когато използвате комбинация от <em>destucturing</em> на обект и масив. Този подход е особено полезен за извличане на стойности от структура на JSON конфигурация без навигиране по цялата структура.</p>
		<h3>Destucturing на параметри</h3>
		<p><em>destucturing</em> има още един особено полезен случай на употреба, това е при подаване на аргументи на функция.  Когато JavaScript функцията взема голям брой избираеми параметри, един общ модел е да се създаде обект с опции, чиито свойства определят допълнителни параметри, като тези:</p>
		<dl>
			<dd><pre class="highlight">
<span class="comment">// свойствата на options предоставят допълнителни параметри</span>
<span class="code">function</span> setCookie(name, value, options) {

    options = options || {};

    <span class="code">let</span> secure = options.secure,
        path = options.path,
        domain = options.domain,
        expires = options.expires;

    <span class="comment">// код за задаване на cookie</span>
}

<span class="comment">// карта на третия аргумент за опции</span>
setCookie("type", "js", {
    secure: <span class="code">true</span>,
    expires: 60000
});
				
			</pre></dd>
		</dl>
		<p>Много JavaScript библиотеки съдържат <em>setCookie()</em>, които изглеждат по подобен начин, като тази. В тази функция, <em>name</em> и <em>value</em> са задължителни аргументи, но <em>secure, path, domain</em> и <em>experes</em> не са. И тъй като няма никакъв приоритетен ред за другите данни, е по-добре просто ефективно да има опции за обект с имена на свойства, от колкото  списък с допълнителни имена на параметри. Този подход  работи, но сега не можем да кажем, какво очаква на входа  функцията, само като погледнем в дефиницията на функцията, налага се да прочетем тялото на функцията.</p>
		<p><em>Destucturing</em> на параметри предлага алтернатива, която прави по-ясно, какви аргументи очаква функцията. <em>Destucturing</em> на параметър използва модел на <em>destucturing</em> на един обект или масив, вместо име на параметър. За да видите това в действие, погледнете тази пренаписана версия на <em>setCookie()</em> функцията от последния пример</p>
		<dl>
			<dd><pre class="highlight-overflow">
<span class="code">function</span> setCookie(name, value, { secure, path, domain, expires }) {

    <span class="comment">// код за задаване на cookie</span>
}

setCookie("type", "js", {
    secure: <span class="code">true</span>,
    expires: 60000
});
				
			</pre></dd>
		</dl>
		<p>Тази функция се държи подобно на предишния пример, но сега третия аргумент използва <em>destucturing</em> за да извади необходимите данни. Параметрите извън <em>destucturing</em> параметър са ясно очаквани и в същото време става ясно на някой който използва <em>setCookie()</em>, какви опции са достъпни, като допълнителни аргументи. И разбира се, ако третият аргумент е необходим, стойностите които съдържа са кристално ясни. <em>Destucturing</em> параметри също действат, като редовни параметри, те са определени на <em>undefined</em>, ако не са подадени.</p>
		<div class="aside">
		<p><em>Destucturing</em> параметри имат всичко от възможностите на <em>destucturing</em>, които сме научили в тази глава. Можете да използвате стойности по подразбиране, смесените модели за обекти и масиви и използване на имена на променливите, които се различават от свойствата, които четат.</p>
		</div>
		<h3>Destucturing параметри са задължителни</h3>
		<p>Една особеност на използването <em>destucturing</em> параметри по подразбиране е, че се хвърля грешка, когато те не са предвидени в извикването на функцията.  Например това извикване на <em>setCookie()</em> функцията в последния пример хвърля грешка:</p>
		<dl>
			<dd><pre class="highlight">
// Error!
setCookie("type", "js");
				
			</pre></dd>
		</dl>
		<p>Третият аргумент липсва и така го оценява на <em>undefined</em>, както се очаква. Това предизвиква грешка, защото <em>destucturing</em> параметри са само обозначение за <em>destucturing</em> декларация. Когато <em>setCookie()</em> функцията се извика, JavaScript машината всъщност прави това:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">function</span> setCookie(name, value, options) {

    <span class="code">let</span> { secure, path, domain, expires } = options;

    <span class="comment">// код за задаване на cookie</span>
}
				
			</pre></dd>
		</dl>
		<p>Тъй като <em>destucturing</em> хвърля грешка, когато изразът от дясната страна е <em>null</em> или <em>undefined</em>, същото важи и когато третия аргумент не се подава на <em>setCookie()</em> функцията.</p>
		<p>Ако искате <em>destucturing</em> параметър да се изисква, тогава това поведение не е толкова тревожно. Но ако искате <em>destucturing</em> параметър да е по желание, може да заобиколите този проблем, като предоставите стойност по подразбиране на <em>destucturing</em> параметър, като тази:</p>
		<dl>
			<dd style="overflow: scroll"><pre class="highlight">
<span class="code">function</span> setCookie(name, value, { secure, path, domain, expires } = {}) {

    // ...
}	
			</pre></dd>
		</dl>
		<p>Този пример дава нов обект, като стойност по подразбиране на третия параметър. Осигуряване на стойност по подразбиране за <em>destucturing</em> параметър означава, че всичките <em>secure, path, domain</em> и <em>expires</em> ще бъдат <em>undefined</em>, ако трети аргумент за <em>setCookie()</em> не е осигурен и няма да бъде хвърлена грешка.</p>
		<h3>Стойности по подразбиране за <em>destucturing</em> параметри</h3>
		<p>Можете  да определите <em>destucturing</em> стойности по подразбиране за <em>destucturing</em> параметри, точно както в <em>destucturing</em> присвояване. Просто добавете знака за равенство след параметъра и определете стойността по подразбиране. Например:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">function</span> setCookie(name, value,
    {
        secure = <span class="code">false</span>,
        path = "/",
        domain = "example.com",
        expires = <span class="code">new Date</span>(<span class="code">Date</span>.now() + 360000000)
    }
) {

    // ...
}
				
			</pre></dd>
		</dl>
		<p>Всяко свойство в <em>destucturing</em> параметър има стойност по подразбиране в този код, така че можем да избегнем проверката дали дадено свойство е включено за да използва правилната стойност. Има няколко недостатъка на този подход обаче. Първо декларацията на функцията става доста по-сложна, от колкото е обикновено. Второ, ако <em>destucturing</em> параметър е по избор, тогава трябва да бъде присвоен обект, като стойност по подразбиране, в противен случай извикване, като <em>setCookie("type", "js")</em> хвърля грешка. Този обект по подразбиране, трябва да има същата информация, като <em>destucturing</em> параметри (със същите настройки по подразбиране, за да осигури последователно поведение), като тази версия на <em>setCookie()</em> функцията:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">function</span> setCookie(name, value,
    {
        secure = <span class="code">false</span>,
        path = "/",
        domain = "example.com",
        expires = <span class="code">new Date</span>(<span class="code">Date</span>.now() + 360000000)
    } = {
        secure: <span class="code">false</span>,
        path: "/",
        domain: "example.com",
        expires: <span class="code">new Date</span>(<span class="code">Date</span>.now() + 360000000)
    }
) {

    // ...
}
				
			</pre></dd>
		</dl>
		<p>Сега декларацията на функцията е още по сложна. Първия обект литерал е <em>destucturing</em> параметър, а втория е стойността по подразбиране. За съжаление това води до много повторение. Може да се премахне част от повторението, чрез извличане на стойности по подразбиране в отделен обект и използване на този обект, като част от <em>destucturing</em> и стойността на параметъра по подразбиране:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">const</span> setCookieDefaults = {
        secure: <span class="code">false</span>,
        path: "/",
        domain: "example.com",
        expires: <span class="code">new Date</span>(<span class="code">Date</span>.now() + 360000000)
    };

<span class="code">function</span> setCookie(name, value,
    {
        secure = setCookieDefault.secure,
        path = setCookieDefault.path,
        domain = setCookieDefault.domain,
        expires = setCookieDefault.expires
    } = setCookieDefaults
) {

    // ...
}
				
			</pre></dd>
		</dl>
		<p>В този код, стойностите по подразбиране са поставени в обекта <em>setCookieDefaults</em>. <em>Destucturing</em> параметър реферира този обект директно, за определяне на стойност по подразбиране на всеки задължително и също като обща стойност по подразбиране на параметъра. Факт е, че се занимаваме с всички настройки по подразбиране, което е сложно и жалко, като страничен ефект от използването на <em>destucturing</em> параметри. От друга страна, ако стойността по подразбиране трябва да се промени, можем да я променим веднъж в <em>setCookieDefaults</em> обекта и данните ще се използват във всички правилни места.</p>
	</article>
	<footer>
		<h3>Обобщение</h3>
		<p><em>Destucturing</em> прави работата с обекти и масиви в JavaScript лесна. Използвайки познатия обект литерал и масив литерал синтаксис, можем да изберем от структурите данни, само информацията, която ни интересува. Обект моделите ни позволяват да извлечем данни от обекти, а масив моделите ни позволяват да извлечем данни от масиви.</p>
		<p>Стойност по подразбиране можем да зададем на <em>destucturing</em> обект и масив за всяко свойство или елемент, което не е дефинирано, и двата хвърлят грешка, когато дясната страна на присвояването се оценява на <em>null</em> или <em>undefined</em>. Можем също така да се движим дълбоко във вложените структури от данни на <em>destucturing</em> обекти и масиви, спускайки се до произволна дълбочина.</p>
		<p>Декларациите на <em>destucturing</em> използващи <em>var, let</em> или <em>const</em> за създаване на променливи винаги трябва да имат инициализатор. <em>Destucturing</em> на присвояването може да се използва вместо другото  присвояване и ни позволява преструкториране на свойствата на обекта и на вече съществуващи променливи.</p>
		<p><em>Destucturing</em> на параметри използва синтаксиса на <em>destucturing</em>, за да направи “опциите” на  обектите по прозрачни, когато се използват, като функционални параметри. Актуалните данни, които ни интересуват могат да бъдат изброени отвън заедно с другите имена на параметри. <em>Destucturing</em> параметри могат да бъдат модели за масиви, модели за обекти  или смесено, както и да използваме всички функции на <em>destucturing</em>.</p>
	</footer>
	<nav>
	<a href="./04_object_function.html" title="previous chapter">◀</a>
  <a href="./index.html" title="cover">◆</a>
  <a href="./06_simbols.html" title="next chapter">▶</a>
</nav>
</body>
</html>
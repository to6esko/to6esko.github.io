<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Класове :: Understanding ECMAScript 6</title>
	<link rel="stylesheet" href="font.css">
</head>
<body>
	<nav>
	<a href="08_iterators_and_generators.html" title="previous chapter">◀</a>
  <a href="./index.html" title="cover">◆</a>
  <a href="10_array.html" title="next chapter">▶</a>
</nav>
	
	<header id="header" class="">
		<h1><div class="head-num">Глава 9</div>Класове</h1>
		<p>Когато за първи път е бил създаден JavaScript много програмисти са били объркани от липсата на класове. Повечето обекто-ориентирани езици за програмиране, поддържат класове и класическото наследяване, като основен начин за определяне на подобни или свързани обекти. От ECMAScript 1 през целия път до ECMAScript 5, тази точка на объркване доведе до много библиотеки, за създаване на комунални услуги предназначени да направят JavaScript да изглежда, като че подкрепя класове.</p>
		<p>Макар, че има някои JavaScript разработчици, които твърдят, че езика не се нуждае от класове, фактът, че толкова много библиотеки са създадени специално за тази цел, доведе до включването на класовете в ECMAScript 6. Обаче, в ECMAScript 6 класовете не са точно същите, като класовете на другите езици. Има една уникалност във тях, която обхваща динамичния характер на JavaScript.</p>
	</header><!-- /header -->
	<article>
		<h3>Подобни на класове структури в ECMAScript 5</h3>
		<p>Преди опознаването на класовете, е полезно да се разберат основните механизми, които използват класове. В ECMAScript 5 и по рано, не е имало класове, най-близкият еквивалент е създаването на конструктор и след това присвояване на методи на неговия прототип. Този подход се нарича създаване на потребителски тип. Например:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">function</span> PersonType(name) {
    <span class="code">this</span>.name = name;
}

PersonType.prototype.sayName = <span class="code">function</span>() {
    console.log(<span class="code">this</span>.name);
};

<span class="code">let</span> person = <span class="code">new</span> PersonType("Nicholas");
person.sayName();   // outputs "Nicholas"

console.log(person <span class="code">instanceof</span> PersonType);  // true
console.log(person <span class="code">instanceof Object</span>);      // true
			</pre></dd>
		</dl>
		<p>В този код, <em>PersonType</em> е функция конструктор, която създава едно свойство наречено <em>name</em>. Метода <em>sayName()</em> е присвоен на прототипа, така същата функция се споделя от всички случаи на <em>PersonType</em>. След това, нов случай на <em>PersonType</em> е създаден с помощта на оператора <em>new</em> и полученият <em>person</em> обект се счита за инстанция на <em>PersonType</em> и на <em>Object</em> (чрез прототипното наследяване).</p>
		<p>Същият основен модел е в основата на много от имитиращите класове библиотеки в JavaScript. И това е началото на класовете в  ECMAScript 6.</p>
		<h3>Декларации на класове</h3>
		<p>Най-простата форма на клас е тази, която изглежда подобно на другите езици: декларацията на класа. Декларации на класове започват с ключовата дума <em>class</em>, последвана от името на класа. Останалата част от синтаксиса изглежда подобно на сбитите методи в обект литерали без да се изискват запетайки между тях. Например, тука е еквивалент на предишния пример:</p>
		<dl>
			<dd><pre class="highlight-overflow">
<span class="code">class</span> PersonClass {

    <span class="comment"><em>// еквивалентно на конструктора PersonType</em></span>
    constructor(name) {
        <span class="code">this</span>.name = name;
    }

    <span class="comment"><em>// еквивалентно на PersonType.prototype.sayName</em></span>
    sayName() {
        console.log(<span class="code">this</span>.name);
    }
}

<span class="code">let</span> person = <span class="code">new</span> PersonClass("Nicholas");
person.sayName();   // outputs "Nicholas"

console.log(person <span class="code">instanceof</span> PersonClass);     // true
console.log(person <span class="code">instanceof Object</span>);          // true

console.log(<span class="code">typeof</span> PersonClass);                    // "function"
console.log(<span class="code">typeof</span> PersonClass.prototype.sayName);  // "function"
			</pre></dd>
		</dl>
		<p>Декларацията на клас <em>PersonClass</em> се държи доста подобно на <em>PersonType</em> от предишния пример. Вместо да дефинира функция, като конструктор, декларацията на класа ни позволява да определим конструктора директно в класа, използвайки метод наречен <em>constructor</em>. Тъй като, методите на класа използват краткия синтаксис, няма нужда да се използва думата <em>function</em>. Всички други имена на метода нямат специално значение, така че може да добавите толкова, колкото си искате.</p>
		<dl>
			<dd><div class="info">
         <img src="./img/info.jpg" alt="info">
       </div><strong>Собствените свойства, са свойства, които се случват само в инстанцията, а не в прототипа и могат да се създават само вътре в клас конструктор или метод. В предишния пример, <em>name</em> е собствено свойство. Препоръчително е да се създадат всички възможни собствени свойства в рамките на функцията конструктор, така че да има едно единствено място, което е отговорно за всички тях.</strong></dd>
		</dl>
		<p>Интересен аспект на декларациите на класове е, че са просто <em>syntactic sugar</em> на върха на съществуващите потребителски типoве декларации. Декларацията на <em>PersonClass</em> всъщност създава функция, която има поведението на метода на конструктора, поради което <em>typeof PersonClass</em> е "function". По същия начин, метода <em>sayName()</em> завършва, като метод на <em>PersonClass.prototype</em>, подобно на <em>PersonType.prototype</em> в предишния пример. Тези сходства ни позволяват да смесваме потребителси типове и класове без да се притесняваме твърде много за какво ги използваме.</p>
		<p>Въпреки приликите има няколко важни разлики, които трябва да имаме в предвид:</p>
		<dl>
			<dd>
				<ol>
					<li>Клас декларациите, за разлика от декларациите на функции, не се издигат. Декларациите на класове действат, като <em>let</em> декларации и така съществуват в темпоралната мъртва зона, до като изпълнението не достигне декларацията.</li>
					<li>Целия код вътре в клас декларацията, минава през <em>strict mode</em> режим автоматично. Няма начин да се откаже <em>strict mode</em> режим вътре в класовете.</li>
					<li>Всички методи са <em>non-enumerable</em>. Това е значителна промяна от потребителските типове, където трябва да използвате <em>Object.defineProperty()</em> за да направите методите <em>non-enumerable</em>.</li>
					<li>Всички методи нямат вътрешен метод [[Construct]] и така хвърлят грешка ако опитате да ги извикате с <em>new</em>.</li>
					<li>Извикване на клас конструктора без <em>new</em> хвърля грешка</li>
					<li>Опита да замените името на класа в рамките на клас метода хвърля грешка.</li>
				</ol>
			</dd>
		</dl>
		<p>С всичко това в предвид, декларацията на <em>PersonClass</em> от предишния пример е директно еквивалентна на следното:</p>
		<dl>
			<dd><pre class="highlight">
<span class="comment"><em>// директен еквивалент на PersonClass</em></span>
<span class="code">let</span> PersonType2 = (<span class="code">function</span>() {

    "use strict";

    <span class="code">const</span> PersonType2 = <span class="code">function</span>(name) {

        <span class="comment"><em>// уверете се, че функцията се извиква с new</em></span>
        <span class="code">if</span> (<span class="code">typeof new</span>.target === "undefined") {
            <span class="code">throw new Error</span>("Constructor must be called with new.");
        }

        <span class="code">this</span>.name = name;
    }

    <span class="code">Object</span>.defineProperty(PersonType2.prototype, "sayName", {
        value: <span class="code">function</span>() {

            <span class="comment"><em>// уверете се, че метода не се извиква с new</em></span>
            <span class="code">if</span> (<span class="code">typeof new</span>.target !== "undefined") {
                <span class="code">throw new Error</span>("Method cannot be called with new.");
            }

            console.log(<span class="code">this</span>.name);
        },
        enumerable: <span class="code">false</span>,
        writable: <span class="code">true</span>,
        configurable: <span class="code">true</span>
    });

    <span class="code">return</span> PersonType2;
}());
			</pre></dd>
		</dl>
		<p>Първото нещо, което се забелязва в този код е, че има две декларации на <em>PersonType2, let</em> декларацията във външния обхват и <em>const</em> декларацията вътре в IIFE. Това е начина, по който методите на класа са защитени от презаписване на името на класа, докато кода от вън го прави. Функцията конструктор проверява <em>new.target</em> за да гарантира, че тя се извиква с <em>new</em>, в противен случай се хвърля грешка. На следващо място <em>sayName()</em> метода се определя на <em>nonenumerable</em> и също така проверява <em>new.target</em> за да гарантира, че той не се извиква с <em>new</em>. Последната стъпка е да върне функцията конструктор.</p>
		<p>От този пример може да видите, че въпреки, че е възможно да се направи всичко, което класовете правят бе да използват нов синтаксис, синтаксиса на класа прави цялата функционалност много по-лесно, от колкото би било иначе.</p>
		<div class="aside">
		<h3>Постоянни имена на класове</h3>
		<p>Името на класа се указва с използването на <em>const</em>, но само в рамките на самия клас. Това означава, че можете да замените името на класа извън този клас, но не и вътре в метода на класа. Например:</p>
		<pre class="highlight">
<span class="code">class</span> Foo {
   constructor() {
       Foo = "bar";    <span class="comment"><em>// хвърля грешка ако бъде изпълнено</em></span>
   }
}

<span class="comment"><em>// но това е добре</em></span>
Foo = "baz";
			</pre>
		<p>В този код, <em>Foo</em> от вътрешността на конструктора е с отделно обвързване от <em>Foo</em> извън класа. Вътрешния <em>Foo</em> се определя, ако това е <em>const</em> и така не може да бъде презаписан, което означава, че ще бъде хвърлена грешка, ако се направи опит за това. Външния <em>Foo</em> се определя, ако това е <em>let</em> декларация и така неговата стойност може да бъде заменена по всяко време.</p>
		</div>
		<h3>Клас изрази</h3>
		<p>Класове и функции са сходни по това, че те имат две форми: декларации и изрази. Декларацията на функции и класове започва с подходяща дума (функция или клас съответно) последвана от идентификатор. Функциите има израз форма, която не изисква идентификатор след <em>function</em> и по същия начин, класовете имат израз форма, която не изисква идентификатор след <em>class</em>.</p>
		<p>Тези <em>class expressions</em> са предназначени да бъдат използвани в декларации на променливи или подаване към функции, като аргументи. Ето един клас израз еквивалент на предишните примери:</p>
		<dl>
			<dd><pre class="highlight">
<span class="comment"><em>// клас израз, който не изисква идентификатор след "class"</em></span>
<span class="code">let</span> PersonClass = <span class="code">class</span> {

    <span class="comment"><em>// еквивалентно на PersonType конструктора</em></span>
    constructor(name) {
        <span class="code">this</span>.name = name;
    }

    <span class="comment"><em>// еквивалентно на PersonType.prototype.sayName</em></span>
    sayName() {
        console.log(<span class="code">this</span>.name);
    }
};

<span class="code">let</span> person = <span class="code">new</span> PersonClass("Nicholas");
person.sayName();   // outputs "Nicholas"

console.log(person <span class="code">instanceof</span> PersonClass);     // true
console.log(person <span class="code">instanceof Object</span>);          // true

console.log(<span class="code">typeof</span> PersonClass);                    // "function"
console.log(<span class="code">typeof</span> PersonClass.prototype.sayName);  // "function"
			</pre></dd>
		</dl>
		<p>Освен синтаксиса, клас изразите са абсолютно равностойни на декларациите за класове</p>
		<dl>
			<dd><div class="info">
         <img src="./img/info.jpg" alt="info">
       </div><strong>Използването на декларации за класове или клас изрази, често е въпрос на стил. За разлика от декларациите за функции и изразите на функции, клас декларациите и клас изразите не се издигат, така избора няма голямо влияние върху поведението по време на изпълнение на кода.</strong></dd>
		</dl>
		<h3>Име на клас израз</h3>
		<p>В предния раздел използвахме анонимен клас израз в примера, но можем също да дадем имена на клас изрази, точно както можем да дадем имена на изрази за функции. За да направим това, трябва да включим идентификатор след ключовата дума <em>class</em>:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">let</span> PersonClass = <span class="code">class</span> PersonClass2 {

    <span class="comment"><em>// еквивалентно на PersonType конструктора</em></span>
    constructor(name) {
        <span class="code">this</span>.name = name;
    }

    <span class="comment"><em>// еквивалентно на PersonType.prototype.sayName</em></span>
    sayName() {
        console.log(<span class="code">this</span>.name);
    }
};

console.log(<span class="code">typeof</span> PersonClass);        // "function"
console.log(<span class="code">typeof</span> PersonClass2);       // "undefined"
			</pre></dd>
		</dl>
		<p>В този пример, на израза на класа се дава име: <em>PersonClass2</em>. Идентификатора <em>PersonClass2</em> съществува само в рамката на дефиницията на класа, така че може да се използва вътре от методи. Извън този клас, няма <em>PersonClass2</em> обвързвания, така че <em>typeof PersonClass2</em> е "undefined". За да разберете, защо се случва това, тука е еквивалентната декларация без да се използват класове:</p>
		<dl>
			<dd><pre class="highlight">
<span class="comment"><em>// директен еквивалент на PersonClass име на клас израз</em></span>
<span class="code">let</span> PersonClass = (<span class="code">function</span>() {

    "use strict";

    <span class="code">const</span> PersonClass2 = <span class="code">function</span>(name) {

        <span class="comment"><em>// уверете се, че функцията се извиква с new</em></span>
        <span class="code">if</span> (<span class="code">typeof new</span>.target === "undefined") {
            <span class="code">throw new Error</span>("Constructor must be called with new.");
        }

        <span class="code">this</span>.name = name;
    }

    <span class="code">Object</span>.defineProperty(PersonClass2.prototype, "sayName", {
        value: <span class="code">function</span>() {
            console.log(<span class="code">this</span>.name);
        },
        enumerable: <span class="code">false</span>,
        writable: <span class="code">true</span>,
        configurable: <span class="code">true</span>
    });

    <span class="code">return</span> PersonClass2;
}());
			</pre></dd>
		</dl>
		<p>Създаване на клас израз с име леко променя това, което се случва в JavaScript машината. За клас декларация на външното обвързване  (дефинирано с <em>let</em>) има същото име, като вътрешното обвързване (дефинирано с <em>const</em>). Именуваните клас изрази използват името си, като <em>const</em> дефиниция, така че в този случай <em>PersonClass2</em> е определен за употреба само в рамките на класа.</p>
		<p>Докато поведението на именуваните клас изрази е различно от това на именуваните изрази на функции, все още има много прилики между двете. И двете могат да се използват, като стойности, което отваря много възможности.</p>
		<h3>Класовете, като първокласни поданици</h3>
		<p>В програмирането, се казва за нещо, че е <em>first-class citizen</em>, когато то може да се използва, като стойност, което означава, че може да бъде прехвърлено във функция, върнато от функция и присвоено от променлива. В JavaScript функциите са първокласни поданици, понякога наричани само първокласни функции и това е само част от това, което прави JavaScript уникален език. ECMAScript 6 продължава тази традиция, като прави класовете първокласни поданици. Това позволява класовете да бъдат използвани по много различни начини. Например, те могат да бъдат вкарани във функции, като аргументи:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">function</span> createObject(classDef) {
    <span class="code">return new</span> classDef();
}

<span class="code">let</span> obj = createObject(<span class="code">class</span> {

    sayHi() {
        console.log("Hi!");
    }
});

obj.sayHi();        // "Hi!"
			</pre></dd>
		</dl>
		<p>В този пример, анонимен клас израз се подава в <em>createObject()</em>. Тази инстанция е създадена с помощта на <em>new</em> и този обект се връща.</p>
		<p>Друго интересно приложение на изрази на класове е да създадат <em>singletons</em>, чрез незабавно извикване на конструктора на класа. За да направим това, трябва да използваме <em>new</em> с израза на класа и да включим скоби на края. Например:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">let</span> person = <span class="code">new class</span> PersonClass {

    constructor(name) {
        <span class="code">this</span>.name = name;
    }

    sayName() {
        console.log(<span class="code">this</span>.name);
    }

}("Nicholas");

person.sayName();       // "Nicholas"
			</pre></dd>
		</dl>
		<p>Тука, анонимния клас израз се създава и след това се изпълнява незабавно. Този модел позволява използването на синтаксиса на класа за създаване на <em>singletons</em> без да излизаме от препратката на класа за проверка (не забравяйте, че <em>PersonClass</em> създава обвързване вътре в класа, не отвън). Скобите в края са индикатор, че извикването на функцията, също така позволява подаване на аргумент.</p>
		<p>Примерите в тази глава са фокусирани, до колкото може, върху класове с методи. Но можете да създадете <em>accessor</em> свойства на класове с един синтаксис подобен на обект литерали.</p>
		<h3>Accessor свойства</h3>
		<p>Докато собствените свойства трябва да бъдат създадени в клас конструктора, класовете дават възможност за определяне на <em>accessor</em> свойства на прототипа. За създаване на <em>getter</em>, трябва да изпозваме ключовата дума <em>get</em> последвана от интервал, последван от идентификатор. За създаване на <em>setter</em>, трябва да използваме ключовата дума <em>set</em>. Например:</p>
		<dl>
			<dd><pre class="highlight-overflow">
<span class="code">class</span> CustomHTMLElement {

    constructor(element) {
        <span class="code">this</span>.element = element;
    }

    get html() {
        <span class="code">return this</span>.element.innerHTML;
    }

    set html(value) {
        <span class="code">this</span>.element.innerHTML = value;
    }
}

<span class="code">var</span> descriptor = <span class="code">Object</span>.getOwnPropertyDescriptor(CustomHTMLElement.prototype, "html");
console.log("get" <span class="code">in</span> descriptor);   // true
console.log("set" <span class="code">in</span> descriptor);   // true
console.log(descriptor.enumerable); // false
			</pre></dd>
		</dl>
		<p>В този пример, класа <em>CustomHTMLElement</em> прави обвивка около съществуващ DOM елемент. Той има <em>getter</em> и <em>setter</em> за <em>html</em>, като делегати на <em>innerHTML</em> метода на самия елемент. Това <em>accessor</em> свойство се създава, като <em>non-enumerable</em>, точно както всеки друг метод ще бъде създаден в <em>CustomHTMLElement.prototype</em>. Еквивалент на <em>non-class</em> ще бъде представен като:</p>
		<dl>
			<dd><pre class="highlight">
<span class="comment"><em>// директен еквивалент на предишния пример</em></span>
<span class="code">let</span> CustomHTMLElement = (<span class="code">function</span>() {

    "use strict";

    <span class="code">const</span> CustomHTMLElement = <span class="code">function</span>(element) {

        <span class="comment"><em>// уверете се, че функцията се извиква с new</em></span>
        <span class="code">if</span> (<span class="code">typeof new</span>.target === "undefined") {
            <span class="code">throw new Error</span>("Constructor must be called with new.");
        }

        <span class="code">this</span>.element = element;
    }

    <span class="code">Object</span>.defineProperty(CustomHTMLElement.prototype, "html", {
        enumerable: <span class="code">false</span>,
        configurable: <span class="code">true</span>,
        get: <span class="code">function</span>() {
            <span class="code">return this</span>.element.innerHTML;
        },
        set: function(value) {
            <span class="code">this</span>.element.innerHTML = value;
        }
    });

    <span class="code">return</span> CustomHTMLElement;
}());
			</pre></dd>
		</dl>
		<p>Както при предишните примери, това показва колко много код се спестява чрез използване на класове вместо еквивалент на <em>non-class</em>. Дефинирането на само <em>accessor</em> свойство е почти с размера на еквивалента за клас декларация.</p>
		<p>Приликите между обект литерали и класове не са доста. Клас методи и <em>accessor</em> свойства могат да използват изчисляване на имена, използвайки същия синтаксис, като обект литералите.</p>
		<h3>Изчисляване на имена</h3>
		<p>Клас методите и <em>accessor</em> свойствата могат да имат изчислени имена. Вместо използването на идентификатор, можем да използваме квадратни скоби (също, както изчислените имена на обект литерали). Например:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">let</span> methodName = "sayName";

<span class="code">class</span> PersonClass {

    constructor(name) {
        <span class="code">this</span>.name = name;
    }

    [methodName]() {
        console.log(<span class="code">this</span>.name);
    }
};

<span class="code">let</span> me = <span class="code">new</span> PersonClass("Nicholas");
me.sayName();           // "Nicholas"
			</pre></dd>
		</dl>
		<p>Тази версия на <em>PersonClass</em> използва променлива да зададе името на метода. Променливата <em>methodName</em> съдържа <em>string</em> "sayName", която след това се използва за деклариране на метода. Метода <em>sayName()</em> по късно се достъпва директно. <em>Accessor</em> свойствата могат да използват изчислените имена по същия начин:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">let</span> propertyName = "html";

<span class="code">class</span> CustomHTMLElement {

    constructor(element) {
        <span class="code">this</span>.element = element;
    }

    get [propertyName]() {
        <span class="code">return this</span>.element.innerHTML;
    }

    set [propertyName](value) {
        <span class="code">this</span>.element.innerHTML = value;
    }
}
			</pre></dd>
		</dl>
		<p>Тука <em>getter</em> и <em>setter</em> за <em>html</em> са определени с помощта на <em>propertyName</em>. Mожем да получим достъп до свойството с помощта на <em>.html</em>, това е само дефиниция, че достъпено.</p>
		<p>Видяхме, че има много прилики между класове и обект литерали за методи, <em>accessor</em> свойства и изчисляване на имена. Има още една прилика за покриване: генератори.</p>
		<h3>Генератор методи</h3>
		<p>Когато въведохме генераторите в <a href="08_iterators_and_generators.html">Глава 8</a>, ние научихме как да дефинираме генератор на даден обект литерал, като поставим символа звезда (*) до името на метода. Същия синтаксис работи и за класове, както и че позволява всеки един метод да бъде генератор. Ето един пример:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">class</span> MyClass {

    *createIterator() {
        <span class="code">yield</span> 1;
        <span class="code">yield</span> 2;
        <span class="code">yield</span> 3;
    }

}

<span class="code">let</span> instance = <span class="code">new</span> MyClass();
<span class="code">let</span> iterator = instance.createIterator();
			</pre></dd>
		</dl>
		<p>Този код създава един клас наречен <em>MyClass</em> който има метод генератор наречен <em>createIterator()</em>. Метода има итератора, чиито стойности са кодирани в генератора. Въпреки, че това е една полезна възможност, много по-полезно е да се определят итернатори по подразбиране за нашия клас.</p>
		<p>Можем да определим итератор по подразбиране за един клас с помощта на <em>Symbol.iterator</em> за определяне на метод генератор, като например:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">class</span> Collection {

    constructor() {
        <span class="code">this</span>.items = [];
    }

    *[Symbol.iterator]() {
        <span class="code">yield *this</span>.items.values();
    }
}

<span class="code">var</span> collection = <span class="code">new</span> Collection();
collection.items.push(1);
collection.items.push(2);
collection.items.push(3);

<span class="code">for</span>(<span class="code">let</span> x of collection) {
    console.log(x);
}

// Output:
// 1
// 2
// 3
			</pre></dd>
		</dl>
		<p>Този пример използва изчислено име за метода на генератора, който е възложил на <em>values()</em> итернатор за <em>this.items</em>. По този начин всички случаи на <em>Collection</em> може да се използват директно в <em>for-of</em> цикъл или оператора <em>spread</em>. Това е добра идея да определим итератор по подразбиране за всеки клас, който управлява колекция от стойности.</p>
		<p>Добавянето на методи и <em>accessor</em> свойства на прототипа на класа е полезно, когато искате да се появяват в обектни инстанции. Ако от друга страна искате методи и <em>accessor</em> свойства на самия клас, тогава ще трябва да използвате статични членове.</p>
		<h3>Статични членове</h3>
		<p>Друг често срещан модел в JavaScript е добавяне на допълнителни методи директно върху конструктора за симулиране на статични членове. Например:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">function</span> PersonType(name) {
    <span class="code">this</span>.name = name;
}

 <span class="comment"><em>// статичен метод</em></span>
PersonType.create = <span class="code">function</span>(name) {
    <span class="code">return new</span> PersonType(name);
};

 <span class="comment"><em>// инстанция на метод</em></span>
PersonType.prototype.sayName = <span class="code">function</span>() {
    console.log(<span class="code">this</span>.name);
};

<span class="code">var</span> person = PersonType.create("Nicholas");
			</pre></dd>
		</dl>
		<p>Този код създава метод-фабрика наречен <em>PersonType.create()</em>. В други програмни езици, това се счита за статичен метод, тъй като не е зависим от нито една инстанция на <em>PersonType</em> за своите данни.</p>
		<p>Класовете опростяват създаването на статични членове с помощта на специална статична нотация преди името на метод или преди името на <em>accessor</em> свойство. Ето еквивалента на последния пример:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">class</span> PersonClass {

    <span class="comment"><em>// еквивалентно на PersonType конструктора</em></span>
    constructor(name) {
        <span class="code">this</span>.name = name;
    }

    <span class="comment"><em>// еквивалентно на PersonType.prototype.sayName</em></span>
    sayName() {
        console.log(<span class="code">this</span>.name);
    }

    <span class="comment"><em>// еквивалентно на PersonType.create</em></span>
    <span class="code">static</span> create(name) {
        <span class="code">return new</span> PersonClass(name);
    }
}

<span class="code">let</span> person = PersonClass.create("Nicholas");
			</pre></dd>
		</dl>
		<p>Дефиницията на <em>PersonClass</em> има един единствен статичен метод наречен <em>create()</em>. Синтаксиса на метода е същия, като за <em>sayName()</em> с изключение на ключовата дума <em>static</em>. Можем да използваме ключовата дума <em>static</em> върху всеки метод или <em>accessor</em> свойство в рамките на един клас. Единственото ограничение е, че не може да използвате <em>static</em> в дефиницията на конструктор.</p>
		<dl>
			<dd><div class="worning">
         <img src="./img/worning.jpg" alt="worning">
       </div><strong>Статичните членове не са достъпни от инстанциите. Достъп до статичните членове винаги трябва да се получи от класа директно.</strong></dd>
		</dl>
		<h3>Наследяване с производни класовете</h3>
		<p>Друг проблем с потребителските типове в ECMAScript 5 и по-рано, беше обширния процес необходим за изпълнение на наследяването. За правилно наследяване, трябват няколко стъпки. Например:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">function</span> Rectangle(length, width) {
    <span class="code">this</span>.length = length;
    <span class="code">this</span>.width = width;
}

Rectangle.prototype.getArea = <span class="code">function</span>() {
    <span class="code">return this</span>.length * <span class="code">this</span>.width;
};

<span class="code">function</span> Square(length) {
    Rectangle.call(<span class="code">this</span>, length, length);
}

Square.prototype = <span class="code">Object</span>.create(Rectangle.prototype, {
    constructor: {
        value:Square,
        enumerable: <span class="code">true</span>,
        writable: <span class="code">true</span>,
        configurable: <span class="code">true</span>
    }
});

<span class="code">var</span> square = <span class="code">new</span> Square(3);

console.log(square.getArea());              // 9
console.log(square <span class="code">instanceof</span> Square);      // true
console.log(square <span class="code">instanceof</span> Rectangle);   // true
			</pre></dd>
		</dl>
		<p>Тука, <em>Square</em> наследява от <em>Rectangle</em> и за да го направи , трябва да презапише <em>Square.prototype</em> с нов обект създаден от <em>Rectangle.prototype</em>, както и да извика <em>Rectangle.call()</em>. Тези стъпки често се бъркат от начинаещите в изучаването на езика, но са  и източник на грешки за опитни програмисти.</p>
		<p>Класовете правят наследяването по-лесно с помощта на познатата ключова дума <em>extends</em> за уточняване на функциите, от която трябва да се наследи класа. Прототипите се настройват автоматично и можем да получим достъп до базовия клас конструктор използвайки <em>super()</em>. Ето еквивалента на предишния пример:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">class</span> Rectangle {
    constructor(length, width) {
        <span class="code">this</span>.length = length;
        <span class="code">this</span>.width = width;
    }

    getArea() {
        <span class="code">return this</span>.length * <span class="code">this</span>.width;
    }
}

<span class="code">class</span> Square <span class="code">extends</span> Rectangle {
    constructor(length) {

        <span class="comment"><em>// също, като Rectangle.call(this, length, length)</em></span>
        <span class="code">super</span>(length, length);
    }
}

<span class="code">var</span> square = <span class="code">new</span> Square(3);

console.log(square.getArea());              // 9
console.log(square <span class="code">instanceof</span> Square);      // true
console.log(square <span class="code">instanceof</span> Rectangle);   // true
			</pre></dd>
		</dl>
		<p>В този пример, класа <em>Square</em> наследява от <em>Rectangle</em> използвайки ключовата дума <em>extends. Square</em> конструктора използва <em>super()</em> за да извика <em>Rectangle</em> конструктора с посочените аргументи. Имайте в предвид, че за разлика от версията на кода в ECMAScript 5 идентификатора <em>Rectangle</em> се използва само в рамките на декларацията на класа (след <em>extends</em>).</p>
		<p>Използването на <em>super()</em> е изискване на производните класове, ако посочите конструктор (ако не го направите, ще възникне грешка). Ако решите да не използвате конструктор, тогава се извиква автоматично <em>super()</em>, с всички аргументи при създаването на нова инстанция на класа. Например, следващите два класа са идентични:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">class</span> Square <span class="code">extends</span> Rectangle {
    <span class="comment"><em>// няма конструктор</em></span>
}

<span class="comment"><em>// е еквивалентно на</em></span>

<span class="code">class</span> Square <span class="code">extends</span> Rectangle {
    constructor(...args) {
        <span class="code">super</span>(...args);
    }
}
			</pre></dd>
		</dl>
		<p>Втория клас в този пример показва еквивалент на конструктор по подразбиране за всички производни класове. Всички аргументи се подават към конструктора на базовия клас. В този случай функционалността не е съвсем правилна, защото на <em>Square</em> конструктора му трябва само един аргумент и за това най-добре е ръчно определяне на конструктора.</p>
		<dl>
			<dd><div class="worning">
         <img src="./img/worning.jpg" alt="worning">
       </div><strong>Има няколко неща, които трябва да имате в предвид, когато използвате <em>super()</em>:
				<ol>
					<li>Може да използвате само <em>super()</em> в производен клас. Ако се опитате да го използвате в не производен клас (клас който не използва <em>extends</em>) или функция, ще бъде хвърлена грешка.</li>
					<li>Трябва да извикате <em>super()</em> преди <em>this</em> в конструктора. Тъй като <em>super()</em> е отговорен за инициализацията на <em>his</em>, опита за достъп до <em>this</em> преди извикването на <em>super()</em> ще доведе до грешка.</li>
					<li>Единственият начин да се избегне извикване на  <em>super()</em> е да се върнем на обект от клас конструктора.</li>
				</ol>
			</strong></dd>
		</dl>
		<h3Сянка на клас методи></h3>
		<p>Методите на производните класове са винаги сянка на методите със същото име на базовия клас. Например можем да добавим <em>getArea()</em> на <em>Square</em> с цел да предефинират функционалността:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">class</span> Square <span class="code">extends</span> Rectangle {
    constructor(length) {
        <span class="code">super</span>(length, length);
    }

    <span class="comment"><em>// презаписване и сянката на Rectangle.prototype.getArea()</em></span>
    getArea() {
        <span class="code">return this</span>.length * <span class="code">this</span>.length;
    }
}
			</pre></dd>
		</dl>
		<p>В този код, <em>getArea()</em> е определена, като част от <em>Square</em> и следователно <em>Rectangle.prototype.getArea()</em> вече няма да се извиква с всички случаи на <em>Square</em>. Разбира се винаги може да решите да извикате от базовия клас версията на метода с помощта на <em>super.getArea()</em>, също като:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">class</span> Square <span class="code">extends</span> Rectangle {
    constructor(length) {
        <span class="code">super</span>(length, length);
    }

    <span class="comment"><em>// презаписване, сянка и извикване на Rectangle.prototype.getArea()</em></span>
    getArea() {
        <span class="code">return super</span>.getArea();
    }
}
			</pre></dd>
		</dl>
		<p>Използването на <em>super</em> по този начин, е обсъдено в <a href="./04_object_function.html">Глава 4</a>: стойността <em>this</em> е автоматично настроена правилно, така че да можем да направим един прост метод на извикване.</p>
		<h3>Наследяване на статични членове</h3>
		<p>Ако базовият клас има статични членове, тогава тези статични членове също са на разположение на производния клас. Това е как наследяването работи на други езици, но е нова концепция за JavaScript. Ето един пример:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">class</span> Rectangle {
    constructor(length, width) {
        <span class="code">this</span>.length = length;
        <span class="code">this</span>.width = width;
    }

    getArea() {
        <span class="code">return this</span>.length * <span class="code">this</span>.width;
    }

    <span class="code">static</span> create(length, width) {
        <span class="code">return new</span> Rectangle(length, width);
    }
}

<span class="code">class</span> Square <span class="code">extends</span> Rectangle {
    constructor(length) {

        <span class="comment"><em>// също, като Rectangle.call(this, length, length</em></span>
        <span class="code">super</span>(length, length);
    }
}

<span class="code">var</span> rect = Square.create(3, 4);

console.log(rect <span class="code">instanceof</span> Rectangle);     // true
console.log(rect.getArea());                // 12
console.log(rect <span class="code">instanceof</span> Square);        // false
			</pre></dd>
		</dl>
		<p>В този код, новия <em>static create()</em> метод е добавен в <em>Rectangle</em>. Чрез наследяване, този метод е достъпен, като <em>Square.create()</em> и се държи по същия начин, както <em>Rectangle.create()</em>.</p>
		<h3>Производни класове от изрази</h3>
		<p>Може би най-мощният аспект на производните класове в ECMAScript 6 е възможността да се извлече клас от израз. Можете да използвате <em>extends</em> с всеки израз, толкова дълго, колкото израза реши, че е функция а [[Construct]] и прототип. Например:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">function</span> Rectangle(length, width) {
    <span class="code">this</span>.length = length;
    <span class="code">this</span>.width = width;
}

Rectangle.prototype.getArea = function() {
    <span class="code">return this</span>.length * <span class="code">this</span>.width;
};

<span class="code">class</span> Square <span class="code">extends</span> Rectangle {
    constructor(length) {
        <span class="code">super</span>(length, length);
    }
}

<span class="code">var</span> x = <span class="code">new</span> Square(3);
console.log(x.getArea());               // 9
console.log(x <span class="code">instanceof</span> Rectangle);    // true
			</pre></dd>
		</dl>
		<p>Този пример определя <em>Rectangle</em> в ECMAScript 5 стил на конструктора, до като <em>Square</em> е клас. Тъй като <em>Rectangle</em> има [[Construct]] и прототип, класа може да наследява директно от него.</p>
		<p>Приемане на всякакъв тип на израз след <em>extends</em> позволява някои мощни възможности, като например, динамично определяне, какво се наследява. Например:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">function</span> Rectangle(length, width) {
    <span class="code">this</span>.length = length;
    <span class="code">this</span>.width = width;
}

Rectangle.prototype.getArea = <span class="code">function</span>() {
    <span class="code">return this</span>.length * <span class="code">this</span>.width;
};

<span class="code">function</span> getBase() {
    <span class="code">return</span> Rectangle;
}

<span class="code">class</span> Square <span class="code">extends</span> getBase() {
    constructor(length) {
        <span class="code">super</span>(length, length);
    }
}

<span class="code">var</span> x = <span class="code">new</span> Square(3);
console.log(x.getArea());               // 9
console.log(x <span class="code">instanceof</span> Rectangle);    // true
			</pre></dd>
		</dl>
		<p>Тука, функцията <em>getBase()</em> се извиква директно, като част от декларацията на класа. Тя връща <em>Rectangle</em>, което означава, че този пример е функционално еквивалентен на предишния. И тъй като можем да определим базата динамично, означава, че е възможно да се създадат различни подходи за наследяване. Например можем ефективно да създадем <em>mixins</em>:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">let</span> SerializableMixin = {
    serialize() {
        <span class="code">return</span> JSON.stringify(<span class="code">this</span>);
    }
};

<span class="code">let</span> AreaMixin = {
    getArea() {
        <span class="code">return this</span>.length * <span class="code">this</span>.width;
    }
};

<span class="code">function</span> mixin(...mixins) {
    <span class="code">var</span> base = <span class="code">function</span>() {};
    <span class="code">Object</span>.assign(base.prototype, ...mixins);
    <span class="code">return</span> base;
}

<span class="code">class</span> Square <span class="code">extends</span> mixin(AreaMixin, SerializableMixin) {
    constructor(length) {
        <span class="code">super</span>();
        <span class="code">this</span>.length = length;
        <span class="code">this</span>.width = length;
    }
}

<span class="code">var</span> x = <span class="code">new</span> Square(3);
console.log(x.getArea());        // 9
console.log(x.serialize());      // "{"length":3,"width":3}"
			</pre></dd>
		</dl>
		<p>В този пример, <em>mixins</em> се използват вместо класическо наследяване. Функцията <em>mixin()</em> взема произволен брой аргументи, които представляват <em>mixin</em> обекти. Той създава функция наречена <em>base</em> и задава свойства на всеки <em>mixin</em> обект на прототипа. Функцията след това връща толкова <em>Square</em>, колкото използва <em>extends</em>. Имайте в предвид, че тъй като <em>extends</em> все още се използва, вие трябва да извикате <em>super()</em> в конструктора.</p>
		<p>В този случай, <em>Square</em> има както <em>getArea()</em> от <em>AreaMixin</em> така и <em>serialize</em> от <em>SerializableMixin</em>. Това се постига, чрез прототипното наследяване, тъй като функцията <em>mixin()</em> динамично наследява прототипа на новата функция с всички собствени свойства на всеки <em>mixin</em>.</p>
		<dl>
			<dd><div class="worning">
         <img src="./img/worning.jpg" alt="worning">
       </div><strong>Въпреки, че всеки израз може да се използва след <em>extends</em>, не всички изрази дават валиден клас. По-конкретно следните типове изрази предизвикват грешка:
				<ul>
					<li>null</li>
					<li>генератор функции (<a href="08_iterators_and_generators.html">Глава 8</a>)</li>
				</ul>
				В тези случаи, всеки опит да се създаде нова инстанция на класа ще доведе до грешка, защото няма [[Construct]] за извикване.
			</strong></dd>
		</dl>
		<h3>Наследяване от вградени модули</h3>
		<p>Почти толкова дълго, от когато има масиви в JavaScript, програмистите са искали да наследяват масиви, за да създават свои собствени специални видове масиви. Обаче, в ECMAScript 5 и по-рано, това не е било възможно. Опитите за класическо наследяване не са довели до функциониращ код. Например:</p>
		<dl>
			<dd><pre class="highlight">
<span class="comment"><em>// вградено поведение в масиви</em></span>
<span class="code">var</span> colors = [];
colors[0] = "red";
console.log(colors.length);         // 1

colors.length = 0;
console.log(colors[0]);             // undefined

<span class="comment"><em>// опити за наследяване на масив в ES5</em></span>

<span class="code">function</span> MyArray() {
    <span class="code">Array</span>.apply(<span class="code">this</span>, arguments);
}

MyArray.prototype = <span class="code">Object</span>.create(<span class="code">Array</span>.prototype, {
    constructor: {
        value: MyArray,
        writable: <span class="code">true</span>,
        configurable: <span class="code">true</span>,
        enumerable: <span class="code">true</span>
    }
});

<span class="code">var</span> colors = <span class="code">new</span> MyArray();
colors[0] = "red";
console.log(colors.length);         // 0

colors.length = 0;
console.log(colors[0]);             // "red"
			</pre></dd>
		</dl>
		<p>Както може да видите, използването на класическата форма на наследяване в JavaScript води до неочаквано поведение. Дължината <em>length</em> и цифровото свойство не реагират по същия начин, както на вградения масив, защото тази функционалност не е покрита от <em>Array.apply()</em> или чрез присвояване на масив.</p>
		<p>Една от целите на  ECMAScript 6 класовете е да се позволи наследяване на всички вградени модули. За да се постигне това модела на наследяването на класове е малко по-различен от  модела на класическото наследяване в ECMAScript 5 и по-рано:</p>
		<dl>
			<dd>
				<ul>
					<li>В класическото наследяване на ECMAScript 5, стойността <em>this</em> се създава първо от производните типове (например, <em>MyArray</em>) и след това се извиква базовия тип конструктор (<em>Array.apply()</em>). Това означава, че <em>this</em> започва, като инстанция на <em>MyArray</em> и след това се украсява с допълнителни свойства от <em>Array</em>.</li>
					<li>В базираното на класове наследяване на ECMAScript 6 стойността на <em>this</em> се създава първо от базовия (<em>Array</em>) и след това се модифицира от конструктора на производния клас (<em>MyArray</em>). Резултата е, че <em>this</em> започва с всички вградени функции на основата и правилно приема всички функции свръзани с него.</li>
				</ul>
			</dd>
		</dl>
		<p>Следния базиран на клас специален масив, работи както се очаква</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">class</span> MyArray <span class="code">extends Array</span> {
    <span class="comment"><em>// празно</em></span>
}

<span class="code">var</span> colors = <span class="code">new</span> MyArray();
colors[0] = "red";
console.log(colors.length);         // 1

colors.length = 0;
console.log(colors[0]);             // undefined
			</pre></dd>
		</dl>
		<p>В този пример, <em>MyArray</em> наследява директно от <em>Array</em> и следователно работи по точно същия начин. Взаимодействието с цифровите свойства актуализира <em>length</em> свойството и манипулирането на <em>length</em> свойството актуализира цифровите свойства. Това означава, че не само може правилно да наследява от масив, а и да създаде свои собствени производни класове от масиви, може също така да наследи от други <em>builtins</em> така добре. ECMAScript 6 и производните класове ефективно отстраняват последния специален случай на наследяване от <em>builtins</em>.</p>
		<h3>Symbol.species свойства</h3>
		<p>Интересен аспект на наследяване от <em>builtins</em> е, че всеки метод, който връща инстанция на <em>builtin</em> автоматично ще върне инстанция на производен клас. Така, че ако имаме производен клас <em>MyArray</em>, който наследява от <em>Array</em>, метод като <em>slice()</em> ще се върне, като инстанция на <em>MyArray</em>. Например:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">class</span> MyArray <span class="code">extends Array</span> {
    <span class="comment"><em>// празно</em></span>
}

<span class="code">let</span> items = <span class="code">new</span> MyArray(1, 2, 3, 4),
    subitems = items.slice(1, 3);

console.log(items <span class="code">instanceof</span> MyArray);      // true
console.log(subitems <span class="code">instanceof</span> MyArray);   // true
			</pre></dd>
		</dl>
		<p>В този код, <em>slice()</em> метода се връща, като инстанця на <em>MyArray</em>. Метода <em>slice()</em> е наследен от <em>Array</em> и се връща, като инстаниция на <em>Array</em> нормално. Зад кулисите на сцената, това е <em>Symbol.species</em>, която прави тази промяна.</p>
		<p><em>Well-known</em> <em>Symbol.species</em> се използва за определяне на статично свойство за достъп, което връща функция. Тази функция е конструктор, която за да се използва, като инстанция на клас, трябва да бъде създадена вътре в инстанцията на метода (вместо използване на конструктора). Има няколко вградени типове, които имат <em>Symbol.species</em> определения:</p>
		<dl>
			<dd>
				<ul>
					<li>Array</li>
					<li>ArrayBuffer (обсъдени в  <a href="10_array.html">Chapter 10</a>)</li>
					<li>Map</li>
					<li>Promise</li>
					<li>RegExp</li>
					<li>Set</li>
					<li>Typed Arrays (обсъдени в  <a href="10_array.html">Chapter 10</a>)</li>
				</ul>
			</dd>
		</dl>
		<p>Всеки един от тези типове имат по подразбиране <em>Symbol.species</em> свойства, които връщат <em>this</em>, което означава, че винаги ще връщат функция конструктор. Ако ви се налага да направите същото на потребителски клас, кодът ще изглежда така:</p>
		<dl>
			<dd><pre class="highlight">
<span class="comment"><em>// няколко вградени типове използват видове подобни на this</em></span>
<span class="code">class</span> MyClass {
    <span class="code">static</span> get [Symbol.species]() {
        <span class="code">return this</span>;
    }

    constructor(value) {
        <span class="code">this</span>.value = value;
    }

    clone() {
        <span class="code">return new this</span>.constructor[Symbol.species](<span class="code">this</span>.value);
    }
}
			</pre></dd>
		</dl>
		<p>В този пример, <em>well-known Symbol.species</em> се използва за да зададем статично свойство за достъп до <em>MyClass</em>. Имайте в предвид, че има само едни <em>getter</em> без <em>setter</em>, защото не е възможно да се промени вида на един клас. Всяко извикване на <em>this.constructor[Symbol.species]</em> връща <em>MyClass</em>. Метода <em>clone()</em> използва това определение, за да върне нова инстанция, вместо директно използване на <em>MyClass</em>, което позволява на производните класове да заменят тази стойност. Например:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">class</span> MyClass {
    <span class="code">static</span> get [Symbol.species]() {
        <span class="code">return this</span>;
    }

    constructor(value) {
        <span class="code">this</span>.value = value;
    }

    clone() {
        <span class="code">return new this</span>.constructor[Symbol.species](<span class="code">this</span>.value);
    }
}

<span class="code">class</span> MyDerivedClass1 <span class="code">extends</span> MyClass {
    <span class="comment"><em>// празно</em></span>
}

<span class="code">class</span> MyDerivedClass2 <span class="code">extends</span> MyClass {
    <span class="code">static</span> get [Symbol.species]() {
        <span class="code">return</span> MyClass;
    }
}

<span class="code">let</span> instance1 = <span class="code">new</span> MyDerivedClass1("foo"),
    clone1 = instance1.clone(),
    instance2 = <span class="code">new</span> MyDerivedClass2("bar"),
    clone2 = instance2.clone();

console.log(clone1 <span class="code">instanceof</span> MyClass);             // true
console.log(clone1 <span class="code">instanceof</span> MyDerivedClass1);     // true
console.log(clone2 <span class="code">instanceof</span> MyClass);             // true
console.log(clone2 <span class="code">instanceof</span> MyDerivedClass2);     // false
			</pre></dd>
		</dl>
		<p>Тука, <em>DerivedClass1</em> наследява от <em>MyClass</em> и не променя <em>Symbol.species</em> свойството. Когато се извика <em>clone()</em>, той се връща на инстанцията на <em>MyDerivedClass1</em>, защото <em>this.constructor[Symbol.species]</em> връща <em>MyDerivedClass1</em>. Класа <em>DerivedClass2</em> наследява от <em>MyClass</em> и заменя <em>Symbol.species</em> за да върне <em>MyClass</em>. Когато се извика <em>clone()</em> върху инстанцията на <em>DerivedClass2</em>, върнатата стойност е инстанция на <em>MyClass</em>. Използвайки <em>Symbol.species</em>, за всеки производен клас, може да се определи, какъв вид стойност трябва да върне, когато метода връща инстанция. И тъй като <em>Array</em> използва <em>Symbol.species</em>, можем да направим тази промяна в производен клас масив, като:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">class</span> MyArray <span class="code">extends Array</span> {
    <span class="code">static</span> get [Symbol.species]() {
        <span class="code">return Array</span>;
    }
}

<span class="code">let</span> items = <span class="code">new</span> MyArray(1, 2, 3, 4),
    subitems = items.slice(1, 3);

console.log(items <span class="code">instanceof</span> MyArray);      // true
console.log(subitems <span class="code">instanceof</span> Array);     // true
console.log(subitems <span class="code">instanceof</span> MyArray);   // false
			</pre></dd>
		</dl>
		<p>Този код заменя <em>Symbol.species</em> на <em>MyArray</em>, който наследява <em>Array</em> и всички наследени методи, които връщат масиви ще използват инстанция на Array вместо <em>MyArray</em>.</p>
		<p>Като, цяло трябва да използваме <em>Symbol.species</em> свойството, когато искаме да използваме <em>this.constructor</em> в клас метод. По този начин, позволява на получените класове да заменят типа на връщане лесно. Освен това, ако създавате производни класове от клас, който има определен <em>Symbol.species</em>, не забравяйте да използвате тази стойност вместо тази на конструктора.</p>
		<h3 id="newTarget">The new.target</h3>
		<p>В <a href="./03_function.html">Глава 3</a>, учихме за <em>new.target</em> и как неговата стойност се променя в зависимост от това как се извиква една функция. Можем също да използваме <em>new.target</em> в клас конструктор, за да определим как се позовава един клас. В прост случай, <em>new.target</em> е равен на функцията конструктор за класа, както в този пример:</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">class</span> Rectangle {
    constructor(length, width) {
        console.log(<span class="code">new</span>.target === Rectangle);
        <span class="code">this</span>.length = length;
        <span class="code">this</span>.width = width;
    }
}

// new.target is Rectangle
<span class="code">var</span> obj = <span class="code">new</span> Rectangle(3, 4);      // outputs true
			</pre></dd>
		</dl>
		<p>В този код, можем да видим, че <em>new.target</em> е еквивалентен на <em>Rectangle</em>, когато се извика <em>Rectangle(3, 4)</em>. Тъй като, клас конструктора не може да се извика без <em>new, new.target</em> винаги е дефиниран вътре в клас конструктора. Въпреки това, стойността не може винаги да е една и съща.</p>
		<dl>
			<dd><pre class="highlight">
<span class="code">class</span> Rectangle {
    constructor(length, width) {
        console.log(<span class="code">new</span>.target === Rectangle);
        <span class="code">this</span>.length = length;
        <span class="code">this</span>.width = width;
    }
}

<span class="code">class</span> Square <span class="code">extends</span> Rectangle {
    constructor(length) {
        <span class="code">super</span>(length, length)
    }
}

// new.target is Square
<span class="code">var</span> obj = <span class="code">new</span> Square(3);      // outputs false
			</pre></dd>
		</dl>
		<p>Тука, <em>Square</em> извиква <em>Rectangle</em> конструктора, така че <em>new.target</em> е равна на <em>Square</em>, когато се извика конструктора <em>Rectangle</em>. Това е важно, защото дава на всеки конструктор способноста да променя поведението си, въз основа на това как се извиква. Например, можем да създадем абстрактен базов клас (такъв, който не може да бъде инстанция директно) с помощта на <em>new.target</em>:</p>
		<dl>
			<dd><pre class="highlight-overflow">
<span class="comment"><em>// абстрактен базов клас</em></span>
<span class="code">class</span> Shape {
    constructor() {
        <span class="code">if</span>(<span class="code">new</span>.target === Shape) {
            <span class="code">throw new Error</span>("This class cannot be instantiated directly.")
        }
    }
}

<span class="code">class</span> Rectangle <span class="code">extends</span> Shape {
    constructor(length, width) {
        <span class="code">super</span>();
        <span class="code">this</span>.length = length;
        <span class="code">this</span>.width = width;
    }
}

<span class="code">var</span> x = <span class="code">new</span> Shape();                <span class="comment"><em>// хвърля грешка</em></span>

<span class="code">var</span> y = <span class="code">new</span> Rectangle(3, 4);        <span class="comment"><em>// няма грешка</em></span>
console.log(y <span class="code">instanceof</span> Shape);    // true
			</pre></dd>
		</dl>
		<p>В този пример, клас конструктора <em>Shape</em> хвърля грешка, когато <em>new.target</em> е <em>Shape</em>, което означава, че <em>new Shape()</em> винаги хвърля грешка. Въпреки това, можем да използваме <em>Shape</em> като базов клас, както правим с <em>Rectangle</em>. Извикването на <em>super()</em> изпълнява <em>Shape</em> конструктора и <em>new.target</em> е равно на <em>Rectangle</em>, за това конструктора продължава без грешка.</p>
		<dl>
			<dd><div class="info">
         <img src="./img/info.jpg" alt="info">
       </div><strong>Понеже класа не може да бъде извикан без <em>new, new.target</em> никога не е дефиниран в рамките на клас конструктор.</strong></dd>
		</dl>
		</article>
		<footer>
		<h3>Обобщение</h3>
		<p>За тези, които се опитват да разберат JavaScript в отсъствието на класове, ECMAScript 6 класовете осигуряват по-лесен начин да се климатизират с езика без да е необходимо да се изхвърли напълно тяхното разбиране за наследяването. ECMAScript 6 класовете започват, като <em>syntactic sugar</em> за класичкия модел на наследяване в ECMAScript 5, но добавят много функции за да се намалят грешките.</p>
		<p>ECMAScript 6 класовете работят с прототипното наследяване, чрез определяне на не-статични методи на прототипа на класа, докато статичните методи в крайна сметка са на самия конструктор. Всички методи са <em>non-enumerable</em>, което по-добре съответства на поведението на вградените обекти, за които методите са обикновено са <em>nonenumerable</em> по подразбиране. Освен това, клас конструктора не може да се извика без <em>new</em>, това гарантира, че не може да извикате клас, като функция.</p>
		<p>Клас базираното наследяване, позволява да се извлече един клас от друг клас, функция или израз. Тази способност означава, че може да се извика функция за определяне на правилната база, от която се наследява, което ни позволява да използваме <em>mixins</em> и други различни модели в състава, за създаване на нов клас. Наследяването работи по такъв начин, че сега е възможно наследяване на вградени обекти, като <em>Array</em>, и работи както се очаква.</p>
		<p>Можете да използвате <em>new.target</em> в клас конструктори, да се държи различно в зависимост от начина на извикване на класа. Най-честата употреба е създаване на абстрактен базов клас, който хвърля грешка при директно стартиране, но все пак позволява наследяване чрез други класове.</p>
		<p>Като цяло, класовете са важно допълнение към езика, като предоставят по-кратък синтаксис и по-добра функционалност за определяне на типове потребителски обекти по последователен и безопасен начин.</p>
		</footer>
		<nav>
	<a href="08_iterators_and_generators.html" title="previous chapter">◀</a>
  <a href="./index.html" title="cover">◆</a>
  <a href="10_array.html" title="next chapter">▶</a>
</nav>
</body>
</html>
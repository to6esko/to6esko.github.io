<!DOCTYPE html>
<!-- saved from url=(0041)./13_dom.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <title>The Document Object Model :: Eloquent JavaScript</title>
  <link rel="stylesheet" href="./media/codemirror.css">
  <script src="./media/acorn_codemirror.js"></script>
  <link rel="stylesheet" href="./media/ejs.css">
  <script src="./media/sandbox.js"></script>
  <script src="./media/ejs.js"></script>
  <script>var chapNum = 13;var sandboxLoadFiles = ["code/mountains.js", "code/chapter/13_dom.js"];</script>
</head>

<body><article>
<nav>
  <a href="./12_browser.html" title="previous chapter">◀</a>
  <a href="./index.html" title="cover">◆</a>
  <a href="./14_event.html" title="next chapter">▶</a>
</nav>

<h1><div class="chap_num">Глава 13</div>Document Object  Model</h1>
<p><a class="p_ident" id="p_O255K9+8+X" href="./13_dom.html#p_O255K9+8+X"></a>Когато отворите уеб страница в браузъра си, той зарежда текста на HTML страницата и го прави по избор, който много прилича на начина, по който нашия анализатор от <a href="./11_language.html#parsing">Chapter 11</a> анализира програми. Браузърът изгражда модел на структурата на документа и след това използва този модел за да изгради страницата на екрана.</p>
<p><a class="p_ident" id="p_NsgEPDmO0h" href="./13_dom.html#p_NsgEPDmO0h"></a>Този начин на представяне на документа е една от играчките, които програмите на JavaScript имат налични в пясъчника му. Може да прочетете от модела и да го промените. Той действа, като една жива структура от данни : когато е модифициран, на страницата на екрана се актуализира, за да отрази промените.</p>
<h2><a class="h_ident" id="h_XJzHjmX32m" href="./13_dom.html#h_XJzHjmX32m"></a>Структура  на  документа</h2>
<p><a class="p_ident" id="p_FuW098VAX5" href="./13_dom.html#p_FuW098VAX5"></a>Можете да си представите един HTML документ, като вложен набор от кутии. Тагове като, <code>&lt;body&gt;</code> и <code>&lt;/body&gt;</code> прилагат други тагове, които от своя страна съдържат други тагове или текст. Ето един документ от <a href="./12_browser.html#browser">предишната глава</a>:</p>
<pre data-language="text/html" class="snippet cm-s-default" data-sandbox="homepage"><a class="c_ident" id="c_hfCVWJl6ha" href="./13_dom.html#c_hfCVWJl6ha"></a><span class="cm-meta">&lt;!doctype html&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">html</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">head</span><span class="cm-tag cm-bracket">&gt;</span>
    <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">title</span><span class="cm-tag cm-bracket">&gt;</span>My home page<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">title</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">head</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">body</span><span class="cm-tag cm-bracket">&gt;</span>
    <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">h1</span><span class="cm-tag cm-bracket">&gt;</span>My home page<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">h1</span><span class="cm-tag cm-bracket">&gt;</span>
    <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>Hello, I am Marijn and this is my home page.<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>
    <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>I also wrote a book! Read it
      <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">a</span> <span class="cm-attribute">href</span>=<span class="cm-string">"http://eloquentjavascript.net"</span><span class="cm-tag cm-bracket">&gt;</span>here<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">a</span><span class="cm-tag cm-bracket">&gt;</span>.<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">body</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">html</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_rRaTGW2wtE" href="./13_dom.html#p_rRaTGW2wtE"></a>Тази страница има следната структура:</p>
<div class="image">
  <img src="./media/html-boxes.svg" alt="HTML document as nested boxes">
</div>
<p><a class="p_ident" id="p_1mgE45KfoF" href="./13_dom.html#p_1mgE45KfoF"></a>Структурата на данните на браузъра използва за представяне на документа следвайки тази форма. За всяка кутия там има един обект, с който можем да взаимодействаме с откриването на нещата, такива каквито таговете на HTML представят и каквито кутии и текст съдържат. Това представяне се нарича <em>Document Object Model</em> или  DOM за по-кратко.</p>
<p><a class="p_ident" id="p_4H8fF9K7jG" href="./13_dom.html#p_4H8fF9K7jG"></a>Глобалната променлива <code>document</code> ни дава достъп до тези обекти. Нейното свойство <code>documentElement</code> се отнася до обекта представен с <code>&lt;html&gt;</code> тага. Той също така предоставя свойствата <code>head</code> и <code>body</code>, които държат обектите на тези елементи.</p>
<h2><a class="h_ident" id="h_HnCB1zb0Ot" href="./13_dom.html#h_HnCB1zb0Ot"></a>Trees</h2>
<p><a class="p_ident" id="p_63ES4U9bHr" href="./13_dom.html#p_63ES4U9bHr"></a>Спомнете си синтактичните дървета от <a href="./11_language.html#parsing">Глава 11</a> за момент. Техните структури са поразително сходни със структурата на документ за браузъра. Всяко разклонение може да се отнася към други разклонения - <em>children</em> деца, които от своя страна могат да имат свои деца. Тази форма е типична за вложени структури, където елементите могат да съдържат под-елементи подобни на тях</p>
<p><a class="p_ident" id="p_QVBp4KpREl" href="./13_dom.html#p_QVBp4KpREl"></a>Ние наричаме структурата от данни - <em>tree</em> (дърво), когато има разклонена структура, но все още няма разклонения (не съдържа разклонение директно или индиректно) но има добре дефиниран “корен”. В случай на DOM, <code>document.documentElement</code> служи за корен.</p>
<p><a class="p_ident" id="p_UKoOzv3djs" href="./13_dom.html#p_UKoOzv3djs"></a>Дърветата са в основата на много компютърни науки. В допълнение към представляващи рекурсивни структури, като HTML документи или програми, те често се използват за поддържане на сортираните набори от данни, защото елементите обикновено могат да бъдат намерени или вписани по-ефективно сортирани в дърво, отколкото сортирани в плосък масив.</p>
<p><a class="p_ident" id="p_bH4un2TNOK" href="./13_dom.html#p_bH4un2TNOK"></a>Типичното дърво има различни разклонения. Дървото в синтаксиса на <a href="./11_language.html#language">езика Egg</a> имаше променливи, стойности и представяне на разклонения. Представените разклонения винаги имат деца, като се имат в предвид стойности и променливи или разклонения без деца.</p>
<p><a class="p_ident" id="p_zV2tKpfume" href="./13_dom.html#p_zV2tKpfume"></a>Същото важи и за DOM. Разклоненията са редовни <em>elements</em> (елементи), които представляват HTML тагове, които определят структурата на документа. Те могат да имат деца разклонения. Пример за такова разклонение е  <code>document.body</code>. Някое от тези деца разклонения могат да бъдат части от текста или коментари (коментарите в HTML се пишат между <code>&lt;!--</code> и <code>--&gt;</code>).</p>
<p><a class="p_ident" id="p_wUIvlqSzVD" href="./13_dom.html#p_wUIvlqSzVD"></a>Всяко разклонение обект на DOM има свойство <code>nodeType</code>, което съдържа цифров код, който идентифицира типа на разклонението. Нормалните елементи имат стойност (1), което също така е дефинирано, като постоянна константа на <code>document.ELEMENT_NODE</code>. Текстовите разклонения, които представляват част от текст в документа имат стойност (3) (<code>document.TEXT_NODE</code>). Коментарите имат стойност (8) (<code>document.COMMENT_NODE</code>).</p>
<p><a class="p_ident" id="p_9JUz0zH2O2" href="./13_dom.html#p_9JUz0zH2O2"></a>Дург начин да се визуализира документ-дърво е както следва:</p>
<div class="image">
  <img src="./media/html-tree.svg" alt="HTML document as a tree">
</div>
<p><a class="p_ident" id="p_CSpbmWiAKq" href="./13_dom.html#p_CSpbmWiAKq"></a>Листата са текстови разклонения, стрелките показват връзката между родител - дете и отношенията между разклоненията.</p>
<h2 id="standard"><a class="h_ident" id="h_XgjABY6Ugx" href="./13_dom.html#h_XgjABY6Ugx"></a>Стандартът</h2>
<p><a class="p_ident" id="p_abbuMja9XR" href="./13_dom.html#p_abbuMja9XR"></a>Използвайки тайни числови кодове за представяне на видовете разклонения не е много в стила на JavaScript. По-късно в тази глава ще разгледаме други части от интерфейса на DOM, които също се чувстват тромави и чужди. Причината за това е, че DOM не е проектиран само за JavaScript. Вместо това той се опитва да определи неутрален интерфейс, който може да се използва с други системи, не само с HTML но и с XML, който има общ формат със синтаксиса на HTML.</p>
<p><a class="p_ident" id="p_aVhfBj+xLx" href="./13_dom.html#p_aVhfBj+xLx"></a>Това е жалко. Стандартите често са полезни. Но в този случай предимството не е всичко непреодолимо. Както един интерфейс, който правилно съчетан с езика, който използвате ще ви спести повече време, отколкото познатия интерфейс на различни езици.</p>
<p><a class="p_ident" id="p_ppPK5iRO6h" href="./13_dom.html#p_ppPK5iRO6h"></a>Като пример за такава слаба интеграция, помислете за  свойството <code>childNodes</code>, което елементите на разклоненията в DOM имат. Това свойство притежава масиво-подобен обект със свойство <code>length</code> и свойства белязани с номера за достъп до <em>childs</em> разклоненията. Но това е инстанция на типа <code>NodeList</code>, а не на реален масив, така че не разполага с методи, като <code>slice</code> и <code>forEach</code>.</p>
<p><a class="p_ident" id="p_NYvzy6J64s" href="./13_dom.html#p_NYvzy6J64s"></a>После идват въпросите за този лош дизайн. Например, няма начин да се създаде ново разклонение и веднага да му се добавят деца или атрибути към него. Вместо това трябва първо да го създадете и след това да добавите децата едно по едно и най-накрая атрибутите един по един, като използвате страничните ефекти. Код, който взаимодейства силно с DOM има тенденцията да е дълъг, повтарящ се и грозен.</p>
<p><a class="p_ident" id="p_1dwhmrGwQQ" href="./13_dom.html#p_1dwhmrGwQQ"></a>Но тези недостатъци не са фатални. Тъй като, JavaScript ни позволява да създаваме собствени абстракции, с които лесно да напишем няколко помощни функции, които да ни позволят да изразим извършваните операции по по-ясен и по-кратък начин. В действителност много библиотеки, предназначени за програмиране на браузъри идват с такива инструменти.</p>
<h2><a class="h_ident" id="h_ShZPVipWw/" href="./13_dom.html#h_ShZPVipWw/"></a>Предвижване  през  дървото</h2>
<p><a class="p_ident" id="p_KU+aLLXhA0" href="./13_dom.html#p_KU+aLLXhA0"></a>DOM разклоненията съдържат доста връзки към други близки разклонения. Следната диаграма илюстрира това:</p>
<div class="image">
  <img src="./media/html-links.svg" alt="Links between DOM nodes">
</div>
<p><a class="p_ident" id="p_oWR8F5E2Yw" href="./13_dom.html#p_oWR8F5E2Yw"></a>Въпреки, че диаграмата показва само една връзка от всички типове, всяко разклонение има <code>parentNode</code> свойство, което сочи към съдържащото го разклонение. По същия начин всеки елемент на разклонение (тип разклонение 1) има <code>childNodes</code> свойство, което сочи към масиво-подобен обект държан от неговите деца.</p>
<p><a class="p_ident" id="p_zpX7kgIV1h" href="./13_dom.html#p_zpX7kgIV1h"></a>На теория можете да се преместите навсякъде в дървото само с помощта на връзките между деца и родители. Но JavaScript ви дава също достъп до редица допълнителни удобни връзки. Свойствата <code>firstChild</code> и <code>lastChild</code> са връзки до първия и последния елемент в разклонението и имат <code>null</code> за разклонение без деца. По същия начин <code>previousSibling</code> и <code>nextSibling</code> са връзки  към съседни разклонения, които имат връзка с общ родител и се появяват веднага преди и след разклонението. За първото дете <code>previousSibling</code> ще бъде нула и за последното дете, <code>nextSibling</code> също ще бъде нула.</p>
<p><a class="p_ident" id="p_wSmPJ/d3c4" href="./13_dom.html#p_wSmPJ/d3c4"></a>Когато става въпрос за вложени структури от данни, като тези, рекурсивните функции често са полезни. Следната рекурсивна функция сканира документ за текстови разклонения, съдържащи се в даден <em>string</em> връща <code>true</code>, когато е установила едно.</p>
<pre id="talksAbout" data-language="javascript" class="snippet cm-s-default" data-sandbox="homepage"><span class="cm-keyword">function</span> <span class="cm-variable">talksAbout</span>(<span class="cm-def">node</span>, <span class="cm-def">string</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">node</span>.<span class="cm-property">nodeType</span> <span class="cm-operator">==</span> <span class="cm-variable">document</span>.<span class="cm-property">ELEMENT_NODE</span>) {
    <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">i</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">i</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">node</span>.<span class="cm-property">childNodes</span>.<span class="cm-property">length</span>; <span class="cm-variable-2">i</span><span class="cm-operator">++</span>) {
      <span class="cm-keyword">if</span> (<span class="cm-variable">talksAbout</span>(<span class="cm-variable-2">node</span>.<span class="cm-property">childNodes</span>[<span class="cm-variable-2">i</span>], <span class="cm-variable-2">string</span>))
        <span class="cm-keyword">return</span> <span class="cm-atom">true</span>;
    }
    <span class="cm-keyword">return</span> <span class="cm-atom">false</span>;
  } <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">node</span>.<span class="cm-property">nodeType</span> <span class="cm-operator">==</span> <span class="cm-variable">document</span>.<span class="cm-property">TEXT_NODE</span>) {
    <span class="cm-keyword">return</span> <span class="cm-variable-2">node</span>.<span class="cm-property">nodeValue</span>.<span class="cm-property">indexOf</span>(<span class="cm-variable-2">string</span>) <span class="cm-operator">&gt;</span> <span class="cm-operator">-</span><span class="cm-number">1</span>;
  }
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">talksAbout</span>(<span class="cm-variable">document</span>.<span class="cm-property">body</span>, <span class="cm-string">"book"</span>));
<span class="cm-comment">// → true</span></pre>
<p><a class="p_ident" id="p_hpFcZy3sUo" href="./13_dom.html#p_hpFcZy3sUo"></a>Свойството <code>nodeValue</code> на текстовото разклонение се отнася до текстовия <em>string</em>, който представлява.</p>
<h2><a class="h_ident" id="h_jS5BEpmLY0" href="./13_dom.html#h_jS5BEpmLY0"></a>Намиране  на  елементи </h2>
<p><a class="p_ident" id="p_saBiuECTgW" href="./13_dom.html#p_saBiuECTgW"></a>Управлението на тези връзки между родители, деца, братя и сестри често е полезно, както предходната функция, която тече през целия документ. Ако искаме да намерим специфично разклонение в документа, то се достига чрез стартиране на <code>document.body</code>, но сляпото следване на твърдия кодов път на линкове е лоша идея, правейки това изследване в нашата програма относно прецизната структура на документа- структура която можем да искаме да променим по-късно. Друг усложняващ фактор е, че текстови разклонения са създадени дори в празното пространство между разклоненията. В примерния документ на <em>body</em> таговете не разполагат само с три деца, едно (<code>&lt;h1&gt;</code> и две <code>&lt;p&gt;</code>, а всъщност със седем: тези три плюс пространствата преди, след и между тях.</p>
<p><a class="p_ident" id="p_St5y6wbhGX" href="./13_dom.html#p_St5y6wbhGX"></a>Така че, ако искате да получите <code>href</code> атрибута на връзката в този документ, трябва да кажем нещо като: вземи второто дете на шестото дете в тялото на документа. А по-лесно би било, ако можехме да се кажем “вземи първата връзка”. И можем:</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="homepage"><a class="c_ident" id="c_aKoH75Zr+K" href="./13_dom.html#c_aKoH75Zr+K"></a><span class="cm-keyword">var</span> <span class="cm-variable">link</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">body</span>.<span class="cm-property">getElementsByTagName</span>(<span class="cm-string">"a"</span>)[<span class="cm-number">0</span>];
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">link</span>.<span class="cm-property">href</span>);</pre>
<p><a class="p_ident" id="p_VGWClqmGZz" href="./13_dom.html#p_VGWClqmGZz"></a>Всички разклонения на елементи имат метода <code>getElementsByTagName</code>, който събира всички елементи с името на даден таг, които са потомци (директни или индиректни деца) на дадено разклонение и ги връща, като масиво-подобен обект.</p>
<p><a class="p_ident" id="p_m0eE7Kg38T" href="./13_dom.html#p_m0eE7Kg38T"></a>За да намерите конкретно едно разклонение може да му дадете <code>id</code> атрибут и да използвате <code>document.getElementById</code>.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_triXCQUCKP" href="./13_dom.html#c_triXCQUCKP"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>My ostrich Gertrude:<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;&lt;</span><span class="cm-tag">img</span> <span class="cm-attribute">id</span>=<span class="cm-string">"gertrude"</span> <span class="cm-attribute">src</span>=<span class="cm-string">"img/ostrich.png"</span><span class="cm-tag cm-bracket">&gt;&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">ostrich</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">getElementById</span>(<span class="cm-string">"gertrude"</span>);
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">ostrich</span>.<span class="cm-property">src</span>);
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_jbdzUTyWj8" href="./13_dom.html#p_jbdzUTyWj8"></a>Трети подобен метод е <code>getElementsByClassName</code>, който подобно на <code>getElementsByTagName</code>, претърсва съдържанието на разклонението и извлича всички елементи, които имат дадения <em>string</em> в техиня <code>class</code> атрибут.</p>
<h2><a class="h_ident" id="h_npiFAJENvT" href="./13_dom.html#h_npiFAJENvT"></a>Промяна  на  документа</h2>
<p><a class="p_ident" id="p_PqYkGnE2Ps" href="./13_dom.html#p_PqYkGnE2Ps"></a>Почти всичко в структурата на данните в DOM може да се променя. Разклоненията на елементите имат редица методи, които могат да бъдат използвани за промяна на тяхното съдържание. Метода <code>removeChild</code> премахва разклонението на дадено дете от документа. За добавяне на дете можем да използваме <code>appendChild</code>, който вмъква разклонение в края на списъка от деца или <code>insertBefore</code>, което вмъква разклонение, като първи аргумент преди това  разклонение, което е дадено, като втори аргумент.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_eG9dfupSor" href="./13_dom.html#c_eG9dfupSor"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>One<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>Two<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>Three<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">paragraphs</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">body</span>.<span class="cm-property">getElementsByTagName</span>(<span class="cm-string">"p"</span>);
  <span class="cm-variable">document</span>.<span class="cm-property">body</span>.<span class="cm-property">insertBefore</span>(<span class="cm-variable">paragraphs</span>[<span class="cm-number">2</span>], <span class="cm-variable">paragraphs</span>[<span class="cm-number">0</span>]);
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_izAyoVA99z" href="./13_dom.html#p_izAyoVA99z"></a>Разклонението може да съществува в документа само на едно място. По този начин, вмъкване на точка “Three” пред параграф “One” първо ще го премахне от края на документа и след това ще го постави от пред и резултата ще е “Three/One/Two”. Всички операции, които вмъкват разклонение някъде, като страничен ефект, причиняват отстраняване от сегашната позиция (ако има такава).</p>
<p><a class="p_ident" id="p_IOhnyZXeWs" href="./13_dom.html#p_IOhnyZXeWs"></a>Метода <code>replaceChild</code> се използва за замяна на дадено разклонение с друго. Взема, като аргументи две разклонения: новото разклонение и това, което трябва да бъде сменено. Замененото разклонение трябва да бъде дете на метода на елемента върху, който е извикано. Имайте в пред вид, че и двата метода <code>replaceChild</code> и <code>insertBefore</code> очакват новото разклонение, като първи аргумент.</p>
<h2><a class="h_ident" id="h_AlX6HES+2D" href="./13_dom.html#h_AlX6HES+2D"></a>Създаване  на  разклонения</h2>
<p><a class="p_ident" id="p_EwUe6UWMca" href="./13_dom.html#p_EwUe6UWMca"></a>В следващия пример, ние искаме да напишем скрипт, който замества всички изображения (<code>&lt;img&gt;</code> тагове) в документа с текста съдържан в техните атрибути, в който се посочва алтернативно текстово представяне на изображението.</p>
<p><a class="p_ident" id="p_HJD0rLoFR3" href="./13_dom.html#p_HJD0rLoFR3"></a>Това включва не само премахване на изображенията но и добавяне на ново текстово разклонение, което да ги замени. За тази цел използваме метода <code>document.createTextNode</code> method.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_rOOH9tlfsG" href="./13_dom.html#c_rOOH9tlfsG"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>The <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">img</span> <span class="cm-attribute">src</span>=<span class="cm-string">"img/cat.png"</span> <span class="cm-attribute">alt</span>=<span class="cm-string">"Cat"</span><span class="cm-tag cm-bracket">&gt;</span> in the
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">img</span> <span class="cm-attribute">src</span>=<span class="cm-string">"img/hat.png"</span> <span class="cm-attribute">alt</span>=<span class="cm-string">"Hat"</span><span class="cm-tag cm-bracket">&gt;</span>.<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;&lt;</span><span class="cm-tag">button</span> <span class="cm-attribute">onclick</span>=<span class="cm-string">"replaceImages()"</span><span class="cm-tag cm-bracket">&gt;</span>Replace<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">button</span><span class="cm-tag cm-bracket">&gt;&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">function</span> <span class="cm-variable">replaceImages</span>() {
    <span class="cm-keyword">var</span> <span class="cm-def">images</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">body</span>.<span class="cm-property">getElementsByTagName</span>(<span class="cm-string">"img"</span>);
    <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">i</span> <span class="cm-operator">=</span> <span class="cm-variable-2">images</span>.<span class="cm-property">length</span> <span class="cm-operator">-</span> <span class="cm-number">1</span>; <span class="cm-variable-2">i</span> <span class="cm-operator">&gt;=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">i</span><span class="cm-operator">--</span>) {
      <span class="cm-keyword">var</span> <span class="cm-def">image</span> <span class="cm-operator">=</span> <span class="cm-variable-2">images</span>[<span class="cm-variable-2">i</span>];
      <span class="cm-keyword">if</span> (<span class="cm-variable-2">image</span>.<span class="cm-property">alt</span>) {
        <span class="cm-keyword">var</span> <span class="cm-def">text</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">createTextNode</span>(<span class="cm-variable-2">image</span>.<span class="cm-property">alt</span>);
        <span class="cm-variable-2">image</span>.<span class="cm-property">parentNode</span>.<span class="cm-property">replaceChild</span>(<span class="cm-variable-2">text</span>, <span class="cm-variable-2">image</span>);
      }
    }
  }
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_SZGvV3YwdR" href="./13_dom.html#p_SZGvV3YwdR"></a>Дадения <em>string</em>, <code>createTextNode</code> ни дава разклонение от тип (3) на DOM (текстово разклонение), което можем да вмъкнем в документа за да се покаже на екрана.</p>
<p><a class="p_ident" id="p_6KP6Yw4ww7" href="./13_dom.html#p_6KP6Yw4ww7"></a>Цикълът, който преминава през изображенията започва от края на списъка с разклонения. Това е необходимо, тъй като списъкът на разклоненията се връща с модел подобен на <code>getElementsByTagName</code> (или свойство, като <code>childNodes</code>). Това е, когато се актуализира в зависимост от промяната на документа. Ако започнем от предната част с отстраняване на първото изображение, списъка ще изгуби неговия първи елемент, така че при втората итерация на цикъла <code>i</code> ще бъде равна на 1 и ще спре, защото дължината на колекцията също ще е 1.</p>
<p><a class="p_ident" id="p_KIHvSOXCAK" href="./13_dom.html#p_KIHvSOXCAK"></a>Ако искате солидна колекция от разклонения може да конвертирате събрания реален масив, като извикате метода <code>slice</code> върху масива</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_U61CHIeSMc" href="./13_dom.html#c_U61CHIeSMc"></a><span class="cm-keyword">var</span> <span class="cm-variable">arrayish</span> <span class="cm-operator">=</span> {<span class="cm-number cm-property">0</span>: <span class="cm-string">"one"</span>, <span class="cm-number cm-property">1</span>: <span class="cm-string">"two"</span>, <span class="cm-property">length</span>: <span class="cm-number">2</span>};
<span class="cm-keyword">var</span> <span class="cm-variable">real</span> <span class="cm-operator">=</span> <span class="cm-variable">Array</span>.<span class="cm-property">prototype</span>.<span class="cm-property">slice</span>.<span class="cm-property">call</span>(<span class="cm-variable">arrayish</span>, <span class="cm-number">0</span>);
<span class="cm-variable">real</span>.<span class="cm-property">forEach</span>(<span class="cm-keyword">function</span>(<span class="cm-def">elt</span>) { <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable-2">elt</span>); });
<span class="cm-comment">// → one</span>
<span class="cm-comment">//   two</span></pre>
<p><a class="p_ident" id="p_s5ww9M09mP" href="./13_dom.html#p_s5ww9M09mP"></a>За да създадете редовни елементи - разклонения тип (1) можете да използвате  метода <code>document.createElement</code>. Този метод взема името и връща ново празно разклонение на дадения тип.</p>
<p id="elt"><a class="p_ident" id="p_bvldRsjLfM" href="./13_dom.html#p_bvldRsjLfM"></a>Следващия пример дефинира удобен <code>elt</code>, който създава елемент -разклонение и третира останалата част от аргументите си, като деца на това разклонение. Тази функция се използва за лесно добавяне на атрибут към цитат.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_y/gv0G99CD" href="./13_dom.html#c_y/gv0G99CD"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">blockquote</span> <span class="cm-attribute">id</span>=<span class="cm-string">"quote"</span><span class="cm-tag cm-bracket">&gt;</span>
  No book can ever be finished. While working on it we learn
  just enough to find it immature the moment we turn away
  from it.
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">blockquote</span><span class="cm-tag cm-bracket">&gt;</span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">function</span> <span class="cm-variable">elt</span>(<span class="cm-def">type</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">node</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">createElement</span>(<span class="cm-variable-2">type</span>);
    <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">i</span> <span class="cm-operator">=</span> <span class="cm-number">1</span>; <span class="cm-variable-2">i</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">arguments</span>.<span class="cm-property">length</span>; <span class="cm-variable-2">i</span><span class="cm-operator">++</span>) {
      <span class="cm-keyword">var</span> <span class="cm-def">child</span> <span class="cm-operator">=</span> <span class="cm-variable-2">arguments</span>[<span class="cm-variable-2">i</span>];
      <span class="cm-keyword">if</span> (<span class="cm-keyword">typeof</span> <span class="cm-variable-2">child</span> <span class="cm-operator">==</span> <span class="cm-string">"string"</span>)
        <span class="cm-variable-2">child</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">createTextNode</span>(<span class="cm-variable-2">child</span>);
      <span class="cm-variable-2">node</span>.<span class="cm-property">appendChild</span>(<span class="cm-variable-2">child</span>);
    }
    <span class="cm-keyword">return</span> <span class="cm-variable-2">node</span>;
  }

  <span class="cm-variable">document</span>.<span class="cm-property">getElementById</span>(<span class="cm-string">"quote"</span>).<span class="cm-property">appendChild</span>(
    <span class="cm-variable">elt</span>(<span class="cm-string">"footer"</span>, <span class="cm-string">"—"</span>,
        <span class="cm-variable">elt</span>(<span class="cm-string">"strong"</span>, <span class="cm-string">"Karl Popper"</span>),
        <span class="cm-string">", preface to the second editon of "</span>,
        <span class="cm-variable">elt</span>(<span class="cm-string">"em"</span>, <span class="cm-string">"The Open Society and Its Enemies"</span>),
        <span class="cm-string">", 1950"</span>));
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<h2><a class="h_ident" id="h_pmUmF/LHme" href="./13_dom.html#h_pmUmF/LHme"></a>Атрибути</h2>
<p><a class="p_ident" id="p_HSPdyuAruy" href="./13_dom.html#p_HSPdyuAruy"></a>Някои елементи - атрибути, като например <code>href</code> за връзка, могат да бъдат достъпни чрез свойството на същото име на елемента в DOM обекта. Това е случай на ограничена група от използвани стандартни атрибути.</p>
<p><a class="p_ident" id="p_vK0AfBjXCM" href="./13_dom.html#p_vK0AfBjXCM"></a>Но HTML ви позволява да групирате всеки атрибут, който искате в разклонения. Това може да бъде полезно, тъй като ви позволява да съхранявате допълнителна информация в документа. Ако направите вашите имена на атрибути, обаче, такива атрибути няма да бъдат налични, като свойство на разклонението на елемента. Вместо това ще трябва да използвате методите <code>getAttribute</code> и <code>setAttribute</code> за работа с тях.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_Y+EUbJzNj3" href="./13_dom.html#c_Y+EUbJzNj3"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span> <span class="cm-attribute">data-classified</span>=<span class="cm-string">"secret"</span><span class="cm-tag cm-bracket">&gt;</span>The launch code is 00000000.<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span> <span class="cm-attribute">data-classified</span>=<span class="cm-string">"unclassified"</span><span class="cm-tag cm-bracket">&gt;</span>I have two feet.<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">paras</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">body</span>.<span class="cm-property">getElementsByTagName</span>(<span class="cm-string">"p"</span>);
  <span class="cm-variable">Array</span>.<span class="cm-property">prototype</span>.<span class="cm-property">forEach</span>.<span class="cm-property">call</span>(<span class="cm-variable">paras</span>, <span class="cm-keyword">function</span>(<span class="cm-def">para</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">para</span>.<span class="cm-property">getAttribute</span>(<span class="cm-string">"data-classified"</span>) <span class="cm-operator">==</span> <span class="cm-string">"secret"</span>)
      <span class="cm-variable-2">para</span>.<span class="cm-property">parentNode</span>.<span class="cm-property">removeChild</span>(<span class="cm-variable-2">para</span>);
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_TbxTjtVsz1" href="./13_dom.html#p_TbxTjtVsz1"></a>Препоръчвам ви да пишете имената на такива измислени атрибути с <code>data-</code> за да гарантирате, че те не са в противоречие с всички останали атрибути.</p>
<p><a class="p_ident" id="p_wZUvKB4q4J" href="./13_dom.html#p_wZUvKB4q4J"></a>Като прост пример, ще напишем “syntax highlighter”, който се оглежда за <code>&lt;pre&gt;</code> тагове (предварително форматирани използвани за код и прав текст) с <code>data-language</code> атрибут и грубо се опитаме да подчертаем ключовите думи на този език.</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="highlight"><a class="c_ident" id="c_Fy7gcr8Htp" href="./13_dom.html#c_Fy7gcr8Htp"></a><span class="cm-keyword">function</span> <span class="cm-variable">highlightCode</span>(<span class="cm-def">node</span>, <span class="cm-def">keywords</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">text</span> <span class="cm-operator">=</span> <span class="cm-variable-2">node</span>.<span class="cm-property">textContent</span>;
  <span class="cm-variable-2">node</span>.<span class="cm-property">textContent</span> <span class="cm-operator">=</span> <span class="cm-string">""</span>; <span class="cm-comment">// Clear the node</span>

  <span class="cm-keyword">var</span> <span class="cm-def">match</span>, <span class="cm-def">pos</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>;
  <span class="cm-keyword">while</span> (<span class="cm-variable-2">match</span> <span class="cm-operator">=</span> <span class="cm-variable-2">keywords</span>.<span class="cm-property">exec</span>(<span class="cm-variable-2">text</span>)) {
    <span class="cm-keyword">var</span> <span class="cm-def">before</span> <span class="cm-operator">=</span> <span class="cm-variable-2">text</span>.<span class="cm-property">slice</span>(<span class="cm-variable-2">pos</span>, <span class="cm-variable-2">match</span>.<span class="cm-property">index</span>);
    <span class="cm-variable-2">node</span>.<span class="cm-property">appendChild</span>(<span class="cm-variable">document</span>.<span class="cm-property">createTextNode</span>(<span class="cm-variable-2">before</span>));
    <span class="cm-keyword">var</span> <span class="cm-def">strong</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">createElement</span>(<span class="cm-string">"strong"</span>);
    <span class="cm-variable-2">strong</span>.<span class="cm-property">appendChild</span>(<span class="cm-variable">document</span>.<span class="cm-property">createTextNode</span>(<span class="cm-variable-2">match</span>[<span class="cm-number">0</span>]));
    <span class="cm-variable-2">node</span>.<span class="cm-property">appendChild</span>(<span class="cm-variable-2">strong</span>);
    <span class="cm-variable-2">pos</span> <span class="cm-operator">=</span> <span class="cm-variable-2">keywords</span>.<span class="cm-property">lastIndex</span>;
  }
  <span class="cm-keyword">var</span> <span class="cm-def">after</span> <span class="cm-operator">=</span> <span class="cm-variable-2">text</span>.<span class="cm-property">slice</span>(<span class="cm-variable-2">pos</span>);
  <span class="cm-variable-2">node</span>.<span class="cm-property">appendChild</span>(<span class="cm-variable">document</span>.<span class="cm-property">createTextNode</span>(<span class="cm-variable-2">after</span>));
}</pre>
<p><a class="p_ident" id="p_pT03b/PJLa" href="./13_dom.html#p_pT03b/PJLa"></a>Функцията <code>highlightCode</code> взема разклонението <code>&lt;pre&gt;</code> и регулярен израз (с включена глобална опция), която съвпада с ключовите думи на езика за програмиране, които елемента съдържа.</p>
<p><a class="p_ident" id="p_uu6ujSbhOJ" href="./13_dom.html#p_uu6ujSbhOJ"></a>Свойството <code>textContent</code> се използва за да получим целия текст в разклонението и след това го приравняваме с празен <em>string</em>, което има ефект на изпразване на разклонението. Цикъла минава през всички съответствия на израза с ключовата дума, като определя текста между тях, като редовни текстови разклонения, а съвпадащия текст (ключови думи), като текстови разклонения увити в <code>&lt;strong&gt;</code> (<em>bold</em>) удебелени елементи</p>
<p><a class="p_ident" id="p_lJjXqP5cl1" href="./13_dom.html#p_lJjXqP5cl1"></a>Ние можем автоматично да маркираме всички програми на страницата с цикъл през всички <code>&lt;pre&gt;</code> елементи, които имат <code>data-language</code> атрибут и извикаме <code>highlightCode</code> върху всеки един с правилния израз на езика.</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="highlight"><a class="c_ident" id="c_tE3g5erxbl" href="./13_dom.html#c_tE3g5erxbl"></a><span class="cm-keyword">var</span> <span class="cm-variable">languages</span> <span class="cm-operator">=</span> {
  <span class="cm-property">javascript</span>: <span class="cm-string-2">/\b(function|return|var)\b/g</span> <span class="cm-comment">/* … etc */</span>
};

<span class="cm-keyword">function</span> <span class="cm-variable">highlightAllCode</span>() {
  <span class="cm-keyword">var</span> <span class="cm-def">pres</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">body</span>.<span class="cm-property">getElementsByTagName</span>(<span class="cm-string">"pre"</span>);
  <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">i</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">i</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">pres</span>.<span class="cm-property">length</span>; <span class="cm-variable-2">i</span><span class="cm-operator">++</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">pre</span> <span class="cm-operator">=</span> <span class="cm-variable-2">pres</span>[<span class="cm-variable-2">i</span>];
    <span class="cm-keyword">var</span> <span class="cm-def">lang</span> <span class="cm-operator">=</span> <span class="cm-variable-2">pre</span>.<span class="cm-property">getAttribute</span>(<span class="cm-string">"data-language"</span>);
    <span class="cm-keyword">if</span> (<span class="cm-variable">languages</span>.<span class="cm-property">hasOwnProperty</span>(<span class="cm-variable-2">lang</span>))
      <span class="cm-variable">highlightCode</span>(<span class="cm-variable-2">pre</span>, <span class="cm-variable">languages</span>[<span class="cm-variable-2">lang</span>]);
  }
}</pre>
<p><a class="p_ident" id="p_q0YBA4Bx6Q" href="./13_dom.html#p_q0YBA4Bx6Q"></a>Ето един пример:</p>
<pre data-language="text/html" class="snippet cm-s-default" data-sandbox="highlight"><a class="c_ident" id="c_1FkYrByRvF" href="./13_dom.html#c_1FkYrByRvF"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>Here it is, the identity function:<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">pre</span> <span class="cm-attribute">data-language</span>=<span class="cm-string">"javascript"</span><span class="cm-tag cm-bracket">&gt;</span>
function id(x) { return x; }
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">pre</span><span class="cm-tag cm-bracket">&gt;</span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span><span class="cm-variable">highlightAllCode</span>();<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_fBkADkC735" href="./13_dom.html#p_fBkADkC735"></a>Има един често използван атрибут <code>class</code>, който е запазена дума в езика JavaScript. По исторически причини - стари приложения на JavaScript не могат да се справят с имената на свойствата, които съвпадат с ключови думи или запазени думи - това свойството, което се използва за достъп до този атрибут се нарича <code>className</code>. Можете също да получите достъп до него под реалното му име class с помощта на методите <code>getAttribute</code> и <code>setAttribute</code> methods.</p>
<h2><a class="h_ident" id="h_lyrY2KUDl7" href="./13_dom.html#h_lyrY2KUDl7"></a>Подредба  на  нещата</h2>
<p><a class="p_ident" id="p_bLEGhDS9sd" href="./13_dom.html#p_bLEGhDS9sd"></a>Може би сте забелязали, че различни видове елементи са представени по различен начин. Някои параграфи, като (<code>&lt;p&gt;</code>) или (<code>&lt;h1&gt;</code>) заемат цялата ширина на документа и се представят на отделни редове. Те се наричат <em>block</em> (блокови) елементи. Други елементи, като линкове (<code>&lt;a&gt;</code>) или <code>&lt;strong&gt;</code> използвани в предишния пример, са рендерирани на една и съща линия със заобикалящия ги текст. Такива елементи се наричат <em>inline</em> (вградени).</p>
<p><a class="p_ident" id="p_uyQ6hsLw6d" href="./13_dom.html#p_uyQ6hsLw6d"></a>За всеки даден документ, браузъра е в състояние да изчисли оформлението, като дава за всеки елемент размер и позиция на базата на неговия вид и съдържание. След това тази подредба се използва за действително изготвяне на документа.</p>
<p><a class="p_ident" id="p_mT0v96DVDo" href="./13_dom.html#p_mT0v96DVDo"></a>Размерът и позицията на даден елемент може да бъде достъпен с JavaScript. Свойствата <code>offsetWidth</code> и <code>offsetHeight</code> дават пространството, което един елемент заема в <em>pixels</em> (пиксели). Пикселът е основна единица за измерване в браузъра  и  отговаря на една малка точица на вашия екран. По същия начин <code>clientWidth</code> и <code>clientHeight</code> дават размера на пространството вътре в елемента, като игнорира дебелината на границите.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_QoIeKzckHs" href="./13_dom.html#c_QoIeKzckHs"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span> <span class="cm-attribute">style</span>=<span class="cm-string">"border: 3px solid red"</span><span class="cm-tag cm-bracket">&gt;</span>
  I'm boxed in
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">para</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">body</span>.<span class="cm-property">getElementsByTagName</span>(<span class="cm-string">"p"</span>)[<span class="cm-number">0</span>];
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"clientHeight:"</span>, <span class="cm-variable">para</span>.<span class="cm-property">clientHeight</span>);
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"offsetHeight:"</span>, <span class="cm-variable">para</span>.<span class="cm-property">offsetHeight</span>);
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p id="boundingRect"><a class="p_ident" id="p_RG9FbUJg15" href="./13_dom.html#p_RG9FbUJg15"></a>Най-ефективния начин за намиране на най-точната позиция на елемент върху екрана е с метода <code>getBoundingClientRect</code>. Той връща обект с <code>top</code>,<code>bottom</code>, <code>left</code> и <code>right</code> свойства, като посочва в пиксели позициите на страните на елемента спрямо горния ляв ъгъл на екрана. Ако го искате по отношение на целия документ, трябва да добавите текущата позиция, намерена по глобалните <code>pageXOffset</code>
и <code>pageYOffset</code> променливи.</p>
<p><a class="p_ident" id="p_nnTb9RktUT" href="./13_dom.html#p_nnTb9RktUT"></a>Подредбата на нещата в един документ може да бъде доста работа. В интерес на скоростта, браузърът не опреснява всеки път веднага промените в рамките на повторна подредба на документа, а изчаква толкова дълго, колкото може. Когато програмата на JavaScript, която променя документа завърши работа, браузърът ще трябва да изчисли подредба за да покаже променения документ на екрана. Когато една програма пита за позицията или размера на нещо четейки качествата, които <code>offsetHeight</code> или <code>getBoundingClientRect</code> предоставят, тя също се нуждае от изчисляване на подредбата.</p>
<p><a class="p_ident" id="p_6id19IfKq+" href="./13_dom.html#p_6id19IfKq+"></a>Програма, която многократно редува четене на DOM информация за подредба и променя DOM по тази подредба ще работи наистина бавно. Следният код показва пример за това. Той съдържа две различни програми, които изграждат една линия със <em>X</em> характера, широка 2000 пиксела и измерва времето на добавянето на всеки един характер.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_jx63hJ74kz" href="./13_dom.html#c_jx63hJ74kz"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;&lt;</span><span class="cm-tag">span</span> <span class="cm-attribute">id</span>=<span class="cm-string">"one"</span><span class="cm-tag cm-bracket">&gt;&lt;/</span><span class="cm-tag">span</span><span class="cm-tag cm-bracket">&gt;&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;&lt;</span><span class="cm-tag">span</span> <span class="cm-attribute">id</span>=<span class="cm-string">"two"</span><span class="cm-tag cm-bracket">&gt;&lt;/</span><span class="cm-tag">span</span><span class="cm-tag cm-bracket">&gt;&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">function</span> <span class="cm-variable">time</span>(<span class="cm-def">name</span>, <span class="cm-def">action</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">start</span> <span class="cm-operator">=</span> <span class="cm-variable">Date</span>.<span class="cm-property">now</span>(); <span class="cm-comment">// Current time in milliseconds</span>
    <span class="cm-variable-2">action</span>();
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable-2">name</span>, <span class="cm-string">"took"</span>, <span class="cm-variable">Date</span>.<span class="cm-property">now</span>() <span class="cm-operator">-</span> <span class="cm-variable-2">start</span>, <span class="cm-string">"ms"</span>);
  }

  <span class="cm-variable">time</span>(<span class="cm-string">"naive"</span>, <span class="cm-keyword">function</span>() {
    <span class="cm-keyword">var</span> <span class="cm-def">target</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">getElementById</span>(<span class="cm-string">"one"</span>);
    <span class="cm-keyword">while</span> (<span class="cm-variable-2">target</span>.<span class="cm-property">offsetWidth</span> <span class="cm-operator">&lt;</span> <span class="cm-number">2000</span>)
      <span class="cm-variable-2">target</span>.<span class="cm-property">appendChild</span>(<span class="cm-variable">document</span>.<span class="cm-property">createTextNode</span>(<span class="cm-string">"X"</span>));
  });
  <span class="cm-comment">// → naive took 32 ms</span>

  <span class="cm-variable">time</span>(<span class="cm-string">"clever"</span>, <span class="cm-keyword">function</span>() {
    <span class="cm-keyword">var</span> <span class="cm-def">target</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">getElementById</span>(<span class="cm-string">"two"</span>);
    <span class="cm-variable-2">target</span>.<span class="cm-property">appendChild</span>(<span class="cm-variable">document</span>.<span class="cm-property">createTextNode</span>(<span class="cm-string">"XXXXX"</span>));
    <span class="cm-keyword">var</span> <span class="cm-def">total</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">ceil</span>(<span class="cm-number">2000</span> <span class="cm-operator">/</span> (<span class="cm-variable-2">target</span>.<span class="cm-property">offsetWidth</span> <span class="cm-operator">/</span> <span class="cm-number">5</span>));
    <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">i</span> <span class="cm-operator">=</span> <span class="cm-number">5</span>; <span class="cm-variable-2">i</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">total</span>; <span class="cm-variable-2">i</span><span class="cm-operator">++</span>)
      <span class="cm-variable-2">target</span>.<span class="cm-property">appendChild</span>(<span class="cm-variable">document</span>.<span class="cm-property">createTextNode</span>(<span class="cm-string">"X"</span>));
  });
  <span class="cm-comment">// → clever took 1 ms</span>
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<h2><a class="h_ident" id="h_VfKBbtOqcL" href="./13_dom.html#h_VfKBbtOqcL"></a>Оформление</h2>
<p><a class="p_ident" id="p_sWGHgVTbfa" href="./13_dom.html#p_sWGHgVTbfa"></a>Видяхме, че различните HTML елементи показват различно поведение. Някои от тях са показани, като блокове, а други в редици. Някои добавят стил, като <code>&lt;strong&gt;</code>, който удебелява съдържанието и <code>&lt;a&gt;</code>, който прави съдържанието синьо и го подчертава.</p>
<p><a class="p_ident" id="p_CLPG6z9ZaH" href="./13_dom.html#p_CLPG6z9ZaH"></a>Начинът, по който един <code>&lt;img&gt;</code> таг показва изображения или <code>&lt;a&gt;</code> създава линк за връзка, който ще бъде последван след като е щракнат, е силно обвързан с вида на елемента. Но стилът по подразбиране свързан с елемента, като например цвят или подчертаване на текст, може да бъде променен от нас. Ето един пример за използване на свойството <code>style</code>:</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_hNWMeC0rA+" href="./13_dom.html#c_hNWMeC0rA+"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;&lt;</span><span class="cm-tag">a</span> <span class="cm-attribute">href</span>=<span class="cm-string">"."</span><span class="cm-tag cm-bracket">&gt;</span>Normal link<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">a</span><span class="cm-tag cm-bracket">&gt;&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;&lt;</span><span class="cm-tag">a</span> <span class="cm-attribute">href</span>=<span class="cm-string">"."</span> <span class="cm-attribute">style</span>=<span class="cm-string">"color: green"</span><span class="cm-tag cm-bracket">&gt;</span>Green link<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">a</span><span class="cm-tag cm-bracket">&gt;&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_6HjJoH2gQy" href="./13_dom.html#p_6HjJoH2gQy"></a>Атрибута <em>style</em> може да съдържа повече от една декларация със свойства (като <code>color</code>) следвано от двуточие и стойност (като <code>green</code>). Когато има повече от една декларация те трябва да бъдат разделени със точка и запетая (;), както в <code>"color: red; border: none"</code>.</p>
<p><a class="p_ident" id="p_oyv0VBpq2N" href="./13_dom.html#p_oyv0VBpq2N"></a>Има много аспекти, които могат да бъдат повлияни със стайлинг. Например свойството <code>display</code> контролира дали даден елемент се показва, като блок или в редица.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_oGtFHeNA4W" href="./13_dom.html#c_oGtFHeNA4W"></a>This text is displayed <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">strong</span><span class="cm-tag cm-bracket">&gt;</span>inline<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">strong</span><span class="cm-tag cm-bracket">&gt;</span>,
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">strong</span> <span class="cm-attribute">style</span>=<span class="cm-string">"display: block"</span><span class="cm-tag cm-bracket">&gt;</span>as a block<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">strong</span><span class="cm-tag cm-bracket">&gt;</span>, and
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">strong</span> <span class="cm-attribute">style</span>=<span class="cm-string">"display: none"</span><span class="cm-tag cm-bracket">&gt;</span>not at all<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">strong</span><span class="cm-tag cm-bracket">&gt;</span>.</pre>
<p><a class="p_ident" id="p_lJ3ZvKI2rm" href="./13_dom.html#p_lJ3ZvKI2rm"></a><code>Block</code> тага ще се покаже на отделен ред, тъй като блоковите елементи не се показват в редица с текста около тях. Последния таг не се показва <code>display: none</code> - не показва елемента на екрана. Това е начин да се скрият елементи. Това често е за предпочитане, отколкото да ги извадите от документа изцяло, защото ги прави лесни за показване отново по-късно.</p>
<p><a class="p_ident" id="p_0ienMYXo3C" href="./13_dom.html#p_0ienMYXo3C"></a>JavaScript кода може директно да манипулира стила на елемент, чрез свойството <code>style</code>. Това свойство има обект, който има свойства за всички възможни стилове. Стойностите на тези свойства са strings, които можем да пишем за да променим конкретен аспект в стила на елемента.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_i1GuHLCmAS" href="./13_dom.html#c_i1GuHLCmAS"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span> <span class="cm-attribute">id</span>=<span class="cm-string">"para"</span> <span class="cm-attribute">style</span>=<span class="cm-string">"color: purple"</span><span class="cm-tag cm-bracket">&gt;</span>
  Pretty text
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">para</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">getElementById</span>(<span class="cm-string">"para"</span>);
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">para</span>.<span class="cm-property">style</span>.<span class="cm-property">color</span>);
  <span class="cm-variable">para</span>.<span class="cm-property">style</span>.<span class="cm-property">color</span> <span class="cm-operator">=</span> <span class="cm-string">"magenta"</span>;
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_LVJWvFthG2" href="./13_dom.html#p_LVJWvFthG2"></a>Някои имена на свойства на стил съдържат тирета, като например <code>font-family</code>. Тъй като такива имена на свойства са неудобни за работа със JavaScript (ще трябва да напишем, <code>style["font-family"]</code>), имената за подобни свойствата в обекта <code>style</code> са с отстранени тирета и буквите, които ги следват са капитализирани (<code>style.fontFamily</code>).</p>
<h2><a class="h_ident" id="h_7kGsaGnBbD" href="./13_dom.html#h_7kGsaGnBbD"></a>CSS стилове</h2>
<p><a class="p_ident" id="p_Phol2kWQBL" href="./13_dom.html#p_Phol2kWQBL"></a>Системата за стайлинг на HTML се нарича CSS - <em>Cascading Style Sheets</em>. <em>Style sheet</em> е набор от правила, за това как да оформите елементи в документ. Те могат да се прилагат във вътрешността на тага <code>&lt;style&gt;</code>.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_prZWDFvQ2S" href="./13_dom.html#c_prZWDFvQ2S"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">style</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-tag">strong</span> {
    <span class="cm-property">font-style</span>: <span class="cm-atom">italic</span>;
    <span class="cm-property">color</span>: <span class="cm-keyword">gray</span>;
  }
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">style</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>Now <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">strong</span><span class="cm-tag cm-bracket">&gt;</span>strong text<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">strong</span><span class="cm-tag cm-bracket">&gt;</span> is italic and gray.<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_m7OFPUb4bV" href="./13_dom.html#p_m7OFPUb4bV"></a><em>Cascading</em> се отнася до факта, че могат да се комбинират множество такива правила за да се получи крайният стил на елемента. В предишния пример, стайлинга по подразбиране за <code>&lt;strong&gt;</code> тагове е <code>font-weight:
bold</code> опаковано в <code>&lt;style&gt;</code> таг, който добавя <code>font-style</code> и <code><em>color</em></code>.</p>
<p><a class="p_ident" id="p_TpdOmgyGAl" href="./13_dom.html#p_TpdOmgyGAl"></a>Когато няколко правила определят стойността на едно и също свойство, правилото с най-висок приоритет побеждава. Така че, ако правилата включени в <code>&lt;style&gt;</code> тага са в конфликт - <code>font-weight: normal</code> по подразбиране текста ще бъде нормален, а не <em>bold</em>. Стиловете в <code>style</code> атрибута, които се прилагат директно към разклонението имат най-висок приоритет и винаги печелят.</p>
<p><a class="p_ident" id="p_BgSVZ5fpx+" href="./13_dom.html#p_BgSVZ5fpx+"></a>Възможно е да посочите неща различни от имената на таговете с правилата на CSS. Едно правило за <code>.abc</code> се прилага за всички елементи с <code>"abc"</code> атрибут  на класа. Правило за <code>#xyz</code> се отнася за елементи с <code>id</code> атрибут <code>"xyz"</code> (който трябва да е уникален в рамките на документа).</p>
<pre data-language="text/css" class="snippet cm-s-default"><a class="c_ident" id="c_G/2r76XW7V" href="./13_dom.html#c_G/2r76XW7V"></a><span class="cm-qualifier">.subtle</span> {
  <span class="cm-property">color</span>: <span class="cm-keyword">gray</span>;
  <span class="cm-property">font-size</span>: <span class="cm-number">80%</span>;
}
<span class="cm-builtin">#header</span> {
  <span class="cm-property">background</span>: <span class="cm-keyword">blue</span>;
  <span class="cm-property">color</span>: <span class="cm-keyword">white</span>;
}
<span class="cm-comment">/* p elements, with classes a and b, and id main */</span>
<span class="cm-tag">p</span><span class="cm-qualifier">.a.b</span><span class="cm-builtin">#main</span> {
  <span class="cm-property">margin-bottom</span>: <span class="cm-number">20px</span>;
}</pre>
<p><a class="p_ident" id="p_7kmWmOHAMA" href="./13_dom.html#p_7kmWmOHAMA"></a>Правилото за предимство в полза на последно определеното правило и важи само, когато правилата имат една и съща специфичност. Специфичност е мярка за това, колко точно се описват съвпадащите елементи, като брой и вид (таг, клас или <em>id</em>). Например, едно правило насочено към <code>p.a</code> е по-специфично от правило насочено просто към <code>p</code> или <code>.a</code> и по този начин ще има предимство.</p>
<p><a class="p_ident" id="p_2eZ1iteQyg" href="./13_dom.html#p_2eZ1iteQyg"></a>Означението <code>p &gt; a {…}</code> прилага дадените стилове за всички <code>&lt;a&gt;</code> тагове, които са преки деца на <code>&lt;p&gt;</code> таговете. По същия начин <code>p a {…}</code> се отнася за всички <code>&lt;a&gt;</code> тагове вътре в <code>&lt;p&gt;</code> таговете, без значение дали са преки или не преки деца.</p>
<h2><a class="h_ident" id="h_5ooQzToxht" href="./13_dom.html#h_5ooQzToxht"></a>Query  selectors    (Критерии  за  селектори)</h2>
<p><a class="p_ident" id="p_RtMy1VYPVy" href="./13_dom.html#p_RtMy1VYPVy"></a>Ние няма да използваме много шаблони за стилове в тази книга. Въпреки, че разбирането им е от решаващо значение за програмирането във браузъра. Правилното обяснение на всички свойства на стиловете, които те поддържат, както и взаимодействието между тези свойства ще отнеме две или три книги.</p>
<p><a class="p_ident" id="p_vgThAtbEjX" href="./13_dom.html#p_vgThAtbEjX"></a>Основната причина за въвеждането на нотацията за селектор синтаксиса използвана в стиловете е да се определи върху кои елементи да се прилагат набори от стилове, можем да използваме този същия мини-език, като ефективен начин за намиране на DOM елементи.</p>
<p><a class="p_ident" id="p_6m9AOTvoRS" href="./13_dom.html#p_6m9AOTvoRS"></a>Метода <code>querySelectorAll</code>, който се определя, като <code>document</code> обект и на разклонения от елементи, взема <em>string</em> селектор и връща масиво-подобен обект съдържащ всички елементи, на които съответства.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_ZSN4aV8YVN" href="./13_dom.html#c_ZSN4aV8YVN"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>And if you go chasing
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">span</span> <span class="cm-attribute">class</span>=<span class="cm-string">"animal"</span><span class="cm-tag cm-bracket">&gt;</span>rabbits<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">span</span><span class="cm-tag cm-bracket">&gt;&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>And you know you're going to fall<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>Tell 'em a <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">span</span> <span class="cm-attribute">class</span>=<span class="cm-string">"character"</span><span class="cm-tag cm-bracket">&gt;</span>hookah smoking
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">span</span> <span class="cm-attribute">class</span>=<span class="cm-string">"animal"</span><span class="cm-tag cm-bracket">&gt;</span>caterpillar<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">span</span><span class="cm-tag cm-bracket">&gt;&lt;/</span><span class="cm-tag">span</span><span class="cm-tag cm-bracket">&gt;&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>Has given you the call<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">function</span> <span class="cm-variable">count</span>(<span class="cm-def">selector</span>) {
    <span class="cm-keyword">return</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelectorAll</span>(<span class="cm-variable-2">selector</span>).<span class="cm-property">length</span>;
  }
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">count</span>(<span class="cm-string">"p"</span>));           <span class="cm-comment">// All &lt;p&gt; elements</span>
  <span class="cm-comment">// → 4</span>
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">count</span>(<span class="cm-string">".animal"</span>));     <span class="cm-comment">// Class animal</span>
  <span class="cm-comment">// → 2</span>
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">count</span>(<span class="cm-string">"p .animal"</span>));   <span class="cm-comment">// Animal inside of &lt;p&gt;</span>
  <span class="cm-comment">// → 2</span>
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">count</span>(<span class="cm-string">"p &gt; .animal"</span>)); <span class="cm-comment">// Direct child of &lt;p&gt;</span>
  <span class="cm-comment">// → 1</span>
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_EQFXoZVpt7" href="./13_dom.html#p_EQFXoZVpt7"></a>За разлика от методи, като <code>getElementsByTagName</code> обекта, който връща  <code>querySelectorAll</code> не е жив. Той няма да се промени, когато промените документа.</p>
<p><a class="p_ident" id="p_sO/Wz9EvWw" href="./13_dom.html#p_sO/Wz9EvWw"></a>Метода <code>querySelector</code> (без <code>All</code> часта) работи по подобен начин. Но е полезен ако искате конкретно един елемент. Той ще върне само първия съвпадащ елемент или нула, ако няма съответствие на елементи.</p>
<h2 id="animation"><a class="h_ident" id="h_MAsyozbjjZ" href="./13_dom.html#h_MAsyozbjjZ"></a>Позициониране и анимиране</h2>
<p><a class="p_ident" id="p_dDOfb5gw5J" href="./13_dom.html#p_dDOfb5gw5J"></a>Свойството <code>position</code> на <em>style</em> влияе на оформлението по мощен начин. По подразбиране той е на стойност 
<code>static</code>, което означава, че елемента е в нормална позиция в документа. Когато е настроен в  <code>relative</code>, елемента все още заема място в документа и със свойствата на <em>style</em> - <code>top</code> и <code>left</code> може да бъде преместен в сравнение с нормалното си място. Когато <code>position</code> е настроен на <code>absolute</code>, елемента се отстранява от нормалния поток на документа, което означава, че вече не заема място и може да бъде застъпен с други елементи. Също така, неговите <code>top</code> и <code>left</code> свойства могат да бъдат използвани за абсолютното му позициониране спрямо горния ляв ъгъл на най-близкия обхващащ елемент чиято <code>position</code> е <code>static</code> или по отношение на документа, ако няма обхващащ елемент.</p>
<p><a class="p_ident" id="p_TEJWNXCk6K" href="./13_dom.html#p_TEJWNXCk6K"></a>Можем да използваме това за да създадем една анимация. Следващият документ показва снимка на котка, която се движи в елипсовидна орбита.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_g5tHxqCsd3" href="./13_dom.html#c_g5tHxqCsd3"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span> <span class="cm-attribute">style</span>=<span class="cm-string">"text-align: center"</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">img</span> <span class="cm-attribute">src</span>=<span class="cm-string">"img/cat.png"</span> <span class="cm-attribute">style</span>=<span class="cm-string">"position: relative"</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">cat</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"img"</span>);
  <span class="cm-keyword">var</span> <span class="cm-variable">angle</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>, <span class="cm-variable">lastTime</span> <span class="cm-operator">=</span> <span class="cm-atom">null</span>;
  <span class="cm-keyword">function</span> <span class="cm-variable">animate</span>(<span class="cm-def">time</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable">lastTime</span> <span class="cm-operator">!=</span> <span class="cm-atom">null</span>)
      <span class="cm-variable">angle</span> <span class="cm-operator">+=</span> (<span class="cm-variable-2">time</span> <span class="cm-operator">-</span> <span class="cm-variable">lastTime</span>) <span class="cm-operator">*</span> <span class="cm-number">0.001</span>;
    <span class="cm-variable">lastTime</span> <span class="cm-operator">=</span> <span class="cm-variable-2">time</span>;
    <span class="cm-variable">cat</span>.<span class="cm-property">style</span>.<span class="cm-property">top</span> <span class="cm-operator">=</span> (<span class="cm-variable">Math</span>.<span class="cm-property">sin</span>(<span class="cm-variable">angle</span>) <span class="cm-operator">*</span> <span class="cm-number">20</span>) <span class="cm-operator">+</span> <span class="cm-string">"px"</span>;
    <span class="cm-variable">cat</span>.<span class="cm-property">style</span>.<span class="cm-property">left</span> <span class="cm-operator">=</span> (<span class="cm-variable">Math</span>.<span class="cm-property">cos</span>(<span class="cm-variable">angle</span>) <span class="cm-operator">*</span> <span class="cm-number">200</span>) <span class="cm-operator">+</span> <span class="cm-string">"px"</span>;
    <span class="cm-variable">requestAnimationFrame</span>(<span class="cm-variable">animate</span>);
  }
  <span class="cm-variable">requestAnimationFrame</span>(<span class="cm-variable">animate</span>);
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_HrW/6s5nxY" href="./13_dom.html#p_HrW/6s5nxY"></a>Картината е центрирана върху страницата и и е дадена <code>position</code> на <code>relative</code>. Ние многократно актуализираме стиловете <code>top</code> и <code>left</code> на картината за да я преместим.</p>
<p id="animationFrame"><a class="p_ident" id="p_YWJ84IIJ5r" href="./13_dom.html#p_YWJ84IIJ5r"></a>Сценарият използва <code>requestAnimationFrame</code> за да насочи <code>animate</code> функцията да тръгва, когато браузърът е готов да опресни екрана. Самата функция <code>animate</code> отново призовава <code>requestAnimationFrame</code> да планира следващата актуализация. Когато прозореца на браузъра е активен това ще кара актуализациите да се случват със скорост около 60 на секунда, което се стреми да осигури добре изглеждаща анимация.</p>
<p><a class="p_ident" id="p_V1ZyP92HDo" href="./13_dom.html#p_V1ZyP92HDo"></a>Ако просто обновяваме DOM в цикъл, страницата ще замръзне и нищо няма да се появи на екрана. Браузърите не актуализират своя дисплей докато програма на JavaScript работи, нито пък позволяват някакво взаимодействие с нея. Ето защо ни трябва <code>requestAnimationFrame</code>, той позволява на браузъра да разбере, когато сме готови за този момент и можем да продължим напред и да правим неща, които браузърите правят, например актуализиране на екрана и реагиране на действията на потребител.</p>
<p><a class="p_ident" id="p_65aVIJgoMb" href="./13_dom.html#p_65aVIJgoMb"></a>Нашата функция за анимация предава текущото време, като аргумент, който се сравнява със изминалия момент (променливата <code>lastTime</code>), за да осигури движението на котката в милисекунди да е стабилно, а движението на анимацията да е плавно. Ако тя просто премества фиксираната сума за всяка стъпка, движението ще се насече, ако например друга тежка задача се изпълнява на същия компютър ще спира да върви за част от секундата.</p>
<p id="sin_cos"><a class="p_ident" id="p_hfdwmxu8Y5" href="./13_dom.html#p_hfdwmxu8Y5"></a>Преместването в кръг се извършва с помощта на тригонометричните функции <code>Math.cos</code> и <code>Math.sin</code>. За тези от вас, които не са запознати с тях ще ги представим на кратко, тъй като от време на време ще се нуждаем от тях в тази книга.</p>
<p><a class="p_ident" id="p_4qsmOl5+5L" href="./13_dom.html#p_4qsmOl5+5L"></a><code>Math.cos</code> и <code>Math.sin</code> са полезни за намиране на точки, които са разположени в кръг около точка (0, 0) с радиус една мерна единица. И двете функции интерпретират своя аргумент, като позицията на този  кръг с нула обозначаваща точка в крайната дясна част на кръга, отивайки по часовниковата стрелка до 2π (около 6.28) вземайки разстоянието около целия кръг. <code>Math.cos</code> ни дава <em>x</em>-координата на точка, която съответства на позиция в окръжността, а с <code>Math.sin</code> получаваме <em>y</em>- координата. Позиции (или ъгли) над 2π или по-малко от 0 са валидни повторения на въртене, така че <em>a</em>+2π се отнася до същия ъгъл <em>a</em>.</p>
<div class="image">
  <img src="./media/cos_sin.svg" alt="Using cosine and sine to compute coordinates">
</div>
<p><a class="p_ident" id="p_XxeJZtQAlH" href="./13_dom.html#p_XxeJZtQAlH"></a>Кодът на анимацията на котката подържа брояч <code>angle</code> за текущия ъгъл на анимацията и увеличава стойността пропорционално на изминалото време всеки път, когато <code>animate</code> функцията се извиква. След това можем да използваме този ъгъл за да изчислим текущата позиция на елемента в изображението. Стила <code>top</code> се изчислява с <code>Math.sin</code> умножено по 20, което е вертикалния радиус на кръга. Стила <code>left</code> се изчислява с <code>Math.cos</code> умножено по 200, така че да получим малко по-широк кръг, отколкото висок, което води до елипсовидно движение.</p>
<p><a class="p_ident" id="p_/Yly9Ir9QF" href="./13_dom.html#p_/Yly9Ir9QF"></a>Имайте в предвид, че обикновено стиловете използват мерни единици. В този случай трябва да добавим <code>"px"</code> към числото за да кажем на браузъра, че използваме пиксели (а не сантиметри, инчове, “EMS” или други единици). Това лесно се забравя. Използване на номера, без мерни единици ще доведе до пренебрегване на вашия стил - освен ако въведения номер е 0, което винаги означава едно и също нещо независимо от неговата мерна единица.</p>
<h2><a class="h_ident" id="h_ErccPg/l98" href="./13_dom.html#h_ErccPg/l98"></a>Резюме</h2>
<p><a class="p_ident" id="p_kLcHWntN1r" href="./13_dom.html#p_kLcHWntN1r"></a>Програми на JavaScript могат да инспектират и месят в текущия документ, който браузъра показва използвайки структурата от данни наречена DOM. Тази структура от данни представлява модел на документа на браузъра  и  програма на JavaScript  може да го промени, за да се промени видимия документ.</p>
<p><a class="p_ident" id="p_7Ce58FA9bp" href="./13_dom.html#p_7Ce58FA9bp"></a>DOM е организиран, като дърво, в което елементите са подредени йерархично съгласно структурата на документа. Обектите представляващи елементи имат свойства, като <code>parentNode</code> и <code>childNodes</code>, които могат да се използват за придвижване по това дърво.</p>
<p><a class="p_ident" id="p_kklmAu08Ik" href="./13_dom.html#p_kklmAu08Ik"></a>Начинът, по който се показва документа може да бъде повлиян от стайлинг, както от пряко прикрепване на стилове към разклоненията така и от определяне на правила, които съответстват на определени точки от разклоненията. Има много различни свойства на стилове, като например <code>color</code> или <code>display</code>. JavaScript може да манипулира стила на елемента директно чрез своето свойство <code>style</code>.</p>
<h2><a class="h_ident" id="h_TcUD2vzyMe" href="./13_dom.html#h_TcUD2vzyMe"></a>Упражнения</h2>
<h3 id="exercise_table"><a class="h_ident" id="h_g/5UC3zznV" href="./13_dom.html#h_g/5UC3zznV"></a>Изграждане на таблица</h3>
<p><a class="p_ident" id="p_1dZtDT5P1x" href="./13_dom.html#p_1dZtDT5P1x"></a>В <a href="./06_object.html#tables">Глава 6</a> ние изградихме една текстова таблица. HTML прави оформлението на таблица малко по-лесно. Ето една HTML таблица изградена със следната структура:</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_svvDC/7YXO" href="./13_dom.html#c_svvDC/7YXO"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">table</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">tr</span><span class="cm-tag cm-bracket">&gt;</span>
    <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">th</span><span class="cm-tag cm-bracket">&gt;</span>name<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">th</span><span class="cm-tag cm-bracket">&gt;</span>
    <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">th</span><span class="cm-tag cm-bracket">&gt;</span>height<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">th</span><span class="cm-tag cm-bracket">&gt;</span>
    <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">th</span><span class="cm-tag cm-bracket">&gt;</span>country<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">th</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">tr</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">tr</span><span class="cm-tag cm-bracket">&gt;</span>
    <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">td</span><span class="cm-tag cm-bracket">&gt;</span>Kilimanjaro<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">td</span><span class="cm-tag cm-bracket">&gt;</span>
    <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">td</span><span class="cm-tag cm-bracket">&gt;</span>5895<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">td</span><span class="cm-tag cm-bracket">&gt;</span>
    <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">td</span><span class="cm-tag cm-bracket">&gt;</span>Tanzania<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">td</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">tr</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">table</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_5ddcb3G9fr" href="./13_dom.html#p_5ddcb3G9fr"></a>Всеки ред в <code>&lt;table&gt;</code> тага съдържа <code>&lt;tr&gt;</code> таг. Вътре в тези <code>&lt;tr&gt;</code> тагове можем да сложим клетъчни елементи: за позиция на клетки с (<code>&lt;th&gt;</code>) или (<code>&lt;td&gt;</code>) за нормални клетки.</p>
<p><a class="p_ident" id="p_BtYdHKzhgN" href="./13_dom.html#p_BtYdHKzhgN"></a>Същата структура от данни, които използвахме в <a href="./06_object.html#mountains">Глава 6</a> е отново на разположение <code>MOUNTAINS</code> променливата в пясъчника или може да бъде <a href="./code/mountains.js">изтеглена</a> от Интернет страницата.</p>
<p><a class="p_ident" id="p_BwmSeFluk3" href="./13_dom.html#p_BwmSeFluk3"></a>Напишете функция <code>buildTable</code>, която по даден масив от обекти, които всички имат еднакви качества, изгражда структура на DOM представляваща една таблица. В таблицата трябва да има <em>header</em> (заглавен) ред с имена увити в <code>&lt;th&gt;</code> елементи и трябва да има един следващ ред от обекти на масива с неговите стойности увити в <code>&lt;td&gt;</code> елементи.</p>
<p><a class="p_ident" id="p_2dqGRmSxc+" href="./13_dom.html#p_2dqGRmSxc+"></a>Функцията <code>Object.keys</code>, която връща масив съдържащ имената на свойствата, които един обект има, най-вероятно ще ви е от полза тука.</p>
<p><a class="p_ident" id="p_+D0CFGh4SM" href="./13_dom.html#p_+D0CFGh4SM"></a>След като имате основните клетки стоящи от дясно, подравнете клетките съдържащи числа чрез създаване на <code>style.textAlign</code> свойство за <code>"right"</code> (дясно).</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_L5p71bhscq" href="./13_dom.html#c_L5p71bhscq"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">style</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-comment">/* Defines a cleaner look for tables */</span>
  <span class="cm-tag">table</span>  { <span class="cm-property">border-collapse</span>: <span class="cm-atom">collapse</span>; }
  <span class="cm-tag">td</span>, <span class="cm-tag">th</span> { <span class="cm-property">border</span>: <span class="cm-number">1px</span> <span class="cm-atom">solid</span> <span class="cm-keyword">black</span>; <span class="cm-property">padding</span>: <span class="cm-number">3px</span> <span class="cm-number">8px</span>; }
  <span class="cm-tag">th</span>     { <span class="cm-property">text-align</span>: <span class="cm-atom">left</span>; }
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">style</span><span class="cm-tag cm-bracket">&gt;</span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">function</span> <span class="cm-variable">buildTable</span>(<span class="cm-def">data</span>) {
    <span class="cm-comment">// Your code here.</span>
  }

  <span class="cm-variable">document</span>.<span class="cm-property">body</span>.<span class="cm-property">appendChild</span>(<span class="cm-variable">buildTable</span>(<span class="cm-variable">MOUNTAINS</span>));
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<div class="solution"><div class="solution-text">
<p><a class="p_ident" id="p_kBIlV+ePxa" href="./13_dom.html#p_kBIlV+ePxa"></a>Използвайте <code>document.createElement</code> за да създадете нов елемент от разклонения, <code>document.createTextNode</code> за да създадете текстови разклонения и <code>appendChild</code> метода за да сложите едни разклонения в други разклонения.</p>
<p><a class="p_ident" id="p_Ur9PpOcYwp" href="./13_dom.html#p_Ur9PpOcYwp"></a>Трябва да минете с цикъл над ключовите имена веднъж за да попълните най-горния ред и след това отново за всеки обект в масива за изграждане на редовете с данни.</p>
<p><a class="p_ident" id="p_445AADzzaU" href="./13_dom.html#p_445AADzzaU"></a>Не забравяйте да върнете затварящия <code>&lt;table&gt;</code> елемент в края на функцията.</p>
</div></div>
<h3><a class="h_ident" id="h_VSftnyRTsV" href="./13_dom.html#h_VSftnyRTsV"></a>Elements by tag name</h3>
<p><a class="p_ident" id="p_8ZJVE0ewRe" href="./13_dom.html#p_8ZJVE0ewRe"></a>Методът <code>getElementsByTagName</code> връща всички дъщерни елементи с даденото име на тага. Приложете своя собствена версия на него, като редовна <em>nonmethod</em> функция, която използва едно разклонение и  <em>string</em> (името на тага), като аргументи и връща масив съдържащ всички елементи-деца на разклонението с даденото име на тага.</p>
<p><a class="p_ident" id="p_F3uW/zaQpy" href="./13_dom.html#p_F3uW/zaQpy"></a>За да намерите името на тага на даден елемент, използвайте свойството <code>tagName</code>. Но имайте в предвид, че това ще върне името на тага във главни букви. Използвайте <code>toLowerCase</code> или <code>toUpperCase</code> методи на <em>string</em> за да компенсирате това.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_+uC7zXcyRj" href="./13_dom.html#c_+uC7zXcyRj"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">h1</span><span class="cm-tag cm-bracket">&gt;</span>Heading with a <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">span</span><span class="cm-tag cm-bracket">&gt;</span>span<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">span</span><span class="cm-tag cm-bracket">&gt;</span> element.<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">h1</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>A paragraph with <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">span</span><span class="cm-tag cm-bracket">&gt;</span>one<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">span</span><span class="cm-tag cm-bracket">&gt;</span>, <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">span</span><span class="cm-tag cm-bracket">&gt;</span>two<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">span</span><span class="cm-tag cm-bracket">&gt;</span>
  spans.<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">function</span> <span class="cm-variable">byTagName</span>(<span class="cm-def">node</span>, <span class="cm-def">tagName</span>) {
    <span class="cm-comment">// Your code here.</span>
  }

  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">byTagName</span>(<span class="cm-variable">document</span>.<span class="cm-property">body</span>, <span class="cm-string">"h1"</span>).<span class="cm-property">length</span>);
  <span class="cm-comment">// → 1</span>
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">byTagName</span>(<span class="cm-variable">document</span>.<span class="cm-property">body</span>, <span class="cm-string">"span"</span>).<span class="cm-property">length</span>);
  <span class="cm-comment">// → 3</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">para</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"p"</span>);
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">byTagName</span>(<span class="cm-variable">para</span>, <span class="cm-string">"span"</span>).<span class="cm-property">length</span>);
  <span class="cm-comment">// → 2</span>
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<div class="solution"><div class="solution-text">
<p><a class="p_ident" id="p_TC2y6C3e1f" href="./13_dom.html#p_TC2y6C3e1f"></a>Решението най-лесно се изразява с рекурсивна функция, подобна на <a href="./13_dom.html#talksAbout"><code>talksAbout</code></a> функцията определена по-рано в тази глава.</p>
<p><a class="p_ident" id="p_snKMJh0e7N" href="./13_dom.html#p_snKMJh0e7N"></a>Можете да извикате <code>byTagname</code> от вътре рекурсивно конкатенирайки получените масиви за производство на продукцията. За по-ефективен подход, дефинирайте една вътрешна функция, която извиква себе си рекурсивно и има достъп до масива на променливите дефинирани във външната функция, в която тя може да добави съвпадащите елементи, които намери. Не забравяйте да извикате вътрешната функция веднъж от външната функция.</p>
<p><a class="p_ident" id="p_Zi3ayOqWyD" href="./13_dom.html#p_Zi3ayOqWyD"></a>Рекурсивната функция трябва да провери вида на разклонението. Тука ние се интересуваме само от <code>node type - 1 (document.ELEMENT_NODE)</code>. За такива разклонения ни трябва цикъл, с който да преминем над децата и за всяко дете да видим дали то съответства на заявката, като същевременно прави рекурсивно извикване върху него, за да инспектира своите собствени деца.</p>
</div></div>
<h3><a class="h_ident" id="h_ye4Ws9YmoI" href="./13_dom.html#h_ye4Ws9YmoI"></a>Шапката на котката</h3>
<p><a class="p_ident" id="p_6r1baDVOSE" href="./13_dom.html#p_6r1baDVOSE"></a>Разширете анимацията на котката дефинирана <a href="./13_dom.html#animation">по-рано</a>, така че котката и шапката (<code>&lt;img src="img/hat.png"&gt;</code>) да обикалят в орбита от противоположните страни на елипсата.</p>
<p><a class="p_ident" id="p_2gTA+NB5av" href="./13_dom.html#p_2gTA+NB5av"></a>Или направи шапка върху главата на котката. Или промени анимацията по някакъв друг интересен начин.</p>
<p><a class="p_ident" id="p_kC6i5Avza+" href="./13_dom.html#p_kC6i5Avza+"></a>За да бъдат по-лесно позиционирани множество обекти, е може би добра идея да се премине към абсолютно позициониране. Това означава, че <code>top</code> и <code>left</code> частта са <em>relative</em> спрямо горния ляв ъгъл на документа. За да избегнете използването на отрицателни координати, можете просто да добавите фиксиран брой пиксели към стойностите на позициите.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_2LqaWLIGPR" href="./13_dom.html#c_2LqaWLIGPR"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">img</span> <span class="cm-attribute">src</span>=<span class="cm-string">"img/cat.png"</span> <span class="cm-attribute">id</span>=<span class="cm-string">"cat"</span> <span class="cm-attribute">style</span>=<span class="cm-string">"position: absolute"</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">img</span> <span class="cm-attribute">src</span>=<span class="cm-string">"img/hat.png"</span> <span class="cm-attribute">id</span>=<span class="cm-string">"hat"</span> <span class="cm-attribute">style</span>=<span class="cm-string">"position: absolute"</span><span class="cm-tag cm-bracket">&gt;</span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">cat</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"#cat"</span>);
  <span class="cm-keyword">var</span> <span class="cm-variable">hat</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"#hat"</span>);
  <span class="cm-comment">// Your code here.</span>
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<nav>
  <a href="./12_browser.html" title="previous chapter">◀</a>
  <a href="./index.html" title="cover">◆</a>
  <a href="./14_event.html" title="next chapter">▶</a>
</nav>
</article>
</body></html>
<!DOCTYPE html>
<!-- saved from url=(0043)./14_event.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <title>Handling Events :: Eloquent JavaScript</title>
  <link rel="stylesheet" href="./media/codemirror.css">
  <script src="./media/acorn_codemirror.js"></script>
  <link rel="stylesheet" href="./media/ejs.css">
  <script src="./media/sandbox.js"></script>
  <script src="./media/ejs.js"></script>
  <script>var chapNum = 14;</script>
</head>

<body><article>
<nav>
  <a href="./13_dom.html" title="previous chapter">◀</a>
  <a href="./index.html" title="cover">◆</a>
  <a href="./15_game.html" title="next chapter">▶</a>
</nav>

<h1><div class="chap_num">Глава 14</div>Боравене със  събития</h1>
<blockquote>
<p><a class="p_ident" id="p_9vGtY0kynX" href="./14_event.html#p_9vGtY0kynX"></a>Вие имате власт над ума - не върху събитията. Осъзнайте това и ще намерите сили.”</p>
 <footer>Marcus Aurelius, <cite>Медитации</cite></footer>
</blockquote>
<p><a class="p_ident" id="p_/DC8VWovoV" href="./14_event.html#p_/DC8VWovoV"></a>Някои програми работят с пряко подаване от потребителя, като например взаимодействие с мишка и клавиатура. Графикът и редът на това въвеждане не може да се прогнозира по-рано. Това изисква по-различен подход за контрол на потока, от този който използвахме до сега.</p>
<h2><a class="h_ident" id="h_HQoLxG2r2l" href="./14_event.html#h_HQoLxG2r2l"></a>Манипулиране  на събития</h2>
<p><a class="p_ident" id="p_4crjoEGjCE" href="./14_event.html#p_4crjoEGjCE"></a>Представете си един интерфейс, където единственият начин да разберете дали е натиснат клавиш от клавиатурата, е да разберете сегашното състояние на този клавиш. За да може да се реагира на натискане на клавишите, ще трябва постоянно да следите състоянието на клавиша, когато е натиснат и когато е пуснат отново. Това би било опасно за извършване на други интензивни времеви изчисления, тъй като рискувате да пропуснете натискане на клавиш.</p>
<p><a class="p_ident" id="p_gL+2BzAZqa" href="./14_event.html#p_gL+2BzAZqa"></a>Това е редът, по който се обработва входа с по-примитивни машини. Стъпка на горе за хардуера или операционната система е да забележи натискане на клавиш и поставянето му в режим на изчакване. Една програма може след това периодично да проверява чакащите на опашката, за нови събития и да реагира на това, което намира там.</p>
<p><a class="p_ident" id="p_llZbht+m+p" href="./14_event.html#p_llZbht+m+p"></a>Разбира се, тя трябва да помни, че трябва  да прегледа опашката и да го прави често, защото всяко време между натиснатия клавиш и забелязването му от програмата, ще накара софтуера да чувства липса на реакция. Този подход се нарича <em>polling</em> (избирателен). Повечето програмисти го избягват, когато е възможно.</p>
<p><a class="p_ident" id="p_yR0Vf6qqc8" href="./14_event.html#p_yR0Vf6qqc8"></a>По-добър механизъм за основна система е да дадем шанс на кода да реагира на събития, когато те се появят. Браузърите ни позволяват да регистрираме функции, които да <em>handlers</em> (обработват) конкретни събития.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_KzXoDsn+8z" href="./14_event.html#c_KzXoDsn+8z"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>Click this document to activate the handler.<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-variable">addEventListener</span>(<span class="cm-string">"click"</span>, <span class="cm-keyword">function</span>() {
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"You clicked!"</span>);
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_MOjheGCW5Y" href="./14_event.html#p_MOjheGCW5Y"></a>Функцията <code>addEventListener</code> регистрира извикване към втория си аргумент, когато събитието описано в първия аргумент се случи.</p>
<h2><a class="h_ident" id="h_Kx1VwAV7ei" href="./14_event.html#h_Kx1VwAV7ei"></a>Събития  и  DOM  разклонения</h2>
<p><a class="p_ident" id="p_OFueY9yZeF" href="./14_event.html#p_OFueY9yZeF"></a>Всяко манипулирано събитие в браузъра се регистрира в контекста. Когато извикаме <code>addEventListener</code>, както показахме по-рано, ние го извикваме, като метод за целия прозорец, защото в браузъра глобалният обхват е еквивалентен на <code>window</code> обект. Всеки DOM елемент има свой собствен <code>addEventListener</code> метод, който ни позволява да го използваме специално върху този елемент.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_MGuoCFu2he" href="./14_event.html#c_MGuoCFu2he"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">button</span><span class="cm-tag cm-bracket">&gt;</span>Click me<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">button</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>No handler here.<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">button</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"button"</span>);
  <span class="cm-variable">button</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"click"</span>, <span class="cm-keyword">function</span>() {
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Button clicked."</span>);
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_dN0xA6sZi2" href="./14_event.html#p_dN0xA6sZi2"></a>Примерът прикрепва манипулатор към разклонението на бутона. По този начин, кликването върху бутона причинява стартиране на манипулатора, докато останалата част от документа не го прави.</p>
<p><a class="p_ident" id="p_baR6w+cVeA" href="./14_event.html#p_baR6w+cVeA"></a>Задаване на <code>onclick</code> атрибут върху разклонение има подобен ефект. Но едно разклонение може да има само един <code>onclick</code> атрибут, така че можем да регистрираме само един манипулатор на разклонение по този начин. Метода <code>addEventListener</code> ни позволява добавяне на произволен брой манипулатори, така че да не може случайно да се замени с манипулатор, който вече е бил регистриран.</p>
<p><a class="p_ident" id="p_/QIdzEWfHg" href="./14_event.html#p_/QIdzEWfHg"></a>Метода <code>removeEventListener</code> се извиква с аргументи, подобни на <code>addEventListener</code>, за премахване на манипулатор.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_r0IM6NVZtn" href="./14_event.html#c_r0IM6NVZtn"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">button</span><span class="cm-tag cm-bracket">&gt;</span>Act-once button<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">button</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">button</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"button"</span>);
  <span class="cm-keyword">function</span> <span class="cm-variable">once</span>() {
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Done."</span>);
    <span class="cm-variable">button</span>.<span class="cm-property">removeEventListener</span>(<span class="cm-string">"click"</span>, <span class="cm-variable">once</span>);
  }
  <span class="cm-variable">button</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"click"</span>, <span class="cm-variable">once</span>);
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_Y/CadjfuHR" href="./14_event.html#p_Y/CadjfuHR"></a>За да можем да опишем функцията манипулатор, ние и даваме име (като, <code>once</code>), така че да можем да я подадем, както на <code>addEventListener</code> и на <code>removeEventListener</code>.</p>
<h2><a class="h_ident" id="h_0d6qd0WrDY" href="./14_event.html#h_0d6qd0WrDY"></a>Обекти  на  събития</h2>
<p><a class="p_ident" id="p_xMV45J9tPM" href="./14_event.html#p_xMV45J9tPM"></a>Върпреки, че го игнорирахме в предишните примери, функцията на манипулатора на събитие приема аргумент: цел на събитието. Тази цел ни дава допълнителна информация за събитието. Например, ако искаме да знаем, кой бутон на мишката е натиснат, можем да разгледаме обекта на събитието със <em>which</em> свойство.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_eORczkJUsy" href="./14_event.html#c_eORczkJUsy"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">button</span><span class="cm-tag cm-bracket">&gt;</span>Click me any way you want<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">button</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">button</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"button"</span>);
  <span class="cm-variable">button</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"mousedown"</span>, <span class="cm-keyword">function</span>(<span class="cm-def">event</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">event</span>.<span class="cm-property">which</span> <span class="cm-operator">==</span> <span class="cm-number">1</span>)
      <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Left button"</span>);
    <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">event</span>.<span class="cm-property">which</span> <span class="cm-operator">==</span> <span class="cm-number">2</span>)
      <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Middle button"</span>);
    <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">event</span>.<span class="cm-property">which</span> <span class="cm-operator">==</span> <span class="cm-number">3</span>)
      <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Right button"</span>);
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_6Vk6va5Rnz" href="./14_event.html#p_6Vk6va5Rnz"></a>Информацията съхранена в обекта на събитието се различава по вида на събитието. Ние ще обсъдим различните видове по-късно в тази глава. Обекта има <code>type</code> свойство, което съдържа <em>string</em> за индентифициране на събитието (например, <code>"click"</code> или <code>"mousedown"</code>).</p>
<h2><a class="h_ident" id="h_NEhx0cDpml" href="./14_event.html#h_NEhx0cDpml"></a>Разпростиране</h2>
<p><a class="p_ident" id="p_AMEe+Oabfh" href="./14_event.html#p_AMEe+Oabfh"></a>Манипулаторите на събития регистрирани на разклонения с деца също ще получат някои събития, които се случват на децата. Ако един бутон вътре в параграф се натисне, манипулатора на събитието на параграфа също ще получи клик-събитие.</p>
<p><a class="p_ident" id="p_UBfEVzqY/E" href="./14_event.html#p_UBfEVzqY/E"></a>Но ако и бутона и параграфа имат манипулатор, тогава по-специфичния манипулатор - този на бутона, ще отиде на първо място. Събитията се разпространяват навън от разклонението, където се е случило към родителското разклонение и до корена на документа. Накрая, след като всички манипулатори регистрирани по конкретно разклонение са имали свой ред манипулатори, регистрирани на целия прозорец получават шанс да отговорят на събитието.</p>
<p><a class="p_ident" id="p_mgXPeV1qcP" href="./14_event.html#p_mgXPeV1qcP"></a>Във всеки един момент може да извикаме метода <code>stopPropagation</code> върху обекта на събитието, за да предотвратим манипулаторите по на горе да получат събитието.
Това може да бъде полезно, например, когато имаме бутон в друг кликнат елемент и не искаме с кликванията на бутона да активираме клик поведение на външния елемент.</p>
<p><a class="p_ident" id="p_qKf3t2phih" href="./14_event.html#p_qKf3t2phih"></a>Следващият пример регистрира <code>"mousedown"</code> манипулатори на бутон и параграфът около него. Когато кликнете с десния бутон на мишката, се извиква <code>stopPropagation</code>, което ще попречи на манипулатора на параграфа да реагира. При натискане на друг бутон на мишката, манипулаторите и на двата ще работят.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_UbBM/GwcX6" href="./14_event.html#c_UbBM/GwcX6"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>A paragraph with a <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">button</span><span class="cm-tag cm-bracket">&gt;</span>button<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">button</span><span class="cm-tag cm-bracket">&gt;</span>.<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">para</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"p"</span>);
  <span class="cm-keyword">var</span> <span class="cm-variable">button</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"button"</span>);
  <span class="cm-variable">para</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"mousedown"</span>, <span class="cm-keyword">function</span>() {
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Handler for paragraph."</span>);
  });
  <span class="cm-variable">button</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"mousedown"</span>, <span class="cm-keyword">function</span>(<span class="cm-def">event</span>) {
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Handler for button."</span>);
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">event</span>.<span class="cm-property">which</span> <span class="cm-operator">==</span> <span class="cm-number">3</span>)
      <span class="cm-variable-2">event</span>.<span class="cm-property">stopPropagation</span>();
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_NocTrrs2K+" href="./14_event.html#p_NocTrrs2K+"></a>Повечето обекти на събития имат <code>target</code> свойство, което се отнася до разклонението от което произхождат. Можем да използваме това свойство за да гарантираме, че при случайно боравене с нещо, ще спре разпространението навън от това разклонение.</p>
<p><a class="p_ident" id="p_RrFjk/g1ly" href="./14_event.html#p_RrFjk/g1ly"></a>Също така е възможно да се използва метода <code>target</code> да хвърли широка мрежа за определяне на типа на събитие. Например, ако имаме едно разклонение съдържащо дълъг списък от бутони, може да е по-удобно да регистрираме един клик-манипулатор на външното разклонение и да използваме <code>target</code> свойството, за да разберем, кога е натиснат един бутон, а не да регистрираме индивидуални манипулатори за всеки бутон.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_+CJF+cvKTm" href="./14_event.html#c_+CJF+cvKTm"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">button</span><span class="cm-tag cm-bracket">&gt;</span>A<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">button</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">button</span><span class="cm-tag cm-bracket">&gt;</span>B<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">button</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">button</span><span class="cm-tag cm-bracket">&gt;</span>C<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">button</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-variable">document</span>.<span class="cm-property">body</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"click"</span>, <span class="cm-keyword">function</span>(<span class="cm-def">event</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">event</span>.<span class="cm-property">target</span>.<span class="cm-property">nodeName</span> <span class="cm-operator">==</span> <span class="cm-string">"BUTTON"</span>)
      <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Clicked"</span>, <span class="cm-variable-2">event</span>.<span class="cm-property">target</span>.<span class="cm-property">textContent</span>);
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<h2><a class="h_ident" id="h_GaHJsztrot" href="./14_event.html#h_GaHJsztrot"></a>Действие по подразбиране</h2>
<p><a class="p_ident" id="p_mNZd3hJWtB" href="./14_event.html#p_mNZd3hJWtB"></a>Много събития имат действие по подразбиране свързано с тях. Ако кликнете върху линк връзка, ще бъдете заведени към целата на връзката. Ако натиснете стрелката надолу, браузърът ще превърти страницата на долу. Ако щракнете с десния бутон, ще получите контекстно меню и т.н.</p>
<p><a class="p_ident" id="p_QdllRyXgOw" href="./14_event.html#p_QdllRyXgOw"></a>За повечето видове събития, модификаторите занимаващи се със събития в JavaScript се извикват преди да се извърши поведението по подразбиране. Ако модификатора не иска нормалното поведение да се случи, обикновено, защото той вече се е погрижил за обработката на събитието, може да извикаме метода <code>preventDefault</code> върху обекта на събитието. </p>
<p><a class="p_ident" id="p_qt5hvvY54m" href="./14_event.html#p_qt5hvvY54m"></a>Той може да се използва за прилагане на собствени клавишни комбинации или контекстно меню. Може също така да бъде използван неприятно за да се меси противно на поведението, което потребителите очакват. Например, това е линк, който не може да бъде последван:</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_tau6Rjumd3" href="./14_event.html#c_tau6Rjumd3"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">a</span> <span class="cm-attribute">href</span>=<span class="cm-string">"https://developer.mozilla.org/"</span><span class="cm-tag cm-bracket">&gt;</span>MDN<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">a</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">link</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"a"</span>);
  <span class="cm-variable">link</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"click"</span>, <span class="cm-keyword">function</span>(<span class="cm-def">event</span>) {
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Nope."</span>);
    <span class="cm-variable-2">event</span>.<span class="cm-property">preventDefault</span>();
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_nc872RiHdX" href="./14_event.html#p_nc872RiHdX"></a>Опитайте се да не правите такива неща, освен ако нямате основателна причина за това. За хората, които използват вашата страница може да бъде неприятно, когато поведението, което очакват се окаже счупено.</p>
<p><a class="p_ident" id="p_KMgK6E70da" href="./14_event.html#p_KMgK6E70da"></a>В зависимост от браузъра, някои събития не могат да бъдат засечени. На Chrome, например, клавишни комбинации за затваряне на текущия раздел (като, Cthl-W или  Command-W) не могат да се обработват от JavaScript.</p>
<h2><a class="h_ident" id="h_974t15Z9oa" href="./14_event.html#h_974t15Z9oa"></a>Клавишни  събития</h2>
<p><a class="p_ident" id="p_dJaRso8RxV" href="./14_event.html#p_dJaRso8RxV"></a>Когато е натиснат клавиш от клавиатурата, на браузъра се  предизвиква <code>"keydown"</code> събитие. Когато е освободен - <code>"keyup"</code> събитие.</p>
<pre data-language="text/html" class="snippet cm-s-default" data-focus="true"><a class="c_ident" id="c_HHTiM1P8JU" href="./14_event.html#c_HHTiM1P8JU"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>This page turns violet when you hold the V key.<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-variable">addEventListener</span>(<span class="cm-string">"keydown"</span>, <span class="cm-keyword">function</span>(<span class="cm-def">event</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">event</span>.<span class="cm-property">keyCode</span> <span class="cm-operator">==</span> <span class="cm-number">86</span>)
      <span class="cm-variable">document</span>.<span class="cm-property">body</span>.<span class="cm-property">style</span>.<span class="cm-property">background</span> <span class="cm-operator">=</span> <span class="cm-string">"violet"</span>;
  });
  <span class="cm-variable">addEventListener</span>(<span class="cm-string">"keyup"</span>, <span class="cm-keyword">function</span>(<span class="cm-def">event</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">event</span>.<span class="cm-property">keyCode</span> <span class="cm-operator">==</span> <span class="cm-number">86</span>)
      <span class="cm-variable">document</span>.<span class="cm-property">body</span>.<span class="cm-property">style</span>.<span class="cm-property">background</span> <span class="cm-operator">=</span> <span class="cm-string">""</span>;
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_gQnz+6p78i" href="./14_event.html#p_gQnz+6p78i"></a>Въпреки името си <code>"keydown"</code>, ефекта не е само, когато клавишът е физически натиснат. Когато е натиснат клавиш и се държи натиснат, събитието отново се предизвиква всеки път с клавишното повторение. По някога, например, ако искате да се увеличи ускорението на герой от игра с натискането на клавиша със стрелка и да го намалите с пускането на този клавиш, вие трябва да внимавате  да не го увеличите прекалено много с всяко клавишно повторение и да се окажете пред неволно огромни стойности..</p>
<p><a class="p_ident" id="p_YN1AGK2x1E" href="./14_event.html#p_YN1AGK2x1E"></a>В предишния пример използвахме свойството <code>keyCode</code> на обекта на събитието. С него можем да определим, кой клавиш е натиснат или освободен. За съжаление, не винаги е ясно, как да се преведе номера на клавишния код до действителния клавиш.</p>
<p><a class="p_ident" id="p_y/Pr/lCtnH" href="./14_event.html#p_y/Pr/lCtnH"></a>За буквени и цифрови клавиши, асоциирания клавишен код ще бъде символ от Unicode таблицата, свързан с (с главната буква) буквата или цифрата изписани върху него. Метода <code>charCodeAt</code> на strings ни дава възможност да се запознаем с него.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_fxVTaBPpbk" href="./14_event.html#c_fxVTaBPpbk"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Violet"</span>.<span class="cm-property">charCodeAt</span>(<span class="cm-number">0</span>));
<span class="cm-comment">// → 86</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"1"</span>.<span class="cm-property">charCodeAt</span>(<span class="cm-number">0</span>));
<span class="cm-comment">// → 49</span></pre>
<p><a class="p_ident" id="p_HVPFsxHIiv" href="./14_event.html#p_HVPFsxHIiv"></a>Други клавиши имат по-малко предсказуеми клавишни кодове. Най добрият начин да намерите нужния ви код е да експериментирате - направете регистър на манипулатора за клавишното събитие, където да събирате кодовете на клавишите и натиснете клавиша, който ви интересува.</p>
<p><a class="p_ident" id="p_4cdQPevWxW" href="./14_event.html#p_4cdQPevWxW"></a>Модифициращи клавиши, като Shift, Ctrl, Alt и Meta (Command на Mac) генерират клавишни събития, точно както нормални клaвиши. Но когато търсите клавишни комбинации, може да разберете дали тези клавиши сa натиснати, като погледнете в <code>shiftKey</code>, <code>ctrlKey</code>, <code>altKey</code> и <code>metaKey</code> свойствата на клавиатурата и на мишка - събитията.</p>
<pre data-language="text/html" class="snippet cm-s-default" data-focus="true"><a class="c_ident" id="c_o9zPQGAwwa" href="./14_event.html#c_o9zPQGAwwa"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>Press Ctrl-Space to continue.<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-variable">addEventListener</span>(<span class="cm-string">"keydown"</span>, <span class="cm-keyword">function</span>(<span class="cm-def">event</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">event</span>.<span class="cm-property">keyCode</span> <span class="cm-operator">==</span> <span class="cm-number">32</span> <span class="cm-operator">&amp;&amp;</span> <span class="cm-variable-2">event</span>.<span class="cm-property">ctrlKey</span>)
      <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Continuing!"</span>);
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_p/+N5nU+rr" href="./14_event.html#p_p/+N5nU+rr"></a>Събитията <code>"keydown"</code> и <code>"keyup"</code> дават информация за физическия клавиш, който е натиснат. Но какво става, ако се интересуваме от действително въведения текст? Вземане на текст - символите от клавишните кодове е неудобно. Вместо това съществува едно събитие <code>"keypress"</code> чийто ефект е, като <code>"keydown"</code> ( и многократен, както при <code>"keydown"</code>, когато е задържан клавиша), но само за клавиши, които въвеждат  символи. Свойството <code>charCode</code> в обекта на събитието съдържа код, който може да се тълкува, като код с Unicode символ. Можем да използваме <code>String.fromCharCode</code> функцията за да превърнем този код в реален единичен <em>string</em> символ</p>
<pre data-language="text/html" class="snippet cm-s-default" data-focus="true"><a class="c_ident" id="c_pIZLxVk8Ol" href="./14_event.html#c_pIZLxVk8Ol"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>Focus this page and type something.<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-variable">addEventListener</span>(<span class="cm-string">"keypress"</span>, <span class="cm-keyword">function</span>(<span class="cm-def">event</span>) {
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">String</span>.<span class="cm-property">fromCharCode</span>(<span class="cm-variable-2">event</span>.<span class="cm-property">charCode</span>));
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_EHGULml9MQ" href="./14_event.html#p_EHGULml9MQ"></a> DOM разклонението, от където идва ключовото събитие зависи от елемента, който е фокусиран, когато клавиша е натиснат. Нормални разклонения не могат да бъдат фокусирани (освен ако не им дадем <code>tabindex</code> атрибут), но такива неща, като линкове, бутони и форми -полета могат. Ще се върнем на форми - полета в <a href="./18_forms.html#forms">Глава 18</a>. Когато нищо по-специално не е фокусирано, <code>document.body</code> действа, като целево разклонение на клавишно събитие.</p>
<h2><a class="h_ident" id="h_D5iwImkmyt" href="./14_event.html#h_D5iwImkmyt"></a>Кликвания  на  мишката</h2>
<p><a class="p_ident" id="p_zZHDVhEhYY" href="./14_event.html#p_zZHDVhEhYY"></a>Натискането на бутона на мишката, също причинява редица прояви на ефекти. Събитията <code>"mousedown"</code> и <code>"mouseup"</code> са подобни на <code>"keydown"</code> и <code>"keyup"</code> ефектите, когато се натисне бутон или е освободен. Това се случва на DOM разклонения, които са непосредствено под показалеца на мишката, когато се появи събитието.</p>
<p><a class="p_ident" id="p_vxFLT2fw8e" href="./14_event.html#p_vxFLT2fw8e"></a>След <code>"mouseup"</code> събитието, ефекта на <code>"click"</code> събитието е върху по -специфично разклонение, което съдържа и двете: пресата и освобождаването на бутона. Например, ако натиснем бутона на мишката върху един параграф, а след това преместим показалеца върху друг параграф и отпуснем бутона <code>"click"</code>, събитието ще се случи на елемента, които съдържа тези два параграфа.</p>
<p><a class="p_ident" id="p_gzmmLlVcMF" href="./14_event.html#p_gzmmLlVcMF"></a>Ако две кликвания се случат близо едно до друго, ефекта на събитието <code>"dblclick"</code> (двойно кликване) ще се случи след второто кликване.</p>
<p><a class="p_ident" id="p_V3QuKrAk2Z" href="./14_event.html#p_V3QuKrAk2Z"></a>За да получите точна информация за мястото, където дадено събитие на мишката се случва, може да погледнете неговите <code>pageX</code> и <code>pageY</code> свойства, които съдържат координатите на събитието(в пиксели), отнасящи се към горния ляв ъгъл на документа.</p>
<p id="mouse_drawing"><a class="p_ident" id="p_A7YDC3hfu1" href="./14_event.html#p_A7YDC3hfu1"></a>Следващият пример, изпълнява една проста чертожна програма. Всеки път, когато щракнете на документа, той добавя една точка под показалеца на мишката. Вижте <a href="./19_paint.html#paint">Глава 19 </a> за по-сложна чертожна програма.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_nEakRU/58f" href="./14_event.html#c_nEakRU/58f"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">style</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-tag">body</span> {
    <span class="cm-property">height</span>: <span class="cm-number">200px</span>;
    <span class="cm-property">background</span>: <span class="cm-keyword">beige</span>;
  }
  <span class="cm-qualifier">.dot</span> {
    <span class="cm-property">height</span>: <span class="cm-number">8px</span>; <span class="cm-property">width</span>: <span class="cm-number">8px</span>;
    <span class="cm-property">border-radius</span>: <span class="cm-number">4px</span>; <span class="cm-comment">/* rounds corners */</span>
    <span class="cm-property">background</span>: <span class="cm-keyword">blue</span>;
    <span class="cm-property">position</span>: <span class="cm-atom">absolute</span>;
  }
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">style</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-variable">addEventListener</span>(<span class="cm-string">"click"</span>, <span class="cm-keyword">function</span>(<span class="cm-def">event</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">dot</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">createElement</span>(<span class="cm-string">"div"</span>);
    <span class="cm-variable-2">dot</span>.<span class="cm-property">className</span> <span class="cm-operator">=</span> <span class="cm-string">"dot"</span>;
    <span class="cm-variable-2">dot</span>.<span class="cm-property">style</span>.<span class="cm-property">left</span> <span class="cm-operator">=</span> (<span class="cm-variable-2">event</span>.<span class="cm-property">pageX</span> <span class="cm-operator">-</span> <span class="cm-number">4</span>) <span class="cm-operator">+</span> <span class="cm-string">"px"</span>;
    <span class="cm-variable-2">dot</span>.<span class="cm-property">style</span>.<span class="cm-property">top</span> <span class="cm-operator">=</span> (<span class="cm-variable-2">event</span>.<span class="cm-property">pageY</span> <span class="cm-operator">-</span> <span class="cm-number">4</span>) <span class="cm-operator">+</span> <span class="cm-string">"px"</span>;
    <span class="cm-variable">document</span>.<span class="cm-property">body</span>.<span class="cm-property">appendChild</span>(<span class="cm-variable-2">dot</span>);
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_qAqiJ6l3wp" href="./14_event.html#p_qAqiJ6l3wp"></a>Свойствата <code>clientX</code> и <code>clientY</code> са подобни на <code>pageX</code> и <code>pageY</code>, но относно тази част на документа, която в момента се движи заедно с изгледа. Това може да бъде полезно, когато се сравняват координатите на мишката с координатите върнати от <code>getBoundingClientRect</code>, който също връща демонстрационен  прозорец с относителни координати.</p>
<h2><a class="h_ident" id="h_XojjiOmg7v" href="./14_event.html#h_XojjiOmg7v"></a>Движение  на  мишката</h2>
<p><a class="p_ident" id="p_Yjy/EtP24n" href="./14_event.html#p_Yjy/EtP24n"></a>Всеки път, когато показалецът на мишката се движи се създават ефекти на <code>"mousemove"</code> събития. Това събитие може да се използва за проследяване на позицията на мишката. Една обща ситуация, в която това е полезно е при изпълнението на някаква форма на плъзгаща (<em>drag</em>) функционалност за мишката.</p>
<p><a class="p_ident" id="p_Z1h4BQYT0/" href="./14_event.html#p_Z1h4BQYT0/"></a>Както например, следната програма показва бар и създава събитие манипулатор, така че при плъзване наляво или на дясно прави този бар по-дълъг или по-къс.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_m6nbicg7BJ" href="./14_event.html#c_m6nbicg7BJ"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>Drag the bar to change its width:<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">div</span> <span class="cm-attribute">style</span>=<span class="cm-string">"background: orange; width: 60px; height: 20px"</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">div</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">lastX</span>; <span class="cm-comment">// Tracks the last observed mouse X position</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">rect</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"div"</span>);
  <span class="cm-variable">rect</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"mousedown"</span>, <span class="cm-keyword">function</span>(<span class="cm-def">event</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">event</span>.<span class="cm-property">which</span> <span class="cm-operator">==</span> <span class="cm-number">1</span>) {
      <span class="cm-variable">lastX</span> <span class="cm-operator">=</span> <span class="cm-variable-2">event</span>.<span class="cm-property">pageX</span>;
      <span class="cm-variable">addEventListener</span>(<span class="cm-string">"mousemove"</span>, <span class="cm-variable">moved</span>);
      <span class="cm-variable-2">event</span>.<span class="cm-property">preventDefault</span>(); <span class="cm-comment">// Prevent selection</span>
    }
  });

  <span class="cm-keyword">function</span> <span class="cm-variable">buttonPressed</span>(<span class="cm-def">event</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">event</span>.<span class="cm-property">buttons</span> <span class="cm-operator">==</span> <span class="cm-atom">null</span>)
      <span class="cm-keyword">return</span> <span class="cm-variable-2">event</span>.<span class="cm-property">which</span> <span class="cm-operator">!=</span> <span class="cm-number">0</span>;
    <span class="cm-keyword">else</span>
      <span class="cm-keyword">return</span> <span class="cm-variable-2">event</span>.<span class="cm-property">buttons</span> <span class="cm-operator">!=</span> <span class="cm-number">0</span>;
  }
  <span class="cm-keyword">function</span> <span class="cm-variable">moved</span>(<span class="cm-def">event</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable">buttonPressed</span>(<span class="cm-variable-2">event</span>)) {
      <span class="cm-variable">removeEventListener</span>(<span class="cm-string">"mousemove"</span>, <span class="cm-variable">moved</span>);
    } <span class="cm-keyword">else</span> {
      <span class="cm-keyword">var</span> <span class="cm-def">dist</span> <span class="cm-operator">=</span> <span class="cm-variable-2">event</span>.<span class="cm-property">pageX</span> <span class="cm-operator">-</span> <span class="cm-variable">lastX</span>;
      <span class="cm-keyword">var</span> <span class="cm-def">newWidth</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">max</span>(<span class="cm-number">10</span>, <span class="cm-variable">rect</span>.<span class="cm-property">offsetWidth</span> <span class="cm-operator">+</span> <span class="cm-variable-2">dist</span>);
      <span class="cm-variable">rect</span>.<span class="cm-property">style</span>.<span class="cm-property">width</span> <span class="cm-operator">=</span> <span class="cm-variable-2">newWidth</span> <span class="cm-operator">+</span> <span class="cm-string">"px"</span>;
      <span class="cm-variable">lastX</span> <span class="cm-operator">=</span> <span class="cm-variable-2">event</span>.<span class="cm-property">pageX</span>;
    }
  }
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_OkAFTS9SkH" href="./14_event.html#p_OkAFTS9SkH"></a>Имайте в предвид, че манипулатора <code>"mousemove"</code> е регистриран на целия прозорец. Дори ако мишката отиде извън бара по време на плъзгането, ние все още искаме да обновим размера му и да спрем плъзгането, когато мишката се освободи.</p>
<p><a class="p_ident" id="p_fndkFYbayW" href="./14_event.html#p_fndkFYbayW"></a>Трябва да спрем преоразмеряването на бара , когато бутона на мишката е свободен. За съжаление, не всички браузъри поддържат <code>"mousemove"</code> събития за смислени <code>which</code> свойства. Налице е стандартното свойство <code>buttons</code>, което осигурява подобна информация, но това също не се поддържа от всички браузъри. За щастие всички основни браузъри поддържат или <code>buttons</code> или <code>which</code>, така че <code>buttonPressed</code> функцията в примера първо прави опит с <code>buttons</code> и ако не се поддържа се прехвърля към <code>which</code>.</p>
<p><a class="p_ident" id="p_H543iFvHsm" href="./14_event.html#p_H543iFvHsm"></a>Всеки път, когато показалеца на мишката влезе или излезе от разклонението, се създават ефектите на  <code>"mouseover"</code> или <code>"mouseout"</code> събитията. Тези две събития могат да се използват наред с други неща, за да създадем “Hover” ефект, показващ или оформящ нещо, когато мишката е над даден елемент.</p>
<p><a class="p_ident" id="p_5IESlahWDS" href="./14_event.html#p_5IESlahWDS"></a>За съжаление създаването на такъв ефект не е толкова просто, трябва да се започне с <code>"mouseover"</code> и да се завърши със <code>"mouseout"</code>. Когато мишката се движи от едно разклонение към неговите деца, ефекта на <code>"mouseout"</code> остава на родителското разклонение, въпреки че мишката вече не е в неговия обхват. За да направим нещата по-лоши, тези събития се разпространяват точно, както и другите събития и по този начин ще получим <code>"mouseout"</code> събитие, когато мишката напусне едно от детските разклонения, върху което манипулатора е регистриран.</p>
<p><a class="p_ident" id="p_WkAAgbH7zo" href="./14_event.html#p_WkAAgbH7zo"></a>За да заобиколим този проблем, можем да използваме свойството <code>relatedTarget</code> на обекта на събитието, създадено за тези събития. То ни казва в случай на <code>"mouseover"</code>, над какъв елемент е показалката и в случай на <code>"mouseout"</code>, от кой елемент излиза. Ние искаме да променим нашия “hover” ефект, само когато <code>relatedTarget</code> е извън целевото разклонение. Само в този случай това събитие представлява пресичане на разклонението отвън на вътре (или друг заобиколен път).</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_TaoImM2eVz" href="./14_event.html#c_TaoImM2eVz"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>Hover over this <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">strong</span><span class="cm-tag cm-bracket">&gt;</span>paragraph<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">strong</span><span class="cm-tag cm-bracket">&gt;</span>.<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">para</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"p"</span>);
  <span class="cm-keyword">function</span> <span class="cm-variable">isInside</span>(<span class="cm-def">node</span>, <span class="cm-def">target</span>) {
    <span class="cm-keyword">for</span> (; <span class="cm-variable-2">node</span> <span class="cm-operator">!=</span> <span class="cm-atom">null</span>; <span class="cm-variable-2">node</span> <span class="cm-operator">=</span> <span class="cm-variable-2">node</span>.<span class="cm-property">parentNode</span>)
      <span class="cm-keyword">if</span> (<span class="cm-variable-2">node</span> <span class="cm-operator">==</span> <span class="cm-variable-2">target</span>) <span class="cm-keyword">return</span> <span class="cm-atom">true</span>;
  }
  <span class="cm-variable">para</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"mouseover"</span>, <span class="cm-keyword">function</span>(<span class="cm-def">event</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable">isInside</span>(<span class="cm-variable-2">event</span>.<span class="cm-property">relatedTarget</span>, <span class="cm-variable">para</span>))
      <span class="cm-variable">para</span>.<span class="cm-property">style</span>.<span class="cm-property">color</span> <span class="cm-operator">=</span> <span class="cm-string">"red"</span>;
  });
  <span class="cm-variable">para</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"mouseout"</span>, <span class="cm-keyword">function</span>(<span class="cm-def">event</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable">isInside</span>(<span class="cm-variable-2">event</span>.<span class="cm-property">relatedTarget</span>, <span class="cm-variable">para</span>))
      <span class="cm-variable">para</span>.<span class="cm-property">style</span>.<span class="cm-property">color</span> <span class="cm-operator">=</span> <span class="cm-string">""</span>;
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_QTE0dpHOFx" href="./14_event.html#p_QTE0dpHOFx"></a>Функцията <code>isInside</code> следва родителското разклонение на даденото разклонение докато то или достигне горната част на документа (където <code>node</code> става нула) или намира родителя, който търсим.</p>
<p><a class="p_ident" id="p_ujj+9rrIE3" href="./14_event.html#p_ujj+9rrIE3"></a>Трябва да добавя, че “hover” ефекта, може да бъде постигнат много по-лесно с помоща на CSS <code>:hover</code>, както следващия пример показва. Но ако “hover” ефекта включва нещо по-сложно, от колкото  смяна на стила на целевото разклонение, трябва да използвате начина с <code>"mouseover"</code> и <code>"mouseout"</code> събитията.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_ekyIyKuAIw" href="./14_event.html#c_ekyIyKuAIw"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">style</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-tag">p</span>:<span class="cm-variable-3">hover</span> { <span class="cm-property">color</span>: <span class="cm-keyword">red</span> }
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">style</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>Hover over this <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">strong</span><span class="cm-tag cm-bracket">&gt;</span>paragraph<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">strong</span><span class="cm-tag cm-bracket">&gt;</span>.<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<h2><a class="h_ident" id="h_xGSp7W5DAZ" href="./14_event.html#h_xGSp7W5DAZ"></a>Scroll  събития (превъртане)</h2>
<p><a class="p_ident" id="p_QhFs2TfUWV" href="./14_event.html#p_QhFs2TfUWV"></a>Всеки път, когато се превърта елемент, се използва ефекта на <code>"scroll"</code> събитието върху него. Той има различни цели, след като знае това, което потребителя гледа в момента (за забраняване на анимации на екрана или изпращане на шпионски доклади към централата на злите) или показва известни признаци на прогрес (като маркираме част от съдържанието на таблица или появяване на номер на страница).</p>
<p><a class="p_ident" id="p_koAfRfBrN2" href="./14_event.html#p_koAfRfBrN2"></a>Следващият пример чертае прогреса на бар в горния десен ъгъл на документа и го актуализира за да се запълни, когато превъртаме на долу.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_/JAGIqqr4X" href="./14_event.html#c_/JAGIqqr4X"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">style</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-qualifier">.progress</span> {
    <span class="cm-property">border</span>: <span class="cm-number">1px</span> <span class="cm-atom">solid</span> <span class="cm-keyword">blue</span>;
    <span class="cm-property">width</span>: <span class="cm-number">100px</span>;
    <span class="cm-property">position</span>: <span class="cm-atom">fixed</span>;
    <span class="cm-property">top</span>: <span class="cm-number">10px</span>; <span class="cm-property">right</span>: <span class="cm-number">10px</span>;
  }
  <span class="cm-qualifier">.progress</span> &gt; <span class="cm-tag">div</span> {
    <span class="cm-property">height</span>: <span class="cm-number">12px</span>;
    <span class="cm-property">background</span>: <span class="cm-keyword">blue</span>;
    <span class="cm-property">width</span>: <span class="cm-number">0%</span>;
  }
  <span class="cm-tag">body</span> {
    <span class="cm-property">height</span>: <span class="cm-number">2000px</span>;
  }
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">style</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">div</span> <span class="cm-attribute">class</span>=<span class="cm-string">"progress"</span><span class="cm-tag cm-bracket">&gt;&lt;</span><span class="cm-tag">div</span><span class="cm-tag cm-bracket">&gt;&lt;/</span><span class="cm-tag">div</span><span class="cm-tag cm-bracket">&gt;&lt;/</span><span class="cm-tag">div</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>Scroll me...<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">bar</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">".progress div"</span>);
  <span class="cm-variable">addEventListener</span>(<span class="cm-string">"scroll"</span>, <span class="cm-keyword">function</span>() {
    <span class="cm-keyword">var</span> <span class="cm-def">max</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">body</span>.<span class="cm-property">scrollHeight</span> <span class="cm-operator">-</span> <span class="cm-variable">innerHeight</span>;
    <span class="cm-keyword">var</span> <span class="cm-def">percent</span> <span class="cm-operator">=</span> (<span class="cm-variable">pageYOffset</span> <span class="cm-operator">/</span> <span class="cm-variable-2">max</span>) <span class="cm-operator">*</span> <span class="cm-number">100</span>;
    <span class="cm-variable">bar</span>.<span class="cm-property">style</span>.<span class="cm-property">width</span> <span class="cm-operator">=</span> <span class="cm-variable-2">percent</span> <span class="cm-operator">+</span> <span class="cm-string">"%"</span>;
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_J92IjzNbC5" href="./14_event.html#p_J92IjzNbC5"></a>Позициониране на елемента с <code>position</code> : <code>fixed</code>, много прилича на <code>absolute</code> позиция, но разликата е, че го предпазва от превъртане заедно с останалата част от документа. Идеята е да направим нашия бар неподвижен в своя ъгъл. В него е друг елемент, който се преоразмерява, за да посочи напредъка. Използваме <code>%</code> вместо <code>px</code>, като мерна единица при определяне на ширината на елемента, така че елемента да е съразмерен спрямо цялата лента.</p>
<p><a class="p_ident" id="p_Q5ZDL6Y/Rx" href="./14_event.html#p_Q5ZDL6Y/Rx"></a>Глобалната променлива <code>innerHeight</code> ни дава височината на прозореца,  която трябва да извадим от общата скрол -височина, за да не можем да продължим да превъртаме, когато стигнем края на документа.(Там има <code>innerWidth</code>, който се мести заедно с <code>innerHeight</code>.) Чрез разделяне на <code>pageYOffset</code> (текущата позиция на превъртане) с максималната  позиция на превъртане и се умножи по 100, получаваме процент за прогреса на лентата.</p>
<p><a class="p_ident" id="p_0tTa0Fp6S+" href="./14_event.html#p_0tTa0Fp6S+"></a>Извикването на <code>preventDefault</code> върху скрол събитието не пречи на превъртането да се случи. В действителност, манипулатора на събитието се извиква само след, като превъртането се състои.</p>
<h2><a class="h_ident" id="h_NoKd+BgJRm" href="./14_event.html#h_NoKd+BgJRm"></a>Фокус  събития</h2>
<p><a class="p_ident" id="p_r6SF152VBY" href="./14_event.html#p_r6SF152VBY"></a>Когато един елемент се фокусира, браузърът използва ефекта на <code>"focus"</code> събитие върху него. Когато губи фокус използва ефекта на <code>"blur"</code> събитие.</p>
<p><a class="p_ident" id="p_rU6XEBvIwF" href="./14_event.html#p_rU6XEBvIwF"></a>За разлика от събитията, обсъдени по рано, тези две събития не се разпространяват. Манипулатора на родителския елемент, не е уведомен, когато дъщерният елемент е фокусиран или губи фокус.</p>
<p><a class="p_ident" id="p_XbY3zpvUvn" href="./14_event.html#p_XbY3zpvUvn"></a>Следващият пример показва помощен текст в текстово поле, което сме фокусирали в момента.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_Z4ZnolMxZ9" href="./14_event.html#c_Z4ZnolMxZ9"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>Name: <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">input</span> <span class="cm-attribute">type</span>=<span class="cm-string">"text"</span> <span class="cm-attribute">data-help</span>=<span class="cm-string">"Your full name"</span><span class="cm-tag cm-bracket">&gt;&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>Age: <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">input</span> <span class="cm-attribute">type</span>=<span class="cm-string">"text"</span> <span class="cm-attribute">data-help</span>=<span class="cm-string">"Age in years"</span><span class="cm-tag cm-bracket">&gt;&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span> <span class="cm-attribute">id</span>=<span class="cm-string">"help"</span><span class="cm-tag cm-bracket">&gt;&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">help</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"#help"</span>);
  <span class="cm-keyword">var</span> <span class="cm-variable">fields</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelectorAll</span>(<span class="cm-string">"input"</span>);
  <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-variable">i</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable">i</span> <span class="cm-operator">&lt;</span> <span class="cm-variable">fields</span>.<span class="cm-property">length</span>; <span class="cm-variable">i</span><span class="cm-operator">++</span>) {
    <span class="cm-variable">fields</span>[<span class="cm-variable">i</span>].<span class="cm-property">addEventListener</span>(<span class="cm-string">"focus"</span>, <span class="cm-keyword">function</span>(<span class="cm-def">event</span>) {
      <span class="cm-keyword">var</span> <span class="cm-def">text</span> <span class="cm-operator">=</span> <span class="cm-variable-2">event</span>.<span class="cm-property">target</span>.<span class="cm-property">getAttribute</span>(<span class="cm-string">"data-help"</span>);
      <span class="cm-variable">help</span>.<span class="cm-property">textContent</span> <span class="cm-operator">=</span> <span class="cm-variable-2">text</span>;
    });
    <span class="cm-variable">fields</span>[<span class="cm-variable">i</span>].<span class="cm-property">addEventListener</span>(<span class="cm-string">"blur"</span>, <span class="cm-keyword">function</span>(<span class="cm-def">event</span>) {
      <span class="cm-variable">help</span>.<span class="cm-property">textContent</span> <span class="cm-operator">=</span> <span class="cm-string">""</span>;
    });
  }
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_5HyY0t9dpU" href="./14_event.html#p_5HyY0t9dpU"></a>Window обекта ще получи  
<code>"focus"</code> и <code>"blur"</code> събитията, когато потребителя се движи във браузъра или в прозореца, в който се показва документа.</p>
<h2><a class="h_ident" id="h_NmV8RP8lpt" href="./14_event.html#h_NmV8RP8lpt"></a>Load  събитие</h2>
<p><a class="p_ident" id="p_NarSNA3PKB" href="./14_event.html#p_NarSNA3PKB"></a>Когато една страница завърши зареждането, използва ефекта на <code>"load"</code> събитието върху прозореца и обектите на тялото на документа. Това често се използва за планиране на действията за инициализация, които изискват целият документ да бъде построен. Не забравяйте , че съдържанието на <code>&lt;script&gt;</code> таговете се стартират в момента, когато се срещне тага. Това често е твърде рано, като например, когато скрипта трябва да направи нещо с част от документа, която се появява след 
<code>&lt;script&gt;</code> тага.</p>
<p><a class="p_ident" id="p_hCgodGiFEt" href="./14_event.html#p_hCgodGiFEt"></a>Елементи, като изображения  и скрипт тагове, които се зареждат от външен файл също имат <code>"load"</code> събитие, което показва, че файловете са заредени. Подобно на събитията свързани с фокуса, <em>load</em> събитията не се разпространяват.</p>
<p><a class="p_ident" id="p_nu8/BUQa7r" href="./14_event.html#p_nu8/BUQa7r"></a>Когато страницата е затворена или навигацията е далеч от тук (например, следването на линк), се използва ефекта на <code>"beforeunload"</code> събитието. Основната употреба на това събитие  е да предотврати отказването на потребителя (да загуби интерес и да затвори прозореца) поради дългото зареждане на страницата. Предотвратяване на страницата от разтоварване (<em>unloading</em>) не е направено, както се очаква с <code>preventDefault</code> метода. Вместо това се извършва чрез връщане на <em>string</em> от модификатора. <em>String</em>-а ще използва диалогов прозорец, който иска от потребителя отговор, дали да остане на страницата или да я напусне. Този механизъм гарантира , че потребителя е в състояние да напусне страницата, дори ако тя изпълнява зловреден скрипт, който би предпочел да го задържи там завинаги, за го принуди да гледа свързани с отслабване реклами.</p>
<h2 id="timeline"><a class="h_ident" id="h_cj44kRfk/h" href="./14_event.html#h_cj44kRfk/h"></a>Изпълнение  на  скрипт  по  график</h2>
<p><a class="p_ident" id="p_m898wVhAww" href="./14_event.html#p_m898wVhAww"></a>Има различни неща, които да са причина скрипта да започне да се изпълнява. Четенето на <code>&lt;script&gt;</code> таг е едно такова нещо. Ефект на събитие е съвсем друго нещо. В 
<a href="./13_dom.html#animationFrame">Глава 13</a> обсъдихме функцията <code>requestAnimationFrame</code>, чиято функция за графика да бъде извикана преди следващата страница да се преначертае. Това е още един начин, по който един скрипт може да започне да работи.</p>
<p><a class="p_ident" id="p_3Ya6RuV22D" href="./14_event.html#p_3Ya6RuV22D"></a>Важно е да се разбере, че макар и събитията да могат да имат ефекти по всяко време, няма два скрипта в един документ, които да се изпълняват в един и същи момент. Ако скрипт вече се изпълнява, модификаторите за събитията и парчетата код, планирани по друг начин трябва да чакат реда си. Това е причината поради , която един документ замръзва, когато даден скрипт работи по-дълго време. Браузърът не може да реагира на кликвания и други събития в рамките на документа, тъй като не може да работи със събития, докато текущия скрипт не приключи работа.</p>
<p><a class="p_ident" id="p_qOcAjNuS8p" href="./14_event.html#p_qOcAjNuS8p"></a>Някои програмни среди позволяват множество нишки за изпълнение, които да се движат по едно и също време. Вместо правенето на няколко неща едновременно, може да се използва да се направи една програма по-бърза. Когато имате множество участници, които действат по едно и също време в едни и същи части на системата, мисленето на програмата става една идея по-трудно.</p>
<p><a class="p_ident" id="p_omeCxjcdIQ" href="./14_event.html#p_omeCxjcdIQ"></a>Фактът, че програмите на JavaScript могат да правят само едно нещо в даден момент прави живота ни по-лесен. За случаите, в които някои неща наистина отнемат време, може да се пусне потребителски фонов режим без замръзване на страницата, браузърите предоставят нещо наречено <em>web workers</em>. Worker е изолирана от JavaScript среда, която работи с основната програма на документа и може да комуникира с него само чрез изпращане и приемане на съобщения.</p>
<p><a class="p_ident" id="p_dXLk5WXFTx" href="./14_event.html#p_dXLk5WXFTx"></a>Да приемем, че имаме следния код във файла, наречен <code>code/squareworker.js</code>:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_W+YwrW4zDz" href="./14_event.html#c_W+YwrW4zDz"></a><span class="cm-variable">addEventListener</span>(<span class="cm-string">"message"</span>, <span class="cm-keyword">function</span>(<span class="cm-def">event</span>) {
  <span class="cm-variable">postMessage</span>(<span class="cm-variable-2">event</span>.<span class="cm-property">data</span> <span class="cm-operator">*</span> <span class="cm-variable-2">event</span>.<span class="cm-property">data</span>);
});</pre>
<p><a class="p_ident" id="p_3bETV2ub20" href="./14_event.html#p_3bETV2ub20"></a>Представете си, че квадратния номер е тежко продължително изчисление, за това ние искаме да се изпълни фоновия режим. Този код създава работник, който ще изпрати няколко съобщения и ще изведе отговорите.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_p9YbRbVPlS" href="./14_event.html#c_p9YbRbVPlS"></a><span class="cm-keyword">var</span> <span class="cm-variable">squareWorker</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Worker</span>(<span class="cm-string">"code/squareworker.js"</span>);
<span class="cm-variable">squareWorker</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"message"</span>, <span class="cm-keyword">function</span>(<span class="cm-def">event</span>) {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"The worker responded:"</span>, <span class="cm-variable-2">event</span>.<span class="cm-property">data</span>);
});
<span class="cm-variable">squareWorker</span>.<span class="cm-property">postMessage</span>(<span class="cm-number">10</span>);
<span class="cm-variable">squareWorker</span>.<span class="cm-property">postMessage</span>(<span class="cm-number">24</span>);</pre>
<p><a class="p_ident" id="p_Stp8nkaZHV" href="./14_event.html#p_Stp8nkaZHV"></a>Функцията <code>postMessage</code> изпраща съобщение, което ще доведе до ефекта на <code>"message"</code> събитие в приемника. Скрипта, който създаде работника изпраща и получава съобщения през обекта на работника, докато работника разговаря със скрипта, който го е създал чрез изпращане и слушане направо от неговия глобален обхват, който е нов глобален обхват, а не общ с оригиналния скрипт.</p>
<h2><a class="h_ident" id="h_WCvdQCKgu8" href="./14_event.html#h_WCvdQCKgu8"></a>Настройка  на  таймерите</h2>
<p><a class="p_ident" id="p_5YmF46Q06c" href="./14_event.html#p_5YmF46Q06c"></a>Функцията <code>setTimeout</code> е подобна на <code>requestAnimationFrame</code>. Тя планира друга функция да бъде извикана по-късно. Но вместо да извика другата функция на следващото преначертаване, тя изчаква дадено количество милисекунди. Тази страница сменя фона си от син в жълт след две секунди.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_pPMIwB3Xm+" href="./14_event.html#c_pPMIwB3Xm+"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-variable">document</span>.<span class="cm-property">body</span>.<span class="cm-property">style</span>.<span class="cm-property">background</span> <span class="cm-operator">=</span> <span class="cm-string">"blue"</span>;
  <span class="cm-variable">setTimeout</span>(<span class="cm-keyword">function</span>() {
    <span class="cm-variable">document</span>.<span class="cm-property">body</span>.<span class="cm-property">style</span>.<span class="cm-property">background</span> <span class="cm-operator">=</span> <span class="cm-string">"yellow"</span>;
  }, <span class="cm-number">2000</span>);
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_de3VjAL+lV" href="./14_event.html#p_de3VjAL+lV"></a>Понякога трябва да се отмени планираната функция. Това се прави чрез съхраняване на стойността върната от <code>setTimeout</code> и извикване на <code>clearTimeout</code> върху нея.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_GKrnZf5KuZ" href="./14_event.html#c_GKrnZf5KuZ"></a><span class="cm-keyword">var</span> <span class="cm-variable">bombTimer</span> <span class="cm-operator">=</span> <span class="cm-variable">setTimeout</span>(<span class="cm-keyword">function</span>() {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"BOOM!"</span>);
}, <span class="cm-number">500</span>);

<span class="cm-keyword">if</span> (<span class="cm-variable">Math</span>.<span class="cm-property">random</span>() <span class="cm-operator">&lt;</span> <span class="cm-number">0.5</span>) { <span class="cm-comment">// 50% chance</span>
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Defused."</span>);
  <span class="cm-variable">clearTimeout</span>(<span class="cm-variable">bombTimer</span>);
}</pre>
<p><a class="p_ident" id="p_c/F+71/NPg" href="./14_event.html#p_c/F+71/NPg"></a>Функцията <code>cancelAnimationFrame</code> работи по същия начин, както <code>clearTimeout</code> - извикана с върнатата стойност от <code>requestAnimationFrame</code> ще отмени този кадър.</p>
<p><a class="p_ident" id="p_MTqUUpmFIN" href="./14_event.html#p_MTqUUpmFIN"></a>Подобен набор от функции <code>setInterval</code>
и <code>clearInterval</code> се използват за задаване на таймери, които трябва да се повтарят на всеки <em>X</em> милисекунди.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_woAViW3Ypf" href="./14_event.html#c_woAViW3Ypf"></a><span class="cm-keyword">var</span> <span class="cm-variable">ticks</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>;
<span class="cm-keyword">var</span> <span class="cm-variable">clock</span> <span class="cm-operator">=</span> <span class="cm-variable">setInterval</span>(<span class="cm-keyword">function</span>() {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"tick"</span>, <span class="cm-variable">ticks</span><span class="cm-operator">++</span>);
  <span class="cm-keyword">if</span> (<span class="cm-variable">ticks</span> <span class="cm-operator">==</span> <span class="cm-number">10</span>) {
    <span class="cm-variable">clearInterval</span>(<span class="cm-variable">clock</span>);
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"stop."</span>);
  }
}, <span class="cm-number">200</span>);</pre>
<h2><a class="h_ident" id="h_AOVmaqj10I" href="./14_event.html#h_AOVmaqj10I"></a>Debouncing</h2>
<p><a class="p_ident" id="p_I3Osg2AlyQ" href="./14_event.html#p_I3Osg2AlyQ"></a>Някои видове събития имат потенциала да се изстрелват много бързо и много пъти в един ред (като <code>"mousemove"</code> и <code>"scroll"</code> събитията). Когато се работи с такива събития трябва да бъдете внимателни да не направите нещо, което отнема много време или вашия манипулатор да отнема толкова много време, че взаимодействието с документа да се чувства бавно и накъсано.</p>
<p><a class="p_ident" id="p_CvRYtJPZwz" href="./14_event.html#p_CvRYtJPZwz"></a>Ако все пак трябва да направим нещо <em>nontrivial</em> с такъв манипулатор, можем да използваме <code>setTimeout</code> за да се уверим, че не го правим твърде често. Това обикновено се нарича <em>debouncing</em> на събитието. Има няколко леко различаващи се подхода към този въпрос.</p>
<p><a class="p_ident" id="p_8qDwbjQg0l" href="./14_event.html#p_8qDwbjQg0l"></a>В първия пример, искаме да направим нещо, когато потребителя е въвел нещо, но не искаме да го изпълним веднага за всяко клавишно събитие. Когато се пише бързо, ние просто искаме да изчакаме докато настъпи пауза. Вместо незабавно извършване на действия в манипулатора на събитието, ще създадем таймаут. Също така ще изчистим предишното изчакване (ако има такова), така че когато се случват събития близо едно до друго (по-близо от нашето изчакване за закъснение), времето за изчакване от предишното събитие ще бъде анулирано.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_ykMNnQNrSH" href="./14_event.html#c_ykMNnQNrSH"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">textarea</span><span class="cm-tag cm-bracket">&gt;</span>Type something here...<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">textarea</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">textarea</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"textarea"</span>);
  <span class="cm-keyword">var</span> <span class="cm-variable">timeout</span>;
  <span class="cm-variable">textarea</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"keydown"</span>, <span class="cm-keyword">function</span>() {
    <span class="cm-variable">clearTimeout</span>(<span class="cm-variable">timeout</span>);
    <span class="cm-variable">timeout</span> <span class="cm-operator">=</span> <span class="cm-variable">setTimeout</span>(<span class="cm-keyword">function</span>() {
      <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"You stopped typing."</span>);
    }, <span class="cm-number">500</span>);
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_55az3iLtsc" href="./14_event.html#p_55az3iLtsc"></a>С подаване на недефинирана стойност към <code>clearTimeout</code> или да го наречем изчакване, събитието няма ефект. Затова, трябва да бъдем внимателни, когато го извикаме и просто да го прави за всяко събитие.</p>
<p><a class="p_ident" id="p_GisH+i+4tv" href="./14_event.html#p_GisH+i+4tv"></a>Можем да използваме малко по-различен подход, ако искаме разредени отговори, така че да са разделени поне за известен период от време, но искаме ефекта през серията от събития, а не само накрая. Например, можем да искаме да се отговори на <code>"mousemove"</code> събитията, като показваме текущите координати на мишката, но само веднъж на всеки 250 милисекунди.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_59G6TKpjOY" href="./14_event.html#c_59G6TKpjOY"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">function</span> <span class="cm-variable">displayCoords</span>(<span class="cm-def">event</span>) {
    <span class="cm-variable">document</span>.<span class="cm-property">body</span>.<span class="cm-property">textContent</span> <span class="cm-operator">=</span>
      <span class="cm-string">"Mouse at "</span> <span class="cm-operator">+</span> <span class="cm-variable-2">event</span>.<span class="cm-property">pageX</span> <span class="cm-operator">+</span> <span class="cm-string">", "</span> <span class="cm-operator">+</span> <span class="cm-variable-2">event</span>.<span class="cm-property">pageY</span>;
  }

  <span class="cm-keyword">var</span> <span class="cm-variable">scheduled</span> <span class="cm-operator">=</span> <span class="cm-atom">false</span>, <span class="cm-variable">lastEvent</span>;
  <span class="cm-variable">addEventListener</span>(<span class="cm-string">"mousemove"</span>, <span class="cm-keyword">function</span>(<span class="cm-def">event</span>) {
    <span class="cm-variable">lastEvent</span> <span class="cm-operator">=</span> <span class="cm-variable-2">event</span>;
    <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable">scheduled</span>) {
      <span class="cm-variable">scheduled</span> <span class="cm-operator">=</span> <span class="cm-atom">true</span>;
      <span class="cm-variable">setTimeout</span>(<span class="cm-keyword">function</span>() {
        <span class="cm-variable">scheduled</span> <span class="cm-operator">=</span> <span class="cm-atom">false</span>;
        <span class="cm-variable">displayCoords</span>(<span class="cm-variable">lastEvent</span>);
      }, <span class="cm-number">250</span>);
    }
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<h2><a class="h_ident" id="h_ErccPg/l98" href="./14_event.html#h_ErccPg/l98"></a>Резюме</h2>
<p><a class="p_ident" id="p_bKLVanKSm7" href="./14_event.html#p_bKLVanKSm7"></a>Манипулаторите на събития дават възможност да се открие и реагира на събитие, върху които нямаме пряк контрол. Метода <code>addEventListener</code> се използва за да се регистрира такъв манипулатор.</p>
<p><a class="p_ident" id="p_pT/A7mXxlh" href="./14_event.html#p_pT/A7mXxlh"></a>Всяко събитие има тип (<code>"keydown"</code>, <code>"focus"</code> и т.н.), който го идентифицира. Повечето събития се извикват върху конкретен  DOM елемент и след това се разпространяват към родителските елементи, позволявайки на модификаторите свързани с тези елементи да ги ръководят.</p>
<p><a class="p_ident" id="p_jK5bk5CuMw" href="./14_event.html#p_jK5bk5CuMw"></a>Когато се извика модификатор на събитие, той се предава на обекта на събитието с допълнителна информация за това събитие. Този обект също има методи, които ни позволяват да спрем по-нататъшно разпространение със (<code>stopPropagation</code>) и предотвратяват по подразбиране работата на браузъра със събитието с (<code>preventDefault</code>).</p>
<p><a class="p_ident" id="p_8R4tiRRH3a" href="./14_event.html#p_8R4tiRRH3a"></a>Натискането на клавиши, предизвикват ефекти на събитията: <code>"keydown"</code>, <code>"keypress"</code> и <code>"keyup"</code>. Натискането на бутони на мишката, предизвикват ефекти на събитията: <code>"mousedown"</code>, <code>"mouseup"</code> и <code>"click"</code>. Движението на мишката, предизвиква ефекти на събитията: <code>"mousemove"</code>, <code>"mouseenter"</code> и <code>"mouseout"</code>.</p>
<p><a class="p_ident" id="p_zwo0vgzm7O" href="./14_event.html#p_zwo0vgzm7O"></a><em>Scrolling</em> може да бъде намерен със <code>"scroll"</code> събитието, а фокусиране на промени могат да бъдат установени с <code>"focus"</code> и <code>"blur"</code> събития. Когато документа завърши зареждането, <code>"load"</code> събитието предизвиква ефекти на прозореца.</p>
<p><a class="p_ident" id="p_0zJSMPD1MF" href="./14_event.html#p_0zJSMPD1MF"></a>Само една част от програмата на JavaScript може да работи в даден момент. По този начин, събития и други планирани скриптове трябва да изчакат другите скриптове да завършат преди да дойде техния ред.</p>
<h2><a class="h_ident" id="h_TcUD2vzyMe" href="./14_event.html#h_TcUD2vzyMe"></a>Упражнения</h2>
<h3><a class="h_ident" id="h_Lhbs8f7VGD" href="./14_event.html#h_Lhbs8f7VGD"></a>Цензурирана клавиатура</h3>
<p><a class="p_ident" id="p_EvVPidig6g" href="./14_event.html#p_EvVPidig6g"></a>Между 1928г. и 2013г. турското законодателство забранява употребата на буквите <em>Q</em>, <em>W</em> и <em>X</em> в официални документи. Това е част от по-широка инициатива за задушаване на кюрдската култура, където тези букви се срещат в езика използван от кюрдите, но не и в Инстанбулския турски.</p>
<p><a class="p_ident" id="p_TZAfuJye+C" href="./14_event.html#p_TZAfuJye+C"></a>Като упражнение да направете смешните неща от технологията, искам да програмирате текстово поле (<code>&lt;input type="text"&gt;</code>), така че тези букви да не могат да бъдат печатани вътре.</p>
<p><a class="p_ident" id="p_cs0DibmEsI" href="./14_event.html#p_cs0DibmEsI"></a>(Не се притеснявайте за копиране и поставяне и други подобни вратички).</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_6U7kyA+bbA" href="./14_event.html#c_6U7kyA+bbA"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">input</span> <span class="cm-attribute">type</span>=<span class="cm-string">"text"</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">field</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"input"</span>);
  <span class="cm-comment">// Your code here.</span>
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<div class="solution"><div class="solution-text">
<p><a class="p_ident" id="p_YBoRLaAVI/" href="./14_event.html#p_YBoRLaAVI/"></a>Решението на това упражнение включва предотвратяване на поведението по подразбиране за ключови събития. Може да използвате <code>"keypress"</code> или <code>"keydown"</code>. Ако някое от тях извика <code>preventDefault</code> текста няма да се появи.</p>
<p><a class="p_ident" id="p_/Pq3qIWZcN" href="./14_event.html#p_/Pq3qIWZcN"></a>Идентифицирането на буква при въвеждане изисква преглеждането и с <code>keyCode</code> или <code>charCode</code> свойствата и сравняване с кодовете на буквите, които искате да филтрирате. В <code>"keydown"</code> не е нужно да се притеснявате за малки или главни букви, тъй като се определя само когато клавиша е натиснат. Ако решите да ползвате <code>"keypress"</code> която идентифицира действително въведения знак, трябва да се уверите, че тества и двата случая. Един от начините да се направи това е :</p>
<pre>/[qwx]/i.test(String.fromCharCode(event.charCode))</pre>
</div></div>
<h3><a class="h_ident" id="h_NOgRH0Y9st" href="./14_event.html#h_NOgRH0Y9st"></a>Следа на мишката</h3>
<p><a class="p_ident" id="p_j4+NSbR+hs" href="./14_event.html#p_j4+NSbR+hs"></a>В ранните дни на JavaScript, което беше време на крещящи начални страници с много анимирани изображения, хората излязоха с някои наистина вдъхновяващи начини за използване на езика.</p>
<p><a class="p_ident" id="p_ZseDCwl6/C" href="./14_event.html#p_ZseDCwl6/C"></a>Един от тях е “миша пътека”- серия от снимки, които следват показалеца на мишката, като го преместим на другата страна на страницата.</p>
<p><a class="p_ident" id="p_0yy1fiF5Gm" href="./14_event.html#p_0yy1fiF5Gm"></a>В това упражнение, искам да приложите една пътека на мишката. Използвайте абсолютно позиционирани <code>&lt;div&gt;</code> елементи с фиксиран размер и цвят на фона( направете справка в <a href="./14_event.html#mouse_drawing">секцията</a> Кликвания на мишката за пример). Създайте едни куп такива елементи и когато мишката се движи да се показват в началото на показалеца на мишката.</p>
<p><a class="p_ident" id="p_5jL8mAUnIQ" href="./14_event.html#p_5jL8mAUnIQ"></a>Има различни възможни подходи тук. Можете да направите вашето решение толкова просто или толкова сложно, колкото си искате. Просто решение е да поддържате фиксиран брой елементи в пътеката и цикъл през тях за преместване на следващия от тях на текущата позиция на мишката всеки път, когато <code>"mousemove"</code> събитието се случва.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_0LLgPO3WFn" href="./14_event.html#c_0LLgPO3WFn"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">style</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-qualifier">.trail</span> { <span class="cm-comment">/* className for the trail elements */</span>
    <span class="cm-property">position</span>: <span class="cm-atom">absolute</span>;
    <span class="cm-property">height</span>: <span class="cm-number">6px</span>; <span class="cm-property">width</span>: <span class="cm-number">6px</span>;
    <span class="cm-property">border-radius</span>: <span class="cm-number">3px</span>;
    <span class="cm-property">background</span>: <span class="cm-keyword">teal</span>;
  }
  <span class="cm-tag">body</span> {
    <span class="cm-property">height</span>: <span class="cm-number">300px</span>;
  }
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">style</span><span class="cm-tag cm-bracket">&gt;</span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-comment">// Your code here.</span>
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<div class="solution"><div class="solution-text">
<p><a class="p_ident" id="p_JMiSkEOEr3" href="./14_event.html#p_JMiSkEOEr3"></a>Създаването на елементите е най-добре с цикъл. Добавете ги към документа за да ги покаже. За да може да получите достъп до тях по-късно за промяна на позицията им, ги съхранете в масив.</p>
<p><a class="p_ident" id="p_seJm6U8e4t" href="./14_event.html#p_seJm6U8e4t"></a>Търкалянето през тях може да се направи чрез променлива-брояч и добавяне на 1 към него всеки път, когато има <code>"mousemove"</code> събитие. Оператора за остатък (<code>% 10</code>) може да се ползва за получаване на валиден масив с индекси, за да изберете елемента, който искате да се позиционира по време на дадено събитие.</p>
<p><a class="p_ident" id="p_cJRZn+Vuv9" href="./14_event.html#p_cJRZn+Vuv9"></a>Друг интересен ефект може да се постигне чрез моделиране на проста физична система. Използвайте <code>"mousemove"</code> събътието само за да се актуализират един чифт променливи, които следят положението на мишката. След това използвайте <code>requestAnimationFrame</code> за задните елементи да симулират привличане от показалеца на мишката. На всяка стъпка анимация актуализирайте позицията на базата на тяхното положение спрямо показалеца (и евентуално скороста, която се съхранява за всеки елемент). Измислянето на добър начин да направите това, е до вас.</p>
</div></div>
<h3><a class="h_ident" id="h_Kk1WKx2anJ" href="./14_event.html#h_Kk1WKx2anJ"></a>Етикети</h3>
<p><a class="p_ident" id="p_Ktj5JZEPdu" href="./14_event.html#p_Ktj5JZEPdu"></a>Етикетиран интерфейс е обща цел на дизайна. Той ви позволява да изберете интерфейсен панел, като избирате от редица номерирани етикети прикрепени над даден елемент.</p>
<p><a class="p_ident" id="p_rh5X8kUE8g" href="./14_event.html#p_rh5X8kUE8g"></a>В това упражнение ще приложите просто етикетиране на интерфейс. Напишете функция <code>asTabs</code>, която взема DOM разклонение и създава етикетиран интерфейс, показващ децата на това разклонение. Трябва да въведете списък <code>&lt;button&gt;</code> елементи в горната част от разклонението, по един за всеки дъщерен елемент, съдържащ текст събран от данните на имената на атрибутите на детето. Всички освен едно от оригиналните деца трябва да бъдат скрити (стил - <code>display</code>: <code>none</code>) и да се вижда родителското разклонение, когато се кликне на бутоните.</p>
<p><a class="p_ident" id="p_744xb2mKFr" href="./14_event.html#p_744xb2mKFr"></a>Когато тръгне, може да удължите програмата , като разкрасите активния в момента бутон по различен начин.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_X/67xebmzu" href="./14_event.html#c_X/67xebmzu"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">div</span> <span class="cm-attribute">id</span>=<span class="cm-string">"wrapper"</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">div</span> <span class="cm-attribute">data-tabname</span>=<span class="cm-string">"one"</span><span class="cm-tag cm-bracket">&gt;</span>Tab one<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">div</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">div</span> <span class="cm-attribute">data-tabname</span>=<span class="cm-string">"two"</span><span class="cm-tag cm-bracket">&gt;</span>Tab two<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">div</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">div</span> <span class="cm-attribute">data-tabname</span>=<span class="cm-string">"three"</span><span class="cm-tag cm-bracket">&gt;</span>Tab three<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">div</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">div</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">function</span> <span class="cm-variable">asTabs</span>(<span class="cm-def">node</span>) {
    <span class="cm-comment">// Your code here.</span>
  }
  <span class="cm-variable">asTabs</span>(<span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"#wrapper"</span>));
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<div class="solution"><div class="solution-text">
<p><a class="p_ident" id="p_Y9FsMe+LUL" href="./14_event.html#p_Y9FsMe+LUL"></a>Недостатъка, с който най-вероятно ще се сблъскате е, че не може да използвате директно свойството за разклоненията <code>childNodes</code>, като колекция от етикети на разклонения. За едно нещо, когато добавите бутони те ще отидат също към децата на разклоненията и в крайна сметка в този обект, защото той е жив. От друга страна, текстовите разклонения, създадени за интервала между разклоненията също са там и те трябва да получат свои собствени етикети.</p>
<p><a class="p_ident" id="p_gEjwEtLy8/" href="./14_event.html#p_gEjwEtLy8/"></a>За да се справите с това, започнете с изграждането на реален масив за всички деца в обвивка, които имат <code>nodeType</code> от 1.</p>
<p><a class="p_ident" id="p_trFuWDXdya" href="./14_event.html#p_trFuWDXdya"></a>Когато се регистрира събитие от манипулаторите на бутоните, функцията на манипулатора трябва да знае с кой етикет на елемент е свързан бутона. Ако те са създадени в един нормален цикъл, може да получите достъп до индекс на променлива от вътрешноста на функцията, което няма да ви даде правилният номер, защото тази променлива ще е допълнително променена от цикъла.</p>
<p><a class="p_ident" id="p_G/6v+erUw4" href="./14_event.html#p_G/6v+erUw4"></a>Едно просто временно решение е да се използва <code>forEach</code> метода и да се създаде манипулатор на функция от вътре на функцията подадена към <code>forEach</code>. Индекса на цикъла, който се подава като втори аргумент на тази функция, ще бъде нормална локална променлива и няма да бъде презаписана от по-нататъшни повторения.</p>
</div></div>
<nav>
  <a href="./13_dom.html" title="previous chapter">◀</a>
  <a href="./index.html" title="cover">◆</a>
  <a href="./15_game.html" title="next chapter">▶</a>
</nav>
</article>
</body></html>
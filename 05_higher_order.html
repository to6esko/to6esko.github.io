<!DOCTYPE html>
<!-- saved from url=(0050)./05_higher_order.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <title>Higher-Order Functions :: Eloquent JavaScript</title>
  <link rel="stylesheet" href="./media/codemirror.css">
  <script src="./media/acorn_codemirror.js"></script>
  <link rel="stylesheet" href="./media/ejs.css">
  <script src="./media/sandbox.js"></script>
  <script src="./media/ejs.js"></script>
  <script>var chapNum = 5;var sandboxLoadFiles = ["code/ancestry.js", "code/chapter/05_higher_order.js", "code/intro.js"];</script>
</head>

<body><article>
<nav>
  <a href="./04_data.html" title="previous chapter">◀</a>
  <a href="./index.html" title="cover">◆</a>
  <a href="./06_object.html" title="next chapter">▶</a>
</nav>

<h1><div class="chap_num">Глава 5</div>По-високо ниво функции</h1>
<blockquote>
<p><a class="p_ident" id="p_18CYJsdOxo" href="./05_higher_order.html#p_18CYJsdOxo"></a>Дзъ-ли и Дзъ-су се хвалят с размерите на най-новите си програми. „Двеста хиляди реда код”, каза Дзъ-ли „без да броим коментарите!” Дзъ-су му отговорил „Пфу, моята е почти с милион линии повече.” А майстор Ян-Ма, казал „Моята най-добра програма има петстотин реда.” Като чули това, Дзъ-ли и Дзъ-су били просветени.”</p>
 <footer>Master Yuan-Ma, <cite>Книга за програмиране</cite></footer>
</blockquote>
<blockquote>
<p><a class="p_ident" id="p_MZD8y19lPz" href="./05_higher_order.html#p_MZD8y19lPz"></a>Има два начина за конструиране на софтуерен дизайн: Единият от начините е да се направи това толкова просто, че да има очевидни недостатъци, а другият начин е да се направи това, толкова сложно, че да не се виждат явните недостатъци.”</p>
 <footer>C.A.R. Hoare, <cite>1980 ACM Turing Award Lecture</cite></footer>
</blockquote>
<p><a class="p_ident" id="p_1SpKr5NIrc" href="./05_higher_order.html#p_1SpKr5NIrc"></a>Голямата програма е скъпа програма и то не само заради времето необходимо да се изгради. Размера почти винаги включва сложност и комплексност, която обърква програмистите. Обърканите програмисти, от своя страна, са склонни да въвеждат грешки (<em>bugs</em>) в програмите. Голямата програма предлага много място, където могат да се крият тези грешки, което ги прави трудни за намиране.</p>
<p><a class="p_ident" id="p_ethH+CXxsM" href="./05_higher_order.html#p_ethH+CXxsM"></a>За кратко да се върнем към последните две примерни програми в увода. Първата е автономна и е дълга 6 реда.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_W93KRCwXP0" href="./05_higher_order.html#c_W93KRCwXP0"></a><span class="cm-keyword">var</span> <span class="cm-variable">total</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>, <span class="cm-variable">count</span> <span class="cm-operator">=</span> <span class="cm-number">1</span>;
<span class="cm-keyword">while</span> (<span class="cm-variable">count</span> <span class="cm-operator">&lt;=</span> <span class="cm-number">10</span>) {
  <span class="cm-variable">total</span> <span class="cm-operator">+=</span> <span class="cm-variable">count</span>;
  <span class="cm-variable">count</span> <span class="cm-operator">+=</span> <span class="cm-number">1</span>;
}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">total</span>);</pre>
<p><a class="p_ident" id="p_Sy8N6Qcb09" href="./05_higher_order.html#p_Sy8N6Qcb09"></a>Втората се позовава на две външни функции и е с дължина един ред.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_OULOwD7HOm" href="./05_higher_order.html#c_OULOwD7HOm"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">sum</span>(<span class="cm-variable">range</span>(<span class="cm-number">1</span>, <span class="cm-number">10</span>)));</pre>
<p><a class="p_ident" id="p_srOi7846QY" href="./05_higher_order.html#p_srOi7846QY"></a>Коя е по-вероятно да съдържа бъг?</p>
<p><a class="p_ident" id="p_G+ApGqjOk4" href="./05_higher_order.html#p_G+ApGqjOk4"></a>Ако се позовем на размера на определенията за <code>sum</code> и <code>range</code>, втората програма е по-голяма от първата. Но все пак, мога да твърдя, че е по-вероятно да бъде вярна.</p>
<p><a class="p_ident" id="p_pkQRvZqQ0u" href="./05_higher_order.html#p_pkQRvZqQ0u"></a>По-вероятно е да бъде вярна, защото отговорът се изразява в речника, който съответства на решението на проблема. Сумирането на поредица от номера не е за цикли и броячи. Става въпрос за обхват и събиране.</p>
<p><a class="p_ident" id="p_VwxmDNivhe" href="./05_higher_order.html#p_VwxmDNivhe"></a>Определенията на тази лексика (функциите <code>sum</code> и <code>range</code>), все още включват цикли, броячи и други съпътстващи подробности. Но тъй като са по-прости понятия за изразяване на програмата, като цяло, те са по-вероятно да са правилни.</p>
<h2><a class="h_ident" id="h_j9ps8qrlyo" href="./05_higher_order.html#h_j9ps8qrlyo"></a>Абстракция</h2>
<p><a class="p_ident" id="p_ZPK6t/LrMG" href="./05_higher_order.html#p_ZPK6t/LrMG"></a>В контекста на програмирането, тези видове речници, обикновено се наричат абстракции. Абстракциите крият информация и ни дават възможност да говорим за проблема на по-високо (по- абстрактно) ниво.</p>
<p><a class="p_ident" id="p_XMbJPaIiI4" href="./05_higher_order.html#p_XMbJPaIiI4"></a>Като аналогия, да сравним тези две рецепти за грахова супа:</p>
<blockquote>
<p><a class="p_ident" id="p_F+PunfZCXq" href="./05_higher_order.html#p_F+PunfZCXq"></a>Сложете 1 чаша сушен грах на човек в контейнер. Добавете вода, докато се покрие добре. Оставете граха във водата в продължение на най-малко 12 часа. Вземете граха от контейнера и го сложете в тенджера за готвене. Добавете 4 чаши вода на човек. Покрийте тенджерата с капак и варете граха в продължение на два часа. Вземете половин глава лук на човек. Нарежете го на парчета с нож. Добавете го към граха. Вземете един морков на човек. Нарежете го на парчета. С нож! Добавете го към граха. Гответе още 10 минути.”</p>

</blockquote>
<p><a class="p_ident" id="p_jOZH7oGiYb" href="./05_higher_order.html#p_jOZH7oGiYb"></a>И втората рецепта:</p>
<blockquote>
<p><a class="p_ident" id="p_iNBZReprTd" href="./05_higher_order.html#p_iNBZReprTd"></a>На човек: 1 чаша изсушен грах, половин нарязан лук, стрък целина и един морков.</p>
<p><a class="p_ident" id="p_k5rI5P5p5u" href="./05_higher_order.html#p_k5rI5P5p5u"></a>Накиснете граха в продължение на 12 часа. Оставете го да къкри 2 часа в 4 чаши вода (на човек). Добавете нарязаните лук и зеленчуци. Гответе още 10 минути.”</p>

</blockquote>
<p><a class="p_ident" id="p_cSeY164LbX" href="./05_higher_order.html#p_cSeY164LbX"></a>Втората е по-кратка и по-лесна да се интерпретира. Но вие трябва да разбирате от някакво готвене свързано със думи, като: накисване, оставете да къкри, нарязване и предполагам зеленчуци.</p>
<p><a class="p_ident" id="p_g/g3l7uyEG" href="./05_higher_order.html#p_g/g3l7uyEG"></a>При програмирането не можем да разчитаме, че всички думи, от които се нуждаем ни чакат в речника. По този начин може да попаднем в схемата на първата рецепта - посочване на работата с конкретните стъпки, които компютъра трябва да извърши, една по една, сляп за концепциите на изразяване от по-високо ниво.</p>
<p><a class="p_ident" id="p_SfvOkDsRNZ" href="./05_higher_order.html#p_SfvOkDsRNZ"></a>Това трябва да се превърне във втора природа на програмиста, да забележи, когато една концепция се моли да бъде абстрактна нова дума.</p>
<h2><a class="h_ident" id="h_inPZJ813r4" href="./05_higher_order.html#h_inPZJ813r4"></a>Абстрактно прекосяване на масив</h2>
<p><a class="p_ident" id="p_kYV0l7wLUe" href="./05_higher_order.html#p_kYV0l7wLUe"></a>Обикновените функции, които сме виждали досега са добър пример за изграждане на абстракции. Но понякога те са кратки.</p>
<p><a class="p_ident" id="p_zubh2XbQ26" href="./05_higher_order.html#p_zubh2XbQ26"></a>В <a href="./04_data.html#data">предишната глава</a>, този вид <code>for</code> цикъл направи няколко завъртания:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_LwyYCeYiUF" href="./05_higher_order.html#c_LwyYCeYiUF"></a><span class="cm-keyword">var</span> <span class="cm-variable">array</span> <span class="cm-operator">=</span> [<span class="cm-number">1</span>, <span class="cm-number">2</span>, <span class="cm-number">3</span>];
<span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-variable">i</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable">i</span> <span class="cm-operator">&lt;</span> <span class="cm-variable">array</span>.<span class="cm-property">length</span>; <span class="cm-variable">i</span><span class="cm-operator">++</span>) {
  <span class="cm-keyword">var</span> <span class="cm-variable">current</span> <span class="cm-operator">=</span> <span class="cm-variable">array</span>[<span class="cm-variable">i</span>];
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">current</span>);
}</pre>
<p><a class="p_ident" id="p_NFtmq7O3su" href="./05_higher_order.html#p_NFtmq7O3su"></a>Цикъла се опитва да каже: “Вземи всеки елемент от масива и го изведи в конзолата”. Но той използва по-заобиколен начин, който включва брояч <code>i</code>, проверка за дължината на масива и допълнителна променлива-декларация за избиране на текущия елемент.
Освен, че е малко грозно, това ни дава много място за потенциални грешки. Ние може случайно да използваме повторно  променливата <code>i</code>, да сбъркаме <code>length</code> с <code>lenght</code>, да объркаме <code>i</code> с <code>current</code> и т.н.</p>
<p><a class="p_ident" id="p_Ij8hUSNURG" href="./05_higher_order.html#p_Ij8hUSNURG"></a>Така, че нека се опитаме да направим това, абстрактно под нова функция. Сещате ли се за начин?</p>
<p><a class="p_ident" id="p_QZzSQpGUXs" href="./05_higher_order.html#p_QZzSQpGUXs"></a>Е, това е лесно да се напише функция, която преминава през масив и извиква <code>console.log</code> на всеки елемент.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_zrjk1tE+gJ" href="./05_higher_order.html#c_zrjk1tE+gJ"></a><span class="cm-keyword">function</span> <span class="cm-variable">logEach</span>(<span class="cm-def">array</span>) {
  <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">i</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">i</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">array</span>.<span class="cm-property">length</span>; <span class="cm-variable-2">i</span><span class="cm-operator">++</span>)
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable-2">array</span>[<span class="cm-variable-2">i</span>]);
}</pre>
<p id="forEach"><a class="p_ident" id="p_q8hNTrfIYb" href="./05_higher_order.html#p_q8hNTrfIYb"></a>Но ако искаме да направим нещо по-различно от зареждане на елементи? Тъй като “направим нещо” може да бъде представено, като функция, а функциите са само стойности, ние можем да променим нашите действия, като стойност на функция.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_on8vSTDMIU" href="./05_higher_order.html#c_on8vSTDMIU"></a><span class="cm-keyword">function</span> <span class="cm-variable">forEach</span>(<span class="cm-def">array</span>, <span class="cm-def">action</span>) {
  <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">i</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">i</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">array</span>.<span class="cm-property">length</span>; <span class="cm-variable-2">i</span><span class="cm-operator">++</span>)
    <span class="cm-variable-2">action</span>(<span class="cm-variable-2">array</span>[<span class="cm-variable-2">i</span>]);
}

<span class="cm-variable">forEach</span>([<span class="cm-string">"Wampeter"</span>, <span class="cm-string">"Foma"</span>, <span class="cm-string">"Granfalloon"</span>], <span class="cm-variable">console</span>.<span class="cm-property">log</span>);
<span class="cm-comment">// → Wampeter</span>
<span class="cm-comment">// → Foma</span>
<span class="cm-comment">// → Granfalloon</span></pre>
<p><a class="p_ident" id="p_gLkhZ+aBcQ" href="./05_higher_order.html#p_gLkhZ+aBcQ"></a>(В някои браузъри, извикана <code>console.log</code> по този начин не работи. Можете да използвате <code>alert</code> вместо <code>console.log</code>, ако този пример не работи.)</p>
<p><a class="p_ident" id="p_TXDEyQXjy/" href="./05_higher_order.html#p_TXDEyQXjy/"></a>Често не подаваме предварително определена функция, като <code>forEach</code>, но можем да създадем стойност на функцията на място.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_wRpVmSHeqP" href="./05_higher_order.html#c_wRpVmSHeqP"></a><span class="cm-keyword">var</span> <span class="cm-variable">numbers</span> <span class="cm-operator">=</span> [<span class="cm-number">1</span>, <span class="cm-number">2</span>, <span class="cm-number">3</span>, <span class="cm-number">4</span>, <span class="cm-number">5</span>], <span class="cm-variable">sum</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>;
<span class="cm-variable">forEach</span>(<span class="cm-variable">numbers</span>, <span class="cm-keyword">function</span>(<span class="cm-def">number</span>) {
  <span class="cm-variable">sum</span> <span class="cm-operator">+=</span> <span class="cm-variable-2">number</span>;
});
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">sum</span>);
<span class="cm-comment">// → 15</span></pre>
<p><a class="p_ident" id="p_v2REJFVWCD" href="./05_higher_order.html#p_v2REJFVWCD"></a>Това много прилича на класически <code>for</code> цикъл, с тяло написано, като блок под него. Въпреки това, сега тялото е вътре в стойността на функцията, както и вътре в скобите на извиканата <code>forEach</code>. Ето защо скобите трябва да бъдат затворени със затварящи скоби.</p>
<p><a class="p_ident" id="p_u1F6T5TuZI" href="./05_higher_order.html#p_u1F6T5TuZI"></a>Използвайки този модел, можем да зададем име на променлива за текущия елемент (<code>number</code>), а не да се налага да го вземаме от масива ръчно. </p>
<p><a class="p_ident" id="p_w5leJJdYGK" href="./05_higher_order.html#p_w5leJJdYGK"></a>В действителност, ние не трябва да пишем на ново <code>forEach</code>. Той се предлага, като стандартен метод за масиви. В масива вече е предвидено, как действа метода <code>forEach</code>, вземайки само един задължителен аргумент: функцията ще бъде изпълнена за всеки елемент.</p>
<p><a class="p_ident" id="p_BbxEeZ0Pmw" href="./05_higher_order.html#p_BbxEeZ0Pmw"></a>За да се убедите, колко полезно е това да погледнем назад към функцията от <a href="./04_data.html#analysis">предишната глава</a>. Тя съдържа два цикъла преминаващи през масива.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_1CXbGUgiP6" href="./05_higher_order.html#c_1CXbGUgiP6"></a><span class="cm-keyword">function</span> <span class="cm-variable">gatherCorrelations</span>(<span class="cm-def">journal</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">phis</span> <span class="cm-operator">=</span> {};
  <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">entry</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">entry</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">journal</span>.<span class="cm-property">length</span>; <span class="cm-variable-2">entry</span><span class="cm-operator">++</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">events</span> <span class="cm-operator">=</span> <span class="cm-variable-2">journal</span>[<span class="cm-variable-2">entry</span>].<span class="cm-property">events</span>;
    <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">i</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">i</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">events</span>.<span class="cm-property">length</span>; <span class="cm-variable-2">i</span><span class="cm-operator">++</span>) {
      <span class="cm-keyword">var</span> <span class="cm-def">event</span> <span class="cm-operator">=</span> <span class="cm-variable-2">events</span>[<span class="cm-variable-2">i</span>];
      <span class="cm-keyword">if</span> (<span class="cm-operator">!</span>(<span class="cm-variable-2">event</span> <span class="cm-keyword">in</span> <span class="cm-variable-2">phis</span>))
        <span class="cm-variable-2">phis</span>[<span class="cm-variable-2">event</span>] <span class="cm-operator">=</span> <span class="cm-variable">phi</span>(<span class="cm-variable">tableFor</span>(<span class="cm-variable-2">event</span>, <span class="cm-variable-2">journal</span>));
    }
  }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">phis</span>;
}</pre>
<p><a class="p_ident" id="p_CGf69rc/Yq" href="./05_higher_order.html#p_CGf69rc/Yq"></a>Работата с <code>forEach</code> я прави малко по-къса и малко по-чиста.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_gIY8Dk2DPY" href="./05_higher_order.html#c_gIY8Dk2DPY"></a><span class="cm-keyword">function</span> <span class="cm-variable">gatherCorrelations</span>(<span class="cm-def">journal</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">phis</span> <span class="cm-operator">=</span> {};
  <span class="cm-variable-2">journal</span>.<span class="cm-property">forEach</span>(<span class="cm-keyword">function</span>(<span class="cm-def">entry</span>) {
    <span class="cm-variable-2">entry</span>.<span class="cm-property">events</span>.<span class="cm-property">forEach</span>(<span class="cm-keyword">function</span>(<span class="cm-def">event</span>) {
      <span class="cm-keyword">if</span> (<span class="cm-operator">!</span>(<span class="cm-variable-2">event</span> <span class="cm-keyword">in</span> <span class="cm-variable-2">phis</span>))
        <span class="cm-variable-2">phis</span>[<span class="cm-variable-2">event</span>] <span class="cm-operator">=</span> <span class="cm-variable">phi</span>(<span class="cm-variable">tableFor</span>(<span class="cm-variable-2">event</span>, <span class="cm-variable-2">journal</span>));
    });
  });
  <span class="cm-keyword">return</span> <span class="cm-variable-2">phis</span>;
}</pre>
<h2><a class="h_ident" id="h_xxCc98lOBK" href="./05_higher_order.html#h_xxCc98lOBK"></a>По-високо ниво функции</h2>
<p><a class="p_ident" id="p_cao2fH68Tj" href="./05_higher_order.html#p_cao2fH68Tj"></a>Функции, които работят в други функции или ги вземат, като аргументи  или се връщат, като аргументи, се наричат "higher-order functions". Ако вече сте приели факта, че функциите са обикновени стойности, няма нищо особено и забележимо във факта, че съществуват такива функции. Терминът идва от математиката, където вземат разграничаването между функциите и другите стойности по-сериозно.</p>
<p><a class="p_ident" id="p_+cgNTV2i2y" href="./05_higher_order.html#p_+cgNTV2i2y"></a>По-високото ниво функции ни позволява абстрактни действия, а не само стойности. Те се прилагат в различни форми. Например, може да имате функции, които създават нови функции.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_9JAVbcWLFt" href="./05_higher_order.html#c_9JAVbcWLFt"></a><span class="cm-keyword">function</span> <span class="cm-variable">greaterThan</span>(<span class="cm-def">n</span>) {
  <span class="cm-keyword">return</span> <span class="cm-keyword">function</span>(<span class="cm-def">m</span>) { <span class="cm-keyword">return</span> <span class="cm-variable-2">m</span> <span class="cm-operator">&gt;</span> <span class="cm-variable-2">n</span>; };
}
<span class="cm-keyword">var</span> <span class="cm-variable">greaterThan10</span> <span class="cm-operator">=</span> <span class="cm-variable">greaterThan</span>(<span class="cm-number">10</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">greaterThan10</span>(<span class="cm-number">11</span>));
<span class="cm-comment">// → true</span></pre>
<p><a class="p_ident" id="p_MKDSIQ0X9D" href="./05_higher_order.html#p_MKDSIQ0X9D"></a>И може да имаме функции, които променят други функции.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_JVArXJ1Pc1" href="./05_higher_order.html#c_JVArXJ1Pc1"></a><span class="cm-keyword">function</span> <span class="cm-variable">noisy</span>(<span class="cm-def">f</span>) {
  <span class="cm-keyword">return</span> <span class="cm-keyword">function</span>(<span class="cm-def">arg</span>) {
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"calling with"</span>, <span class="cm-variable-2">arg</span>);
    <span class="cm-keyword">var</span> <span class="cm-def">val</span> <span class="cm-operator">=</span> <span class="cm-variable-2">f</span>(<span class="cm-variable-2">arg</span>);
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"called with"</span>, <span class="cm-variable-2">arg</span>, <span class="cm-string">"- got"</span>, <span class="cm-variable-2">val</span>);
    <span class="cm-keyword">return</span> <span class="cm-variable-2">val</span>;
  };
}
<span class="cm-variable">noisy</span>(<span class="cm-variable">Boolean</span>)(<span class="cm-number">0</span>);
<span class="cm-comment">// → calling with 0</span>
<span class="cm-comment">// → called with 0 - got false</span></pre>
<p><a class="p_ident" id="p_2qBy/XBHVa" href="./05_higher_order.html#p_2qBy/XBHVa"></a>Можем да пишем функции, които осигуряват нови видове контрол на потока.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_IiJsXvslVu" href="./05_higher_order.html#c_IiJsXvslVu"></a><span class="cm-keyword">function</span> <span class="cm-variable">unless</span>(<span class="cm-def">test</span>, <span class="cm-def">then</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable-2">test</span>) <span class="cm-variable-2">then</span>();
}
<span class="cm-keyword">function</span> <span class="cm-variable">repeat</span>(<span class="cm-def">times</span>, <span class="cm-def">body</span>) {
  <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">i</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">i</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">times</span>; <span class="cm-variable-2">i</span><span class="cm-operator">++</span>) <span class="cm-variable-2">body</span>(<span class="cm-variable-2">i</span>);
}

<span class="cm-variable">repeat</span>(<span class="cm-number">3</span>, <span class="cm-keyword">function</span>(<span class="cm-def">n</span>) {
  <span class="cm-variable">unless</span>(<span class="cm-variable-2">n</span> <span class="cm-operator">%</span> <span class="cm-number">2</span>, <span class="cm-keyword">function</span>() {
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable-2">n</span>, <span class="cm-string">"is even"</span>);
  });
});
<span class="cm-comment">// → 0 is even</span>
<span class="cm-comment">// → 2 is even</span></pre>
<p><a class="p_ident" id="p_i6rGSdWQvz" href="./05_higher_order.html#p_i6rGSdWQvz"></a>Лексикалното определяне на обхвата от правила, което обсъдихме в <a href="./03_functions.html#scoping">Глава 3</a>, работи в наша полза, когато използваме функциите по този начин. В предишния пример, променливата <code>n</code> е параметър към външната функция. Но вътрешната функция живее в средата на външната и тя може да използва <code>n</code>. Телата на такива вътрешни функции могат да получат достъп до променливите около тях. Те могат да играят роля подобна на <code>{}</code> блокове, използвани в редовни цикли и условни конструкции. Важна разлика е, че променливи декларирани вътре във вътрешните функции, не попадат в заобикалящата среда на външната функция. И това обикновено е нещо добро.</p>
<h2><a class="h_ident" id="h_7/X8BSjdvi" href="./05_higher_order.html#h_7/X8BSjdvi"></a>Подаване на аргументи</h2>
<p><a class="p_ident" id="p_IYAO9/PwTt" href="./05_higher_order.html#p_IYAO9/PwTt"></a>Функцията <code>noisy</code> определена по-рано, която увива своя аргумент в друга функция, има доста сериозен пропуск.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_9Deoi4g6M/" href="./05_higher_order.html#c_9Deoi4g6M/"></a><span class="cm-keyword">function</span> <span class="cm-variable">noisy</span>(<span class="cm-def">f</span>) {
  <span class="cm-keyword">return</span> <span class="cm-keyword">function</span>(<span class="cm-def">arg</span>) {
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"calling with"</span>, <span class="cm-variable-2">arg</span>);
    <span class="cm-keyword">var</span> <span class="cm-def">val</span> <span class="cm-operator">=</span> <span class="cm-variable-2">f</span>(<span class="cm-variable-2">arg</span>);
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"called with"</span>, <span class="cm-variable-2">arg</span>, <span class="cm-string">"- got"</span>, <span class="cm-variable-2">val</span>);
    <span class="cm-keyword">return</span> <span class="cm-variable-2">val</span>;
  };
}</pre>
<p><a class="p_ident" id="p_xa/8T14jAc" href="./05_higher_order.html#p_xa/8T14jAc"></a>Ако <code>f</code> взема повече от един аргумент,  получава само първия. Бихме могли да добавим един куп аргументи към вътрешната функция (<code>arg1</code>,
<code>arg2</code> и т.н.) и да ги прехвърлим към <code>f</code>, но не е ясно, колко от тях ще бъдат достъпни. Това решение също би лишило <code>f</code> от част от информацията в <code>arguments.length</code>. Тъй като винаги ще взема същия брой аргументи, колкото първоначално са му били зададени.</p>
<p><a class="p_ident" id="p_d8oC4azbX1" href="./05_higher_order.html#p_d8oC4azbX1"></a>За тези видове ситуации, функциите в JavaScript имат метода <code>apply</code>. Може да го сложите в масив (или масиво-подобен обект) от аргументи и да извикате функцията с тези аргументи.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_OwePsf3FVa" href="./05_higher_order.html#c_OwePsf3FVa"></a><span class="cm-keyword">function</span> <span class="cm-variable">transparentWrapping</span>(<span class="cm-def">f</span>) {
  <span class="cm-keyword">return</span> <span class="cm-keyword">function</span>() {
    <span class="cm-keyword">return</span> <span class="cm-variable-2">f</span>.<span class="cm-property">apply</span>(<span class="cm-atom">null</span>, <span class="cm-variable-2">arguments</span>);
  };
}</pre>
<p><a class="p_ident" id="p_DzgFx1ko9R" href="./05_higher_order.html#p_DzgFx1ko9R"></a>Това е безполезна функция, но тя показва модела, който ни интересува - функцията връща  всички подадени аргументи и само тези аргументи към <code>f</code>. Тя прави това, чрез подаване на свой собствен <code>arguments</code> обект към <code>apply</code>. Първият аргумент към <code>apply</code>, който ние подаваме тук е <code>null</code>, който може да се използва за симулиране на извикване на метод. Ще се върнем към това в 
<a href="./06_object.html#call_method">следващата глава</a>.</p>
<h2><a class="h_ident" id="h_AxpOdvCznQ" href="./05_higher_order.html#h_AxpOdvCznQ"></a>JSON</h2>
<p><a class="p_ident" id="p_A2VaNOTR7R" href="./05_higher_order.html#p_A2VaNOTR7R"></a>По-високото ниво функции, които по някакъв начин прилагат функция върху елементите на даден масив, са широко използвани в JavaScript. Метода <code>forEach</code> е най-примитивната такава функция. Има редица други варианти на методи за масиви. За да се запознаем с тях, нека си поиграем с друг набор от данни.</p>
<p><a class="p_ident" id="p_U8cxfiInkI" href="./05_higher_order.html#p_U8cxfiInkI"></a>Преди няколко години, попаднах на много архиви събрани и поставени на едно място в книга, посветена на историята на моето семейство (Haverbeke—meaning Oatbrook). Отворих я с надеждата да намеря рицари, пирати и алхимици...., но книгата се оказа пълна най-вече с фламандски фермери. За забавление, извлякох данните на моите преки предци и ги поставих в електронен формат.</p>
<p><a class="p_ident" id="p_kyOqr/Ovkw" href="./05_higher_order.html#p_kyOqr/Ovkw"></a>Файлът изглежда нещо такова:</p>
<pre data-language="application/json" class="snippet cm-s-default"><a class="c_ident" id="c_ndJ1dhsRpC" href="./05_higher_order.html#c_ndJ1dhsRpC"></a>[
  {<span class="cm-string cm-property">"name"</span>: <span class="cm-string">"Emma de Milliano"</span>, <span class="cm-string cm-property">"sex"</span>: <span class="cm-string">"f"</span>,
   <span class="cm-string cm-property">"born"</span>: <span class="cm-number">1876</span>, <span class="cm-string cm-property">"died"</span>: <span class="cm-number">1956</span>,
   <span class="cm-string cm-property">"father"</span>: <span class="cm-string">"Petrus de Milliano"</span>,
   <span class="cm-string cm-property">"mother"</span>: <span class="cm-string">"Sophia van Damme"</span>},
  {<span class="cm-string cm-property">"name"</span>: <span class="cm-string">"Carolus Haverbeke"</span>, <span class="cm-string cm-property">"sex"</span>: <span class="cm-string">"m"</span>,
   <span class="cm-string cm-property">"born"</span>: <span class="cm-number">1832</span>, <span class="cm-string cm-property">"died"</span>: <span class="cm-number">1905</span>,
   <span class="cm-string cm-property">"father"</span>: <span class="cm-string">"Carel Haverbeke"</span>,
   <span class="cm-string cm-property">"mother"</span>: <span class="cm-string">"Maria van Brussel"</span>},
  <span class="cm-variable">…</span> <span class="cm-variable">and</span> <span class="cm-variable">so</span> <span class="cm-variable">on</span>
]</pre>
<p><a class="p_ident" id="p_TtSCtpw/XN" href="./05_higher_order.html#p_TtSCtpw/XN"></a>Този формат се нарича JSON (произнася се”Джейсън”), което е съкращение от JavaScript Object Notation. Той се използва широко, както за съхранение на данни, така и за комуникационен формат в Web.</p>
<p><a class="p_ident" id="p_LkHACkXND1" href="./05_higher_order.html#p_LkHACkXND1"></a>JSON подобно на JavaScript е начин за писане на масиви и обекти, но с няколко ограничения. Всички имена на свойства трябва да бъдат заобиколени от двойни кавички и са позволени само прости изрази - данни. Не са позволени: извиквания на функции, променливи или нещо, което включва действително изчисление. Коментарите също не са разрешени в JSON.</p>
<p><a class="p_ident" id="p_1IU60Zh2Af" href="./05_higher_order.html#p_1IU60Zh2Af"></a>JavaScript ни дава функциите <code>JSON.parse</code> и <code>JSON.stringify</code>, които преобразуват данни от и към този формат. Първата взема стойност от JavaScript и връща кодиран JSON <em>string</em> формат. Втората взема този <em>string</em> и го преобразува в кодирана стойност.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_mzHhvmUWat" href="./05_higher_order.html#c_mzHhvmUWat"></a><span class="cm-keyword">var</span> <span class="cm-variable">string</span> <span class="cm-operator">=</span> <span class="cm-variable">JSON</span>.<span class="cm-property">stringify</span>({<span class="cm-property">name</span>: <span class="cm-string">"X"</span>, <span class="cm-property">born</span>: <span class="cm-number">1980</span>});
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">string</span>);
<span class="cm-comment">// → {"name":"X","born":1980}</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">JSON</span>.<span class="cm-property">parse</span>(<span class="cm-variable">string</span>).<span class="cm-property">born</span>);
<span class="cm-comment">// → 1980</span></pre>
<p><a class="p_ident" id="p_NDrk0od6QR" href="./05_higher_order.html#p_NDrk0od6QR"></a>Променливата <code>ANCESTRY_FILE</code> е налична в пясъчника на тази глава и във <a href="./code/ancestry.js">файл за изтегляне</a> от уеб-сайта, който съдържа моя JSON файл, като <em>string</em>. Нека го декодираме и да видим, колко много хора съдържа.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_iIU5d+0x1R" href="./05_higher_order.html#c_iIU5d+0x1R"></a><span class="cm-keyword">var</span> <span class="cm-variable">ancestry</span> <span class="cm-operator">=</span> <span class="cm-variable">JSON</span>.<span class="cm-property">parse</span>(<span class="cm-variable">ANCESTRY_FILE</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">ancestry</span>.<span class="cm-property">length</span>);
<span class="cm-comment">// → 39</span></pre>
<h2><a class="h_ident" id="h_1BJbwiI0gI" href="./05_higher_order.html#h_1BJbwiI0gI"></a>Филтриране  на  масив</h2>
<p><a class="p_ident" id="p_Vpf83lHLbL" href="./05_higher_order.html#p_Vpf83lHLbL"></a>Следната функция, може да бъде полезна за да разберем, кои са хората, които са били млади през 1924г., в масива от данни на моите предци. Тя филтрира елементите, които не преминават теста в масива.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_VcGTxSYgrf" href="./05_higher_order.html#c_VcGTxSYgrf"></a><span class="cm-keyword">function</span> <span class="cm-variable">filter</span>(<span class="cm-def">array</span>, <span class="cm-def">test</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">passed</span> <span class="cm-operator">=</span> [];
  <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">i</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">i</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">array</span>.<span class="cm-property">length</span>; <span class="cm-variable-2">i</span><span class="cm-operator">++</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">test</span>(<span class="cm-variable-2">array</span>[<span class="cm-variable-2">i</span>]))
      <span class="cm-variable-2">passed</span>.<span class="cm-property">push</span>(<span class="cm-variable-2">array</span>[<span class="cm-variable-2">i</span>]);
  }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">passed</span>;
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">filter</span>(<span class="cm-variable">ancestry</span>, <span class="cm-keyword">function</span>(<span class="cm-def">person</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable-2">person</span>.<span class="cm-property">born</span> <span class="cm-operator">&gt;</span> <span class="cm-number">1900</span> <span class="cm-operator">&amp;&amp;</span> <span class="cm-variable-2">person</span>.<span class="cm-property">born</span> <span class="cm-operator">&lt;</span> <span class="cm-number">1925</span>;
}));
<span class="cm-comment">// → [{name: "Philibert Haverbeke", …}, …]</span></pre>
<p><a class="p_ident" id="p_F1sdIqvMdQ" href="./05_higher_order.html#p_F1sdIqvMdQ"></a>Функцията използва аргумент с име <code>test</code>, като стойност на функция за да попълни “разминаването” в изчислението. <code>Test</code> функцията се извиква за всеки елемент и върнатата и стойност определя дали даден елемент е включен във върнатия масив.</p>
<p><a class="p_ident" id="p_l78Pj0p/pD" href="./05_higher_order.html#p_l78Pj0p/pD"></a>Трима души са били млади и живи през 1924г: дядо ми, баба ми и пра-леля ми.</p>
<p><a class="p_ident" id="p_vcnUQxte/7" href="./05_higher_order.html#p_vcnUQxte/7"></a>Забележете как функцията <code>filter</code>, вместо да изтрива елементи от съществуващия масив, изгражда нов масив само с елементите, които преминават теста. Тази функция е чиста. Тя не променя масива, който и е даден.</p>
<p><a class="p_ident" id="p_OduOippCCU" href="./05_higher_order.html#p_OduOippCCU"></a>Подобно на <code>forEach</code>, така и <code>filter</code> също е стандартен метод за масиви. Примерът дефинира функция само за да покаже това, което тя прави вътрешно. От сега на татък, ще я използваме така:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_V5IGmt9uTK" href="./05_higher_order.html#c_V5IGmt9uTK"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">ancestry</span>.<span class="cm-property">filter</span>(<span class="cm-keyword">function</span>(<span class="cm-def">person</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable-2">person</span>.<span class="cm-property">father</span> <span class="cm-operator">==</span> <span class="cm-string">"Carel Haverbeke"</span>;
}));
<span class="cm-comment">// → [{name: "Carolus Haverbeke", …}]</span></pre>
<h2><a class="h_ident" id="h_lJEtQ+qjXz" href="./05_higher_order.html#h_lJEtQ+qjXz"></a>Трансформиране  с  карта (map)</h2>
<p><a class="p_ident" id="p_iZsa8JAje9" href="./05_higher_order.html#p_iZsa8JAje9"></a>Да кажем, че имаме масив от обекти представляващи хора, направени чрез филтриране на масива <code>ancestry</code> по някакъв начин. Но ние искаме масив от имена, който е по-лесен за четене.</p>
<p><a class="p_ident" id="p_/HoP3C1P28" href="./05_higher_order.html#p_/HoP3C1P28"></a>Метода <code>map</code> трансформира масив чрез прилагане на функция върху всички свои елементи и изгражда нов масив от върнатите стойности. Новият масив има същата дължина, като входящия масив, но съдържанието му е “mapped” към новата форма на функцията.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_Oc5rRWigBO" href="./05_higher_order.html#c_Oc5rRWigBO"></a><span class="cm-keyword">function</span> <span class="cm-variable">map</span>(<span class="cm-def">array</span>, <span class="cm-def">transform</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">mapped</span> <span class="cm-operator">=</span> [];
  <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">i</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">i</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">array</span>.<span class="cm-property">length</span>; <span class="cm-variable-2">i</span><span class="cm-operator">++</span>)
    <span class="cm-variable-2">mapped</span>.<span class="cm-property">push</span>(<span class="cm-variable-2">transform</span>(<span class="cm-variable-2">array</span>[<span class="cm-variable-2">i</span>]));
  <span class="cm-keyword">return</span> <span class="cm-variable-2">mapped</span>;
}

<span class="cm-keyword">var</span> <span class="cm-variable">overNinety</span> <span class="cm-operator">=</span> <span class="cm-variable">ancestry</span>.<span class="cm-property">filter</span>(<span class="cm-keyword">function</span>(<span class="cm-def">person</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable-2">person</span>.<span class="cm-property">died</span> <span class="cm-operator">-</span> <span class="cm-variable-2">person</span>.<span class="cm-property">born</span> <span class="cm-operator">&gt;</span> <span class="cm-number">90</span>;
});
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">map</span>(<span class="cm-variable">overNinety</span>, <span class="cm-keyword">function</span>(<span class="cm-def">person</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable-2">person</span>.<span class="cm-property">name</span>;
}));
<span class="cm-comment">// → ["Clara Aernoudts", "Emile Haverbeke",</span>
<span class="cm-comment">//    "Maria Haverbeke"]</span></pre>
<p><a class="p_ident" id="p_Jd3axE7OGU" href="./05_higher_order.html#p_Jd3axE7OGU"></a>Интересно е, че хората, които са живели най-малко до 90г. са същите трима души, които видяхме преди: хората, които са били млади през 1920г., което е най-близкото поколение в моя набор от данни. Предполагам, че медицината е извървяла дълъг път.</p>
<p><a class="p_ident" id="p_kz8fxQbtBm" href="./05_higher_order.html#p_kz8fxQbtBm"></a>Подобно на <code>forEach</code> и <code>filter</code>, <code>map</code> също е стандартен метод за масиви.</p>
<h2><a class="h_ident" id="h_fx3e34kT/k" href="./05_higher_order.html#h_fx3e34kT/k"></a>Обобщаване  с  намаляване</h2>
<p><a class="p_ident" id="p_jc3nW2aN35" href="./05_higher_order.html#p_jc3nW2aN35"></a>Друг често срещан модел за изчисляване на масиви е изчисляване на една стойност от тях. Нашия повтарящ се пример със сумиране на набор от цифри е пример за това. Друг пример ще бъде намирането на лице с най-ранната година на раждане в масива от данни.</p>
<p><a class="p_ident" id="p_AR3Kp1oBC4" href="./05_higher_order.html#p_AR3Kp1oBC4"></a>По-високото ниво на операцията, която представлява този модел се нарича <em>reduce</em> (намаляване или понякога <em>fold</em>). Можете да мислите за него, като сгъване на масива в един елемент в даден момент. 
Когато сумираме номерата, ще започнем с числото нула и за всеки елемент го комбинираме с текущата сума чрез добавяне на две.</p>
<p><a class="p_ident" id="p_2+GsHstzgE" href="./05_higher_order.html#p_2+GsHstzgE"></a>Параметрите на функцията <code>reduce</code> са освен масива, функция за комбиниране и начална стойност. Тази функция е малко по-малка от <code>filter</code> и <code>map</code>, така че и обърнете особено внимание.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_0Tuk2O6cyM" href="./05_higher_order.html#c_0Tuk2O6cyM"></a><span class="cm-keyword">function</span> <span class="cm-variable">reduce</span>(<span class="cm-def">array</span>, <span class="cm-def">combine</span>, <span class="cm-def">start</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">current</span> <span class="cm-operator">=</span> <span class="cm-variable-2">start</span>;
  <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">i</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">i</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">array</span>.<span class="cm-property">length</span>; <span class="cm-variable-2">i</span><span class="cm-operator">++</span>)
    <span class="cm-variable-2">current</span> <span class="cm-operator">=</span> <span class="cm-variable-2">combine</span>(<span class="cm-variable-2">current</span>, <span class="cm-variable-2">array</span>[<span class="cm-variable-2">i</span>]);
  <span class="cm-keyword">return</span> <span class="cm-variable-2">current</span>;
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">reduce</span>([<span class="cm-number">1</span>, <span class="cm-number">2</span>, <span class="cm-number">3</span>, <span class="cm-number">4</span>], <span class="cm-keyword">function</span>(<span class="cm-def">a</span>, <span class="cm-def">b</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable-2">a</span> <span class="cm-operator">+</span> <span class="cm-variable-2">b</span>;
}, <span class="cm-number">0</span>));
<span class="cm-comment">// → 10</span></pre>
<p><a class="p_ident" id="p_r9cFmJJTar" href="./05_higher_order.html#p_r9cFmJJTar"></a>Стандартния метод за масиви <code>reduce</code>, който разбира се съответства на тази функция, има допълнително удобство. Ако вашият масив съдържа поне един елемент, ви е позволено да пропуснете <code>start</code> аргумента. Методът ще вземе първият елемент на масива, като начална стойност и ще започне намаляване на втория елемент.</p>
<p><a class="p_ident" id="p_I1pmLx5OiJ" href="./05_higher_order.html#p_I1pmLx5OiJ"></a>За да използваме <code>reduce</code>, за да намерим най-древния известен мой предшественик, можем да напишем нещо такова:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_yFx+CUT9gj" href="./05_higher_order.html#c_yFx+CUT9gj"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">ancestry</span>.<span class="cm-property">reduce</span>(<span class="cm-keyword">function</span>(<span class="cm-def">min</span>, <span class="cm-def">cur</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">cur</span>.<span class="cm-property">born</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">min</span>.<span class="cm-property">born</span>) <span class="cm-keyword">return</span> <span class="cm-variable-2">cur</span>;
  <span class="cm-keyword">else</span> <span class="cm-keyword">return</span> <span class="cm-variable-2">min</span>;
}));
<span class="cm-comment">// → {name: "Pauwels van Haverbeke", born: 1535, …}</span></pre>
<h2><a class="h_ident" id="h_+NeFt8aXxf" href="./05_higher_order.html#h_+NeFt8aXxf"></a>Composability</h2>
<p><a class="p_ident" id="p_UHvCjnmGjM" href="./05_higher_order.html#p_UHvCjnmGjM"></a>Помислете как може да се напише предишния пример ( намиране на лице с най-ранната година на раждане) без по-високо ниво на функции. Не че кодът е много зле.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_ZzCa/ILXHh" href="./05_higher_order.html#c_ZzCa/ILXHh"></a><span class="cm-keyword">var</span> <span class="cm-variable">min</span> <span class="cm-operator">=</span> <span class="cm-variable">ancestry</span>[<span class="cm-number">0</span>];
<span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-variable">i</span> <span class="cm-operator">=</span> <span class="cm-number">1</span>; <span class="cm-variable">i</span> <span class="cm-operator">&lt;</span> <span class="cm-variable">ancestry</span>.<span class="cm-property">length</span>; <span class="cm-variable">i</span><span class="cm-operator">++</span>) {
  <span class="cm-keyword">var</span> <span class="cm-variable">cur</span> <span class="cm-operator">=</span> <span class="cm-variable">ancestry</span>[<span class="cm-variable">i</span>];
  <span class="cm-keyword">if</span> (<span class="cm-variable">cur</span>.<span class="cm-property">born</span> <span class="cm-operator">&lt;</span> <span class="cm-variable">min</span>.<span class="cm-property">born</span>)
    <span class="cm-variable">min</span> <span class="cm-operator">=</span> <span class="cm-variable">cur</span>;
}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">min</span>);
<span class="cm-comment">// → {name: "Pauwels van Haverbeke", born: 1535, …}</span></pre>
<p><a class="p_ident" id="p_EbeznYJOvD" href="./05_higher_order.html#p_EbeznYJOvD"></a>Има още няколко променливи и програмата е с два реда повече, но все още е доста лесно да се разбере.</p>
<p id="average_function"><a class="p_ident" id="p_a0FspsuDHF" href="./05_higher_order.html#p_a0FspsuDHF"></a>По-високото ниво функции започват да синеят, когато създаваме такава функция. Като пример, нека напишем код, който намира средната възраст на мъжете и жените в масива от данни.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_uqgWfWbd7m" href="./05_higher_order.html#c_uqgWfWbd7m"></a><span class="cm-keyword">function</span> <span class="cm-variable">average</span>(<span class="cm-def">array</span>) {
  <span class="cm-keyword">function</span> <span class="cm-def">plus</span>(<span class="cm-def">a</span>, <span class="cm-def">b</span>) { <span class="cm-keyword">return</span> <span class="cm-variable-2">a</span> <span class="cm-operator">+</span> <span class="cm-variable-2">b</span>; }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">array</span>.<span class="cm-property">reduce</span>(<span class="cm-variable-2">plus</span>) <span class="cm-operator">/</span> <span class="cm-variable-2">array</span>.<span class="cm-property">length</span>;
}
<span class="cm-keyword">function</span> <span class="cm-variable">age</span>(<span class="cm-def">p</span>) { <span class="cm-keyword">return</span> <span class="cm-variable-2">p</span>.<span class="cm-property">died</span> <span class="cm-operator">-</span> <span class="cm-variable-2">p</span>.<span class="cm-property">born</span>; }
<span class="cm-keyword">function</span> <span class="cm-variable">male</span>(<span class="cm-def">p</span>) { <span class="cm-keyword">return</span> <span class="cm-variable-2">p</span>.<span class="cm-property">sex</span> <span class="cm-operator">==</span> <span class="cm-string">"m"</span>; }
<span class="cm-keyword">function</span> <span class="cm-variable">female</span>(<span class="cm-def">p</span>) { <span class="cm-keyword">return</span> <span class="cm-variable-2">p</span>.<span class="cm-property">sex</span> <span class="cm-operator">==</span> <span class="cm-string">"f"</span>; }

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">average</span>(<span class="cm-variable">ancestry</span>.<span class="cm-property">filter</span>(<span class="cm-variable">male</span>).<span class="cm-property">map</span>(<span class="cm-variable">age</span>)));
<span class="cm-comment">// → 61.67</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">average</span>(<span class="cm-variable">ancestry</span>.<span class="cm-property">filter</span>(<span class="cm-variable">female</span>).<span class="cm-property">map</span>(<span class="cm-variable">age</span>)));
<span class="cm-comment">// → 54.56</span></pre>
<p><a class="p_ident" id="p_Tnj4SDSgBt" href="./05_higher_order.html#p_Tnj4SDSgBt"></a>(Това е малко глупаво, че трябва да дефинираме <code>plus</code>, като функция, но операторите в JavaScript, за разлика от функциите, не са стойности, така че не могат да се прехвърлят, като аргументи.)</p>
<p><a class="p_ident" id="p_vIaMNOYUL0" href="./05_higher_order.html#p_vIaMNOYUL0"></a>Вместо да заплетем логиката в един голям цикъл, съставяме спретнати концепции на понятията, които ни интересуват - определяне на пол, изчисляване на възраст и средно-аритметични номера. Можем да ги приложим една по една, за да получим резултата, който търсим.</p>
<p><a class="p_ident" id="p_ZOp8f8zApw" href="./05_higher_order.html#p_ZOp8f8zApw"></a>Това е страхотно за написване на ясен код. За съжаление, тази яснота има цена.</p>
<h2><a class="h_ident" id="h_KTy9HpX3R4" href="./05_higher_order.html#h_KTy9HpX3R4"></a>Разходите</h2>
<p><a class="p_ident" id="p_ROxex88LkV" href="./05_higher_order.html#p_ROxex88LkV"></a>В щастливата земя на елегантния код и красивите дъги, живее чудовище наречено <em>неефективност</em>.</p>
<p><a class="p_ident" id="p_KZv3u+lncm" href="./05_higher_order.html#p_KZv3u+lncm"></a>Програма, която обработва масив, най-общо казано, е последователност от ясно разделени стъпки, като всяка прави нещо с масива и създава нов масив. Но изграждането на всички тези междинни масиви е малко скъпо.</p>
<p><a class="p_ident" id="p_fwEhp/GEHu" href="./05_higher_order.html#p_fwEhp/GEHu"></a>По същия начин, подавайки функция към <code>forEach</code> и оставяйки този метод да се справи с итерациите на масива, за нас е удобен и лесен за четене. Но извикванията на функции в JavaScript са скъпи в сравнение с прости цикли.</p>
<p><a class="p_ident" id="p_QCCz0cq1ti" href="./05_higher_order.html#p_QCCz0cq1ti"></a>И така, има много техники, които помагат за подобряване на яснотата на програмата. Абстракциите добавят слоеве между концепциите, с които работим и грубите неща, които компютъра прави, като по този начин предизвикват машината да извърши повече работа. Това не е железен закон - има програмни езици, които имат по-добра подкрепа за изграждане на абстракции без добавяне на неефективност и дори в JavaScript, опитен програмист може да намери начини да пише абстрактно код, който е по-бърз. Но това е проблем, който идва по нататък.</p>
<p><a class="p_ident" id="p_8YtdVmu3Oc" href="./05_higher_order.html#p_8YtdVmu3Oc"></a>За щастие повечето компютри са безумно бързи. Ако обработвате скромен набор от данни или правите нещо, което трябва да се случи само по скалата на човешкото време (да речем, всеки път, когато потребителя кликне на бутон), тогава няма значение дали пишете решение, което отнема половин милисекунда или супер - оптимизирано решение, което отнема една десета от секундата.</p>
<p><a class="p_ident" id="p_s9R2GjExxl" href="./05_higher_order.html#p_s9R2GjExxl"></a>Полезно е грубо да следите, колко често парче от вашата програма се стартира. Ако имате един цикъл вътре в друг цикъл (или директно, чрез външния цикъл извиквате функция, която завършва работата на вътрешния цикъл), кодът вътре във вътрешния цикъл ще приключи с <em>N</em>×<em>M</em> пъти, където <em>N</em> е броя на повторенията на външният цикъл, а <em>M</em> е броят пъти, когато вътрешният цикъл се повтаря в рамките на всяка итерация на външния цикъл. Ако този вътрешен цикъл съдържа друг цикъл, който прави P завъртания, тялото му ще се стартира <em>M</em>×<em>N</em>×<em>P</em> пъти и т. н. Това може да бъде в големи количества и когато дадена програма е бавна, проблемът често може да бъде проследен до само една малка част от кода, който стои вътре във вътрешния цикъл.</p>
<h2><a class="h_ident" id="h_XnMZS4zMW6" href="./05_higher_order.html#h_XnMZS4zMW6"></a>Пра-пра-пра-пра...</h2>
<p><a class="p_ident" id="p_Typ91CWfYn" href="./05_higher_order.html#p_Typ91CWfYn"></a>Дядо ми, Philibert Haverbeke, е включен в базата данни. Като се започне с него, мога да проследя родословието си, за да разбера дали най-древния човек в данните - Pauwels van Haverbeke, е моя прародител. И ако е той, бих искал да знам колко ДНК теоретично споделям с него.</p>
<p><a class="p_ident" id="p_pwQeT587/V" href="./05_higher_order.html#p_pwQeT587/V"></a>За да мога да стигна до името на действителния обект, който представлява този човек, първо трябва да изградя един обект, който свързва имената с хората.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_/p8Gq6iabK" href="./05_higher_order.html#c_/p8Gq6iabK"></a><span class="cm-keyword">var</span> <span class="cm-variable">byName</span> <span class="cm-operator">=</span> {};
<span class="cm-variable">ancestry</span>.<span class="cm-property">forEach</span>(<span class="cm-keyword">function</span>(<span class="cm-def">person</span>) {
  <span class="cm-variable">byName</span>[<span class="cm-variable-2">person</span>.<span class="cm-property">name</span>] <span class="cm-operator">=</span> <span class="cm-variable-2">person</span>;
});

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">byName</span>[<span class="cm-string">"Philibert Haverbeke"</span>]);
<span class="cm-comment">// → {name: "Philibert Haverbeke", …}</span></pre>
<p><a class="p_ident" id="p_Yko1+UXeBG" href="./05_higher_order.html#p_Yko1+UXeBG"></a>Сега проблемът не е прост, трябва да се следват <code>father</code> свойствата, които трябва да преброим за да стигнем до Pauwels. Има няколко случая в родословното дърво, където хората се женели за вторите си братовчеди. Това е причина клоните на родословното дърво да се съединяват на няколко места, което означава, че аз споделям повече от 1/2<sup><em>G</em></sup> от гените на този човек, като броя <em>G</em> е за броя на поколенията между Pauwels и мен. Тази формула идва от идеята, че всяко поколение разделя генетичния фонд на две.</p>
<p><a class="p_ident" id="p_qznNjPi9uB" href="./05_higher_order.html#p_qznNjPi9uB"></a>Разумен начин да мислим за този проблем е да гледаме на него, като аналогичен на <code>reduce</code>, който свива масива до една стойност, чрез многократно съкращаване на стойности от ляво на дясно. В този случай, ние също искаме да съкратим нашата структура от данни до една стойност по начин, който следва семейните линии. Формата на данните е на родословно дърво , а не плосък списък.</p>
<p><a class="p_ident" id="p_1De08sAcOD" href="./05_higher_order.html#p_1De08sAcOD"></a>Начинът, по който искаме да намалим тази форма е с изчисляване на стойност за даден човек, чрез комбиниране на стойности от неговите предци. Това може да стане рекурсивно: ако ние сме заинтересованото лице <em>A</em>, то трябва да изчислим стойностите на родителите на <em>A</em>, което от своя страна трябва да изчисли стойностите на техните родители-“баба и дядо” и т.н. По принцип, това изисква да прегледаме един безкраен брой от хора, но тъй като нашия набор от данни е ограничен, ще трябва да спрем някъде. Ще приемем стойност по подразбиране, която да дадем на нашата функция за намаляване, която ще се използва за хора, които не са в данните. В нашия случай, тази стойност е просто нула за предположението, че хората, които не са в списъка не споделят ДНК с прародителя, който търсим.</p>
<p><a class="p_ident" id="p_B0sEhVOeSP" href="./05_higher_order.html#p_B0sEhVOeSP"></a>За дадено лице, функцията комбинира стойностите от двамата родители на даденото лице и стойността по подразбиране, и <code>reduceAncestors</code> съкращава стойност от родословното дърво.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_FR1ZA75xXV" href="./05_higher_order.html#c_FR1ZA75xXV"></a><span class="cm-keyword">function</span> <span class="cm-variable">reduceAncestors</span>(<span class="cm-def">person</span>, <span class="cm-def">f</span>, <span class="cm-def">defaultValue</span>) {
  <span class="cm-keyword">function</span> <span class="cm-def">valueFor</span>(<span class="cm-def">person</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">person</span> <span class="cm-operator">==</span> <span class="cm-atom">null</span>)
      <span class="cm-keyword">return</span> <span class="cm-variable-2">defaultValue</span>;
    <span class="cm-keyword">else</span>
      <span class="cm-keyword">return</span> <span class="cm-variable-2">f</span>(<span class="cm-variable-2">person</span>, <span class="cm-variable-2">valueFor</span>(<span class="cm-variable">byName</span>[<span class="cm-variable-2">person</span>.<span class="cm-property">mother</span>]),
                       <span class="cm-variable-2">valueFor</span>(<span class="cm-variable">byName</span>[<span class="cm-variable-2">person</span>.<span class="cm-property">father</span>]));
  }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">valueFor</span>(<span class="cm-variable-2">person</span>);
}</pre>
<p><a class="p_ident" id="p_HK0Nr6MiCM" href="./05_higher_order.html#p_HK0Nr6MiCM"></a>Вътрешната функция (<code>valueFor</code>) обработва един човек. Чрез магията на рекурсията, тя просто извиква себе си, за да обработи майката и бащата на този човек. Резултатите, заедно със самия обект на лицето се подават на <code>f</code>, който връща действителната стойност за този човек.</p>
<p><a class="p_ident" id="p_2Q4JEt3Fiv" href="./05_higher_order.html#p_2Q4JEt3Fiv"></a>След това можем да използваме това за да изчислим количеството ДНК, което дядо ми споделя с Pauwels van Haverbeke и го разделим на четири.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_DKCt/KZuIB" href="./05_higher_order.html#c_DKCt/KZuIB"></a><span class="cm-keyword">function</span> <span class="cm-variable">sharedDNA</span>(<span class="cm-def">person</span>, <span class="cm-def">fromMother</span>, <span class="cm-def">fromFather</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">person</span>.<span class="cm-property">name</span> <span class="cm-operator">==</span> <span class="cm-string">"Pauwels van Haverbeke"</span>)
    <span class="cm-keyword">return</span> <span class="cm-number">1</span>;
  <span class="cm-keyword">else</span>
    <span class="cm-keyword">return</span> (<span class="cm-variable-2">fromMother</span> <span class="cm-operator">+</span> <span class="cm-variable-2">fromFather</span>) <span class="cm-operator">/</span> <span class="cm-number">2</span>;
}
<span class="cm-keyword">var</span> <span class="cm-variable">ph</span> <span class="cm-operator">=</span> <span class="cm-variable">byName</span>[<span class="cm-string">"Philibert Haverbeke"</span>];
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">reduceAncestors</span>(<span class="cm-variable">ph</span>, <span class="cm-variable">sharedDNA</span>, <span class="cm-number">0</span>) <span class="cm-operator">/</span> <span class="cm-number">4</span>);
<span class="cm-comment">// → 0.00049</span></pre>
<p><a class="p_ident" id="p_+kx1i84Abe" href="./05_higher_order.html#p_+kx1i84Abe"></a>Лицето Pauwels van Haverbeke очевидно има 100% от ДНК-то си с Pauwels van Haverbeke ( ако не съществуват хора , които да споделят същото име в масива от данни), така че функцията връща 1 за него. Всички други хора споделят средната стойност от сумите, които техните родители споделят.</p>
<p><a class="p_ident" id="p_sxFDHiagLr" href="./05_higher_order.html#p_sxFDHiagLr"></a>Така че, статистически погледнато аз споделям около 0.05% от моето ДНК с този човек от 16-ти век. Трябва да се отбележи, че това е само статистическо приближение, а не точен резултат. Това е по-скоро малък брой в предвид, колко генетичен материал носим ( около 3 милиарда база двойки), но може би е някакъв аспект, който приближава произхода ми с Pauwels.</p>
<p><a class="p_ident" id="p_9W8GK5HRM6" href="./05_higher_order.html#p_9W8GK5HRM6"></a>Този номер може да се изчисли и без да разчитаме на <code>reduceAncestors</code>. Но разделяне на общото приближение (намаленото родословно дърво) от конкретния случай (изчислено споделено ДНК) може да подобри яснотата на кода и ни позволява да използваме повторно абстрактната част от програмата за други случаи. Например, следният код установява процентът на известни предци на човек, който е живял 70г (от потеклото, така че хората могат да бъдат преброени няколко пъти).</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_8JFA4YEKi4" href="./05_higher_order.html#c_8JFA4YEKi4"></a><span class="cm-keyword">function</span> <span class="cm-variable">countAncestors</span>(<span class="cm-def">person</span>, <span class="cm-def">test</span>) {
  <span class="cm-keyword">function</span> <span class="cm-def">combine</span>(<span class="cm-def">current</span>, <span class="cm-def">fromMother</span>, <span class="cm-def">fromFather</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">thisOneCounts</span> <span class="cm-operator">=</span> <span class="cm-variable-2">current</span> <span class="cm-operator">!=</span> <span class="cm-variable-2">person</span> <span class="cm-operator">&amp;&amp;</span> <span class="cm-variable-2">test</span>(<span class="cm-variable-2">current</span>);
    <span class="cm-keyword">return</span> <span class="cm-variable-2">fromMother</span> <span class="cm-operator">+</span> <span class="cm-variable-2">fromFather</span> <span class="cm-operator">+</span> (<span class="cm-variable-2">thisOneCounts</span> <span class="cm-operator">?</span> <span class="cm-number">1</span> : <span class="cm-number">0</span>);
  }
  <span class="cm-keyword">return</span> <span class="cm-variable">reduceAncestors</span>(<span class="cm-variable-2">person</span>, <span class="cm-variable-2">combine</span>, <span class="cm-number">0</span>);
}
<span class="cm-keyword">function</span> <span class="cm-variable">longLivingPercentage</span>(<span class="cm-def">person</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">all</span> <span class="cm-operator">=</span> <span class="cm-variable">countAncestors</span>(<span class="cm-variable-2">person</span>, <span class="cm-keyword">function</span>(<span class="cm-def">person</span>) {
    <span class="cm-keyword">return</span> <span class="cm-atom">true</span>;
  });
  <span class="cm-keyword">var</span> <span class="cm-def">longLiving</span> <span class="cm-operator">=</span> <span class="cm-variable">countAncestors</span>(<span class="cm-variable-2">person</span>, <span class="cm-keyword">function</span>(<span class="cm-def">person</span>) {
    <span class="cm-keyword">return</span> (<span class="cm-variable-2">person</span>.<span class="cm-property">died</span> <span class="cm-operator">-</span> <span class="cm-variable-2">person</span>.<span class="cm-property">born</span>) <span class="cm-operator">&gt;=</span> <span class="cm-number">70</span>;
  });
  <span class="cm-keyword">return</span> <span class="cm-variable-2">longLiving</span> <span class="cm-operator">/</span> <span class="cm-variable-2">all</span>;
}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">longLivingPercentage</span>(<span class="cm-variable">byName</span>[<span class="cm-string">"Emile Haverbeke"</span>]));
<span class="cm-comment">// → 0.129</span></pre>
<p><a class="p_ident" id="p_yX3KPrQkep" href="./05_higher_order.html#p_yX3KPrQkep"></a>Такива номера не трябва да се вземат прекалено на сериозно, предвид факта, че нашият набор от данни съдържа доста произволна колекция от хора. Но кода илюстрира факта, че <code>reduceAncestors</code> ни дава полезна част от речника за работа с данни от структура на родословно дърво.</p>
<h2><a class="h_ident" id="h_fwBD5oTMLl" href="./05_higher_order.html#h_fwBD5oTMLl"></a>Обвързване</h2>
<p><a class="p_ident" id="p_JR92h9ZvcR" href="./05_higher_order.html#p_JR92h9ZvcR"></a>Метода <code>bind</code>, който имат всички функции, създава нова функция, която ще извика оригиналната функция, но с някои от определените вече аргументи.</p>
<p><a class="p_ident" id="p_RpFvD2j6a4" href="./05_higher_order.html#p_RpFvD2j6a4"></a>Следният код показва пример на <code>bind</code> в употреба. Той дефинира функция <code>isInSet</code>, която ни казва дали даден човек е в наборa от strings. За да извикаме <code>filter</code> да събере тези обекти на лица, чиито имена са в специфичния набор от данни, можем да напишем функционален израз, който прави извикване на <code>isInSet</code> с нашия набор от данни, като първи аргумент или частично прилага <code>isInSet</code> функцията.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_P/KGz4FBMo" href="./05_higher_order.html#c_P/KGz4FBMo"></a><span class="cm-keyword">var</span> <span class="cm-variable">theSet</span> <span class="cm-operator">=</span> [<span class="cm-string">"Carel Haverbeke"</span>, <span class="cm-string">"Maria van Brussel"</span>,
              <span class="cm-string">"Donald Duck"</span>];
<span class="cm-keyword">function</span> <span class="cm-variable">isInSet</span>(<span class="cm-def">set</span>, <span class="cm-def">person</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable-2">set</span>.<span class="cm-property">indexOf</span>(<span class="cm-variable-2">person</span>.<span class="cm-property">name</span>) <span class="cm-operator">&gt;</span> <span class="cm-operator">-</span><span class="cm-number">1</span>;
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">ancestry</span>.<span class="cm-property">filter</span>(<span class="cm-keyword">function</span>(<span class="cm-def">person</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable">isInSet</span>(<span class="cm-variable">theSet</span>, <span class="cm-variable-2">person</span>);
}));
<span class="cm-comment">// → [{name: "Maria van Brussel", …},</span>
<span class="cm-comment">//    {name: "Carel Haverbeke", …}]</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">ancestry</span>.<span class="cm-property">filter</span>(<span class="cm-variable">isInSet</span>.<span class="cm-property">bind</span>(<span class="cm-atom">null</span>, <span class="cm-variable">theSet</span>)));
<span class="cm-comment">// → … same result</span></pre>
<p><a class="p_ident" id="p_P5qnPOIMMg" href="./05_higher_order.html#p_P5qnPOIMMg"></a>Извикването на <code>bind</code> връща функция, която извиква <code>isInSet</code> с <code>theSet</code>, като първи аргумент, последван от всички останали аргументи, подадени на свързващата функция.</p>
<p><a class="p_ident" id="p_j9JPuWJlk7" href="./05_higher_order.html#p_j9JPuWJlk7"></a>Първият аргумент, който е подаден в примера е <code>null</code>, той се използва за извикване на метод, подобно на първия аргумент на <code>apply</code>. Ще опишем това по-подробно в <a href="./06_object.html#call_method">следващата глава</a>.</p>
<h2><a class="h_ident" id="h_ErccPg/l98" href="./05_higher_order.html#h_ErccPg/l98"></a>Резюме</h2>
<p><a class="p_ident" id="p_EmYdYeFPjo" href="./05_higher_order.html#p_EmYdYeFPjo"></a>Да си в състояние да прехвърляш стойности на функция към други функции, не е просто трик, това е дълбок полезен аспект на JavaScript. Това ни позволява да напишем изчисления с “пропуски” в тях, като функции и има код, който позволява тези функции да попълнят тези пропуски, чрез предоставяне на функционални стойности, които описват липсващите изчисления.</p>
<p><a class="p_ident" id="p_YfXho6cgu+" href="./05_higher_order.html#p_YfXho6cgu+"></a>Масивите предоставят редица полезни по-високо ниво методи: <code>forEach</code>, който да направи нещо с всеки елемент в масива, <code>filter</code>, който да изгради нов масив с филтрираните елементи, <code>map</code>, който да изгради нов масив, където всеки елемент е преминал през функция и <code>reduce</code> който да комбинира всички елементи на масива в една стойност.</p>
<p><a class="p_ident" id="p_3UBuCIfCEM" href="./05_higher_order.html#p_3UBuCIfCEM"></a>Функциите имат още <code>apply</code> метод, който може да се използва, за да го извикаме с масив, като посочва своите аргументи. Те имат също и <code>bind</code> метод, който се използва за създаване на частично прилагана версия на функция.</p>
<h2><a class="h_ident" id="h_TcUD2vzyMe" href="./05_higher_order.html#h_TcUD2vzyMe"></a>Упражнения</h2>
<h3><a class="h_ident" id="h_aIOczlLyX1" href="./05_higher_order.html#h_aIOczlLyX1"></a>Сплескване</h3>
<p><a class="p_ident" id="p_RqAkArolEa" href="./05_higher_order.html#p_RqAkArolEa"></a>Използвайте метода <code>reduce</code> в комбинация с метода <code>concat</code> за да “изгладите” масив от масиви в един масив, който има всички елементи на входящите масиви.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_HFu+EZSG8B" href="./05_higher_order.html#c_HFu+EZSG8B"></a><span class="cm-keyword">var</span> <span class="cm-variable">arrays</span> <span class="cm-operator">=</span> [[<span class="cm-number">1</span>, <span class="cm-number">2</span>, <span class="cm-number">3</span>], [<span class="cm-number">4</span>, <span class="cm-number">5</span>], [<span class="cm-number">6</span>]];
<span class="cm-comment">// Your code here.</span>
<span class="cm-comment">// → [1, 2, 3, 4, 5, 6]</span></pre>
<h3><a class="h_ident" id="h_I9XoVSLsTV" href="./05_higher_order.html#h_I9XoVSLsTV"></a>Възрастова разлика между майка и дете</h3>
<p><a class="p_ident" id="p_a44KIXR4aT" href="./05_higher_order.html#p_a44KIXR4aT"></a>Използвайте данните от настоящата глава, за да изчислите средно-възрастовата разликата между майки и деца (това е възрастта на майката, когато детето се ражда). Можете да използвате  функцията <code>average</code> дефинирана <a href="./05_higher_order.html#average_function">по-рано</a> в тази глава.</p>
<p><a class="p_ident" id="p_/E+zqsb0UA" href="./05_higher_order.html#p_/E+zqsb0UA"></a>Имайте в предвид, че не всички майки посочени в данните присъстват в масива. Обекта <code>byName</code> може да ви е полезен, понеже прави лесно намирането на обекта на едно лице, само по името му.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_+30TY+6MeW" href="./05_higher_order.html#c_+30TY+6MeW"></a><span class="cm-keyword">function</span> <span class="cm-variable">average</span>(<span class="cm-def">array</span>) {
  <span class="cm-keyword">function</span> <span class="cm-def">plus</span>(<span class="cm-def">a</span>, <span class="cm-def">b</span>) { <span class="cm-keyword">return</span> <span class="cm-variable-2">a</span> <span class="cm-operator">+</span> <span class="cm-variable-2">b</span>; }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">array</span>.<span class="cm-property">reduce</span>(<span class="cm-variable-2">plus</span>) <span class="cm-operator">/</span> <span class="cm-variable-2">array</span>.<span class="cm-property">length</span>;
}

<span class="cm-keyword">var</span> <span class="cm-variable">byName</span> <span class="cm-operator">=</span> {};
<span class="cm-variable">ancestry</span>.<span class="cm-property">forEach</span>(<span class="cm-keyword">function</span>(<span class="cm-def">person</span>) {
  <span class="cm-variable">byName</span>[<span class="cm-variable-2">person</span>.<span class="cm-property">name</span>] <span class="cm-operator">=</span> <span class="cm-variable-2">person</span>;
});

<span class="cm-comment">// Your code here.</span>

<span class="cm-comment">// → 31.2</span></pre>
<div class="solution"><div class="solution-text">
<p><a class="p_ident" id="p_UL/8si2OX7" href="./05_higher_order.html#p_UL/8si2OX7"></a>Тъй като, не всички елементи в <code>ancestry</code> масива произвеждат полезни данни (не можем да изчислим разликата във възрастта, освен ако не сме сигурни в датата на раждане на майката), ние трябва да приложим <code>filter</code> по някакъв начин преди да извикаме <code>average</code>. Можете да го направите, като първо го подадете, чрез дефиниране на <code>hasKnownMother</code> функция и филтрирате там първо. Алтернативно, можете да извикате <code>map</code> и във вашата mapping функция да върнете разликата във възрастта или <code>null</code>, ако майката не е известна. След това можете да извикате <code>filter</code> за премахване на <code>null</code> елементите преди да подадете масива към <code>average</code>.</p>
</div></div>
<h3><a class="h_ident" id="h_FkNn96IrQe" href="./05_higher_order.html#h_FkNn96IrQe"></a>Продължителноста на живота исторически</h3>
<p><a class="p_ident" id="p_ENbLeUYppS" href="./05_higher_order.html#p_ENbLeUYppS"></a>Когато прегледаме всички хора в нашия набор от данни, които са живели повече от 90г., излиза само последното поколение в данните. Нека разгледаме по-подробно това явление.</p>
<p><a class="p_ident" id="p_0JOS/ablSJ" href="./05_higher_order.html#p_0JOS/ablSJ"></a>Изчисляват се изходящите данни на средната възраст на хората в потеклото за един век. Лице се определя на един век, когато годината на смъртта се дели на 100 и се закръгля на горе, както в <code>Math.ceil(person.died / 100)</code>.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_Xi4vRpdLx1" href="./05_higher_order.html#c_Xi4vRpdLx1"></a><span class="cm-keyword">function</span> <span class="cm-variable">average</span>(<span class="cm-def">array</span>) {
  <span class="cm-keyword">function</span> <span class="cm-def">plus</span>(<span class="cm-def">a</span>, <span class="cm-def">b</span>) { <span class="cm-keyword">return</span> <span class="cm-variable-2">a</span> <span class="cm-operator">+</span> <span class="cm-variable-2">b</span>; }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">array</span>.<span class="cm-property">reduce</span>(<span class="cm-variable-2">plus</span>) <span class="cm-operator">/</span> <span class="cm-variable-2">array</span>.<span class="cm-property">length</span>;
}

<span class="cm-comment">// Your code here.</span>

<span class="cm-comment">// → 16: 43.5</span>
<span class="cm-comment">//   17: 51.2</span>
<span class="cm-comment">//   18: 52.8</span>
<span class="cm-comment">//   19: 54.8</span>
<span class="cm-comment">//   20: 84.7</span>
<span class="cm-comment">//   21: 94</span></pre>
<div class="solution"><div class="solution-text">
<p><a class="p_ident" id="p_fj5gLJr4+G" href="./05_higher_order.html#p_fj5gLJr4+G"></a>Същността на този пример се крие в групирането на елементите от колекцията с някои аспекти на тяхното разделяне в масива на предците, на по-малки масиви с предци за един век.</p>
<p><a class="p_ident" id="p_Jonw4Z0wbo" href="./05_higher_order.html#p_Jonw4Z0wbo"></a>По време на процеса на групиране, дръжте един обект, който свързва името на века (в цифри) с масива на един обект на човек или с възрастта. Тъй като не знаем предварително, какви категории ще открием, трябва да ги създадете в движение. За всеки човек, след изчисляване на неговия век, трябва да тестваме дали този век вече е бил известен. Ако не е, добавете масив за него. След това добавете лицето (или възрастта) в правилния масив за век.</p>
<p><a class="p_ident" id="p_YoO/BHbTiQ" href="./05_higher_order.html#p_YoO/BHbTiQ"></a>И на края може да използвате <code>for</code>/<code>in</code> цикъл за отпечатване на средната възраст за отделните векове.</p>
</div></div>
<p><a class="p_ident" id="p_yzI++go/yy" href="./05_higher_order.html#p_yzI++go/yy"></a>За бонус точки, напишете функция <code>groupBy</code>, която абстрактно групира операциите. Тя трябва да приема, като аргументи масив и функция, които изчисляват групата за даден елемент в масива и връща един обект, който съпоставя имена на групи към масиви от групи членове.</p>
<h3><a class="h_ident" id="h_jr7hZiuR7+" href="./05_higher_order.html#h_jr7hZiuR7+"></a>Всеки и след това някои</h3>
<p><a class="p_ident" id="p_BZKBxgsPML" href="./05_higher_order.html#p_BZKBxgsPML"></a>Масивите също идват със стандартните методи: <code>every</code> и <code>some</code>. И двете са <code>predicate</code> функции, които когато бъдат извикани с елемент от масив, като аргумент, връщат истина или лъжа. Точно, както <code>&amp;&amp;</code> връща истина, само когато всеки от изразите от двете му страни са верни, така и <code>every</code> връща истина, само когато <code>predicate</code> връща вярно за всички елементи в масива. По същия начин, <code>some</code> връща истина, веднага след като, <code>predicate</code> върне вярно за някой от елементите в масива. Те не обработват повече елементи отколкото е необходимо, например, ако <code>some</code> открие, че <code>predicate</code> взема първия елемент на масива за верен, той няма да разглежда стойности след това.</p>
<p><a class="p_ident" id="p_aMPYznovUm" href="./05_higher_order.html#p_aMPYznovUm"></a>Напишете две функции <code>every</code> и <code>some</code>, които се държат като тези методи с изключение на това, че те вземат масива, като първи аргумент, а не метод.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_EK+njyIMWq" href="./05_higher_order.html#c_EK+njyIMWq"></a><span class="cm-comment">// Your code here.</span>

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">every</span>([<span class="cm-atom">NaN</span>, <span class="cm-atom">NaN</span>, <span class="cm-atom">NaN</span>], <span class="cm-variable">isNaN</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">every</span>([<span class="cm-atom">NaN</span>, <span class="cm-atom">NaN</span>, <span class="cm-number">4</span>], <span class="cm-variable">isNaN</span>));
<span class="cm-comment">// → false</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">some</span>([<span class="cm-atom">NaN</span>, <span class="cm-number">3</span>, <span class="cm-number">4</span>], <span class="cm-variable">isNaN</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">some</span>([<span class="cm-number">2</span>, <span class="cm-number">3</span>, <span class="cm-number">4</span>], <span class="cm-variable">isNaN</span>));
<span class="cm-comment">// → false</span></pre>
<div class="solution"><div class="solution-text">
<p><a class="p_ident" id="p_43tyHVRbBq" href="./05_higher_order.html#p_43tyHVRbBq"></a>Функциите могат да следват подобен модел на поведение, като  <a href="./05_higher_order.html#forEach">дефиницията</a> на <code>forEach</code> в началото на тази глава, с изключение на това, че трябва да се върнат незабавно (с правилната стойност), когато <code>predicate</code> функцията връща <em>false</em> или <em>true</em>. Не забравяйте да поставите друго <code>return</code> изявление след цикъла, така че функцията също да връща правилната стойност, когато достигне края на масива.</p>
</div></div>
<nav>
  <a href="./04_data.html" title="previous chapter">◀</a>
  <a href="./index.html" title="cover">◆</a>
  <a href="./06_object.html" title="next chapter">▶</a>
</nav>
</article>
</body></html>
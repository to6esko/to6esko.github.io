<!DOCTYPE html>
<!-- saved from url=(0042)./15_game.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <title>Project: A Platform Game :: Eloquent JavaScript</title>
  <link rel="stylesheet" href="./media/codemirror.css">
  <script src="./media/acorn_codemirror.js"></script>
  <link rel="stylesheet" href="./media/ejs.css">
  <script src="./media/sandbox.js"></script>
  <script src="./media/ejs.js"></script>
  <script>var chapNum = 15;var sandboxLoadFiles = ["code/chapter/15_game.js", "code/game_levels.js"];</script>
</head>

<body><article>
<nav>
  <a href="./14_event.html" title="previous chapter">◀</a>
  <a href="./index.html" title="cover">◆</a>
  <a href="./16_canvas.html" title="next chapter">▶</a>
</nav>

<h1><div class="chap_num">Chapter 15</div>Проект: Платформа игра</h1>
<blockquote>
<p><a class="p_ident" id="p_kUA7+lr6ay" href="./15_game.html#p_kUA7+lr6ay"></a>Цялата реалност е една игра.”</p>
 <footer>Iain Banks, <cite>The Player of Games</cite></footer>
</blockquote>
<p><a class="p_ident" id="p_LHKzmIPa3c" href="./15_game.html#p_LHKzmIPa3c"></a>Моят първи интерес към компютрите, както и на много деца, възникна с компютърните игри. Бях очарован от мъничките компютърно симулирани светове, които мога да манипулирам и  чиито истории се развиваха, предполагам повече поради начина , по който въображението ми можеше да проектира, отколкото заради възможностите, които те действително предлагаха.</p>
<p><a class="p_ident" id="p_oGz9+U3nKJ" href="./15_game.html#p_oGz9+U3nKJ"></a>Не бих препоръчал кариера в програмиране на игри на никого. Много прилича на музикалната индустрия, несъответствието между нетърпеливи млади хора, които искат да работят в нея и реалното търсене на такива хора създава доста нездравословна среда. Но написването на игри за забавление е забавно.</p>
<p><a class="p_ident" id="p_j3t+HvGbaT" href="./15_game.html#p_j3t+HvGbaT"></a>В тази глава ще направим една проста игра платформа. Платформа игрите (или “jump and run” игри) са, както очаква играча, движение на една фигура през свят, който често е двуизмерен и се гледа от страни, и прави скокове върху или над неща.</p>
<h2><a class="h_ident" id="h_lMtTRzata0" href="./15_game.html#h_lMtTRzata0"></a>Играта</h2>
<p><a class="p_ident" id="p_C38xTPlNF8" href="./15_game.html#p_C38xTPlNF8"></a>Нашата игра ще бъде приблизително базирана на <a href="http://www.lessmilk.com/games/10">Dark Blue</a> от  Thomas Palef. Аз избрах тази игра, защото тя е едновременно забавна и малка, и може да бъде построена без прекалено много код. Тя изглежда така:</p>
<div class="image">
  <img src="./media/darkblue.png" alt="The game Dark Blue">
</div>
<p><a class="p_ident" id="p_mIXBfsCnQQ" href="./15_game.html#p_mIXBfsCnQQ"></a>Тъмната кутия представлява играчът, чиято задача е да събира жълти кутии (монети), като избягва червените неща (лава). Нивото е минато, когато всички монети са събрани.</p>
<p><a class="p_ident" id="p_g71I1Gdo7w" href="./15_game.html#p_g71I1Gdo7w"></a>Играчът може да се разхожда с левия и десния клавиш със стрелки и скача със стрелката на горе. Скока е специалитет на тази игра. Той може да достигне няколко пъти собствената си височина и е в състояние да промени посоката си във въздуха. Това може да не е напълно реалистично, но помага на играча за усещането, че е в пряк контрол с аватара на екрана.</p>
<p><a class="p_ident" id="p_or+OtPnSO1" href="./15_game.html#p_or+OtPnSO1"></a>Играта се състои от фиксиран фон, изложен под формата на решетка, с движещи се елементи върху него. Всяко поле на решетка е празно, твърдо или лава. За разлика от симулацията на изкуствения живот в <a href="./07_elife.html#elife">Глава 7</a>, позициите на тези елементи на са ограничени на мрежата, координатите им могат да бъдат дробни числа позволявайки плавно движение.</p>
<h2><a class="h_ident" id="h_hLFu/U4fE5" href="./15_game.html#h_hLFu/U4fE5"></a>Технология</h2>
<p><a class="p_ident" id="p_w6B1L26QOc" href="./15_game.html#p_w6B1L26QOc"></a>Ние ще използваме DOM на браузъра за да изведем играта на екрана и ще отчетем приноса на потребителите чрез манипулиране на клавишни събития.</p>
<p><a class="p_ident" id="p_wha4Kv9EnE" href="./15_game.html#p_wha4Kv9EnE"></a>Екран и клавиатура свързани с кода е само една малка част от работата, която трябва да направим за изграждането на играта. Тъй като всичко изглежда, като цветни кутии рисунката не е сложна: ще създадем DOM елементи и използвайки стилизация ще им дадем фонов цвят, размер и позиция.</p>
<p><a class="p_ident" id="p_5a/S/bF/ru" href="./15_game.html#p_5a/S/bF/ru"></a>Можем да представим фона във вид на таблица, тъй като е неизменна мрежа от квадрати. Свободно движещите се елементи могат да бъдат наслагвани върху нея, използвайки абсолютно позиционирани елементи.</p>
<p><a class="p_ident" id="p_kmznnwbiqx" href="./15_game.html#p_kmznnwbiqx"></a>В игри и други програми, които имат анимиране на графики и взаимодействие с потребители без да се забелязва забавяне, ефективността е много важна. Въпреки, че DOM не бил първоначално проектиран за графики с висока производителност, той всъщност е по-добър в това, отколкото очакваме. Ние видяхме няколко анимации в <a href="./13_dom.html#animation">Глава 13</a>. На една модерна машина, проста игра, като тази се представя добре дори и ако не се задълбочим в оптимизирането много.</p>
<p><a class="p_ident" id="p_wN87+E1mRv" href="./15_game.html#p_wN87+E1mRv"></a>В <a href="./16_canvas.html#canvas">следващата глава </a> ще разгледаме друга браузър технология - <code>&lt;canvas&gt;</code> таг, който осигурява по-традиционен начин за чертане на графики, които работят по отношение на форми и пиксели, а не с DOM елементи.</p>
<h2><a class="h_ident" id="h_7UfwmBGLOk" href="./15_game.html#h_7UfwmBGLOk"></a>Нива</h2>
<p><a class="p_ident" id="p_qtbcbQFDkK" href="./15_game.html#p_qtbcbQFDkK"></a>В <a href="./07_elife.html#plan">Глава 7</a> използвахме масиви от <em>strings</em>, за да опишем двуизмерна решетка. Ние можем да направим същото тук. Това ще ни позволи да проектираме нива без да изграждаме редактор за ниво.</p>
<p><a class="p_ident" id="p_Y3dxlqZNOr" href="./15_game.html#p_Y3dxlqZNOr"></a>Едно просто ниво ще изглежда така:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_ydbtOFWK2H" href="./15_game.html#c_ydbtOFWK2H"></a><span class="cm-keyword">var</span> <span class="cm-variable">simpleLevelPlan</span> <span class="cm-operator">=</span> [
  <span class="cm-string">"                      "</span>,
  <span class="cm-string">"                      "</span>,
  <span class="cm-string">"  x              = x  "</span>,
  <span class="cm-string">"  x         o o    x  "</span>,
  <span class="cm-string">"  x @      xxxxx   x  "</span>,
  <span class="cm-string">"  xxxxx            x  "</span>,
  <span class="cm-string">"      x!!!!!!!!!!!!x  "</span>,
  <span class="cm-string">"      xxxxxxxxxxxxxx  "</span>,
  <span class="cm-string">"                      "</span>
];</pre>
<p><a class="p_ident" id="p_/+8Bj7dHhI" href="./15_game.html#p_/+8Bj7dHhI"></a>И двете: фиксираната мрежа и движещите се елементи ще бъдат включени в плана. Характера <code>x</code> е за стени, характера <em>space</em> е за празно пространство, удивителните знаци ! (<em>nonmoving</em>) представляват лава.</p>
<p><a class="p_ident" id="p_lnXaKIc8yw" href="./15_game.html#p_lnXaKIc8yw"></a>Знакът <code>@</code> определя мястото, където играчът започва. Всяко <code>o</code> е монета, а знака за равенство (<code>=</code>) означава блок от лава, която се движи напред-назад хризонтално. Имайте в предвид, че мрежата за тези позиции ще бъде настроена да съдържа празно пространство, а друга структура от данни ще се използва за проследяване на положението на движещите се елементи.</p>
<p><a class="p_ident" id="p_3Abhc0fnza" href="./15_game.html#p_3Abhc0fnza"></a>Ще поддържаме още два вида движение на лава: характера (<code>|</code>), който ще представлява тръба за вертикално изригване на лава и <code>v</code> също за вертикално капене на лава, която не се мести напред-назад, а се движи само на долу и удряйки пода скача обратно в стартовата си позиция.</p>
<p><a class="p_ident" id="p_JSlRu3lL/0" href="./15_game.html#p_JSlRu3lL/0"></a>Цялата игра се състои от няколко нива, които играчът трябва да мине. Нивото е минато, когато всички монети са събрани. Ако играчът докосне лавата той умира и сегашното ниво се възстановява до началното си положение, където играчът може да опита отново.</p>
<h2 id="level"><a class="h_ident" id="h_DeVC1tufta" href="./15_game.html#h_DeVC1tufta"></a>Четене на ниво</h2>
<p><a class="p_ident" id="p_+Eovnn74MN" href="./15_game.html#p_+Eovnn74MN"></a>Следната конструкция изражда обекта на нивото. Нейният аргумент трябва да бъде масив от <em>strings</em>, който определя нивото.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_PTlscRwogG" href="./15_game.html#c_PTlscRwogG"></a><span class="cm-keyword">function</span> <span class="cm-variable">Level</span>(<span class="cm-def">plan</span>) {
  <span class="cm-keyword">this</span>.<span class="cm-property">width</span> <span class="cm-operator">=</span> <span class="cm-variable-2">plan</span>[<span class="cm-number">0</span>].<span class="cm-property">length</span>;
  <span class="cm-keyword">this</span>.<span class="cm-property">height</span> <span class="cm-operator">=</span> <span class="cm-variable-2">plan</span>.<span class="cm-property">length</span>;
  <span class="cm-keyword">this</span>.<span class="cm-property">grid</span> <span class="cm-operator">=</span> [];
  <span class="cm-keyword">this</span>.<span class="cm-property">actors</span> <span class="cm-operator">=</span> [];

  <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">y</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">y</span> <span class="cm-operator">&lt;</span> <span class="cm-keyword">this</span>.<span class="cm-property">height</span>; <span class="cm-variable-2">y</span><span class="cm-operator">++</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">line</span> <span class="cm-operator">=</span> <span class="cm-variable-2">plan</span>[<span class="cm-variable-2">y</span>], <span class="cm-def">gridLine</span> <span class="cm-operator">=</span> [];
    <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">x</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">x</span> <span class="cm-operator">&lt;</span> <span class="cm-keyword">this</span>.<span class="cm-property">width</span>; <span class="cm-variable-2">x</span><span class="cm-operator">++</span>) {
      <span class="cm-keyword">var</span> <span class="cm-def">ch</span> <span class="cm-operator">=</span> <span class="cm-variable-2">line</span>[<span class="cm-variable-2">x</span>], <span class="cm-def">fieldType</span> <span class="cm-operator">=</span> <span class="cm-atom">null</span>;
      <span class="cm-keyword">var</span> <span class="cm-def">Actor</span> <span class="cm-operator">=</span> <span class="cm-variable">actorChars</span>[<span class="cm-variable-2">ch</span>];
      <span class="cm-keyword">if</span> (<span class="cm-variable-2">Actor</span>)
        <span class="cm-keyword">this</span>.<span class="cm-property">actors</span>.<span class="cm-property">push</span>(<span class="cm-keyword">new</span> <span class="cm-variable-2">Actor</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Vector</span>(<span class="cm-variable-2">x</span>, <span class="cm-variable-2">y</span>), <span class="cm-variable-2">ch</span>));
      <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">ch</span> <span class="cm-operator">==</span> <span class="cm-string">"x"</span>)
        <span class="cm-variable-2">fieldType</span> <span class="cm-operator">=</span> <span class="cm-string">"wall"</span>;
      <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">ch</span> <span class="cm-operator">==</span> <span class="cm-string">"!"</span>)
        <span class="cm-variable-2">fieldType</span> <span class="cm-operator">=</span> <span class="cm-string">"lava"</span>;
      <span class="cm-variable-2">gridLine</span>.<span class="cm-property">push</span>(<span class="cm-variable-2">fieldType</span>);
    }
    <span class="cm-keyword">this</span>.<span class="cm-property">grid</span>.<span class="cm-property">push</span>(<span class="cm-variable-2">gridLine</span>);
  }

  <span class="cm-keyword">this</span>.<span class="cm-property">player</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">actors</span>.<span class="cm-property">filter</span>(<span class="cm-keyword">function</span>(<span class="cm-def">actor</span>) {
    <span class="cm-keyword">return</span> <span class="cm-variable-2">actor</span>.<span class="cm-property">type</span> <span class="cm-operator">==</span> <span class="cm-string">"player"</span>;
  })[<span class="cm-number">0</span>];
  <span class="cm-keyword">this</span>.<span class="cm-property">status</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">finishDelay</span> <span class="cm-operator">=</span> <span class="cm-atom">null</span>;
}</pre>
<p><a class="p_ident" id="p_ZIIJavICol" href="./15_game.html#p_ZIIJavICol"></a>За краткост, кода не се проверява за неправилен вход. Това предполага, че сме му дали завършен подходящ план за ниво със стартова позиция на играча и други важни неща.</p>
<p><a class="p_ident" id="p_x/twI7oWfP" href="./15_game.html#p_x/twI7oWfP"></a>Нивото съхранява своята ширина и висичина, както и два масива - един за мрежата и един за актьорите, които са динамични елементи. Решетката е представена, като масив от масиви, където всеки от вътрешните масиви представлява хоризонтална линия и всеки квадрат съдържа или нула за празен квадрат или string за вида на пълния квадрат <code>"wall"</code> или <code>"lava"</code>.</p>
<p><a class="p_ident" id="p_lk9TyBu+V9" href="./15_game.html#p_lk9TyBu+V9"></a>Масивът за актьорите съдържа обекти, които следят текущата позиция и състояние на динамичните елементи в нивото. Всеки от тях очаква да има: <code>pos</code> свойство, което дава позиция (координатите на неговата позиция спрямо горния ляв ъгъл), <code>size</code> свойството, което дава неговия размер и <code>type</code> свойство, което притежава <em>string</em> идентифициращ елементите  (<code>"lava"</code>, <code>"coin"</code> и <code>"player"</code>).</p>
<p><a class="p_ident" id="p_CHBpIMO/+A" href="./15_game.html#p_CHBpIMO/+A"></a>След изграждането на мрежата, ние използваме <code>filter</code> метод за намиране на обекта на играча, който съхраняваме в свойството на нивото. А <code>status</code> свойството следи дали играчът е спечелил или загубил. Когато това се случи, <code>finishDelay</code> се използва да подържа нивото активно за кратък период от време, така да може да се покаже една проста анимация. (Незабавно възстановяване или излизане от нивото ще изглежда евтино.) Този метод може да се използва за да се разбере дали нивото е минато.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_5Zb+6efnJo" href="./15_game.html#c_5Zb+6efnJo"></a><span class="cm-variable">Level</span>.<span class="cm-property">prototype</span>.<span class="cm-property">isFinished</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>() {
  <span class="cm-keyword">return</span> <span class="cm-keyword">this</span>.<span class="cm-property">status</span> <span class="cm-operator">!=</span> <span class="cm-atom">null</span> <span class="cm-operator">&amp;&amp;</span> <span class="cm-keyword">this</span>.<span class="cm-property">finishDelay</span> <span class="cm-operator">&lt;</span> <span class="cm-number">0</span>;
};</pre>
<h2><a class="h_ident" id="h_pw0251T7gn" href="./15_game.html#h_pw0251T7gn"></a>Актьори</h2>
<p><a class="p_ident" id="p_E0kVEhfjBl" href="./15_game.html#p_E0kVEhfjBl"></a><a id="vector"></a> За съхраняване на положението и размерите на един актьор, ние ще се върнем към нашия надежден <code>Vector</code> тип, с неговите групи от х и у координати в обекта.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_/G1xAMXuR9" href="./15_game.html#c_/G1xAMXuR9"></a><span class="cm-keyword">function</span> <span class="cm-variable">Vector</span>(<span class="cm-def">x</span>, <span class="cm-def">y</span>) {
  <span class="cm-keyword">this</span>.<span class="cm-property">x</span> <span class="cm-operator">=</span> <span class="cm-variable-2">x</span>; <span class="cm-keyword">this</span>.<span class="cm-property">y</span> <span class="cm-operator">=</span> <span class="cm-variable-2">y</span>;
}
<span class="cm-variable">Vector</span>.<span class="cm-property">prototype</span>.<span class="cm-property">plus</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">other</span>) {
  <span class="cm-keyword">return</span> <span class="cm-keyword">new</span> <span class="cm-variable">Vector</span>(<span class="cm-keyword">this</span>.<span class="cm-property">x</span> <span class="cm-operator">+</span> <span class="cm-variable-2">other</span>.<span class="cm-property">x</span>, <span class="cm-keyword">this</span>.<span class="cm-property">y</span> <span class="cm-operator">+</span> <span class="cm-variable-2">other</span>.<span class="cm-property">y</span>);
};
<span class="cm-variable">Vector</span>.<span class="cm-property">prototype</span>.<span class="cm-property">times</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">factor</span>) {
  <span class="cm-keyword">return</span> <span class="cm-keyword">new</span> <span class="cm-variable">Vector</span>(<span class="cm-keyword">this</span>.<span class="cm-property">x</span> <span class="cm-operator">*</span> <span class="cm-variable-2">factor</span>, <span class="cm-keyword">this</span>.<span class="cm-property">y</span> <span class="cm-operator">*</span> <span class="cm-variable-2">factor</span>);
};</pre>
<p><a class="p_ident" id="p_YBJ9X5jC/P" href="./15_game.html#p_YBJ9X5jC/P"></a>Метода <code>times</code> скалира вектора по дадената сума. Това ще бъде полезно, когато трябва да се умножи скоростта на вектора по интервала от време, за да получим изминатото разстояние през това време</p>
<p><a class="p_ident" id="p_ZUYAD4nQKB" href="./15_game.html#p_ZUYAD4nQKB"></a>В предишния раздел, обекта <code>actorChars</code> се използва от <code>Level</code> конструктора да асоциира характери с конструктор функции. Обекта изглежда по следния начин:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_yAQDMv58Ql" href="./15_game.html#c_yAQDMv58Ql"></a><span class="cm-keyword">var</span> <span class="cm-variable">actorChars</span> <span class="cm-operator">=</span> {
  <span class="cm-string cm-property">"@"</span>: <span class="cm-variable">Player</span>,
  <span class="cm-string cm-property">"o"</span>: <span class="cm-variable">Coin</span>,
  <span class="cm-string cm-property">"="</span>: <span class="cm-variable">Lava</span>, <span class="cm-string cm-property">"|"</span>: <span class="cm-variable">Lava</span>, <span class="cm-string cm-property">"v"</span>: <span class="cm-variable">Lava</span>
};</pre>
<p><a class="p_ident" id="p_Ezz8Z00Wak" href="./15_game.html#p_Ezz8Z00Wak"></a>Последните три характера са карта на лавата. The <code>Level</code> конструктора подава характера на актьора, като втори аргумент към конструктора и <code>Lava</code> конструктора използва това, за да коригира своето поведение (вертикално или хоризонтално подскачане или капене).</p>
<p><a class="p_ident" id="p_9z5NweLFob" href="./15_game.html#p_9z5NweLFob"></a>Типът на играча е изграден със следната конструкция. Той разполага със свойството <code>speed</code>, където съхранява сегашната скорост, която ще ни помогне да симулираме инерция и гравитация.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_GHc17EeS05" href="./15_game.html#c_GHc17EeS05"></a><span class="cm-keyword">function</span> <span class="cm-variable">Player</span>(<span class="cm-def">pos</span>) {
  <span class="cm-keyword">this</span>.<span class="cm-property">pos</span> <span class="cm-operator">=</span> <span class="cm-variable-2">pos</span>.<span class="cm-property">plus</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Vector</span>(<span class="cm-number">0</span>, <span class="cm-operator">-</span><span class="cm-number">0.5</span>));
  <span class="cm-keyword">this</span>.<span class="cm-property">size</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Vector</span>(<span class="cm-number">0.8</span>, <span class="cm-number">1.5</span>);
  <span class="cm-keyword">this</span>.<span class="cm-property">speed</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Vector</span>(<span class="cm-number">0</span>, <span class="cm-number">0</span>);
}
<span class="cm-variable">Player</span>.<span class="cm-property">prototype</span>.<span class="cm-property">type</span> <span class="cm-operator">=</span> <span class="cm-string">"player"</span>;</pre>
<p><a class="p_ident" id="p_KwI14wjzqB" href="./15_game.html#p_KwI14wjzqB"></a>Играча е висок един и половина квадрата и първоначалната му позиция е половин квадрат над позицията, където се появява характера <code>@</code>. По този начин, долната му част се подравнява с дъното на квадрата, в който се появява.</p>
<p><a class="p_ident" id="p_tERSi4X6Me" href="./15_game.html#p_tERSi4X6Me"></a>При изграждането на динамичен <code>Lava</code> обект, ние трябва да инициализираме обекта по различен начин в зависимост от характера, на който се основава. Динамичната лава се движи сама в зависимост от дадената и скорост, докато не срещне препятствие. В този момент, ако има <code>repeatPos</code> свойство, тя ще скочи обратно към своята начална позиция (при капене). Ако това не стане, тя ще обърне скоростта и ще продължи в друга посока (изригване). Конструктора само определя необходимите свойства. Методът, който прави действителното преместване ще бъде написан <a href="./15_game.html#actors">по-късно</a>.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_PTqOmT7FMn" href="./15_game.html#c_PTqOmT7FMn"></a><span class="cm-keyword">function</span> <span class="cm-variable">Lava</span>(<span class="cm-def">pos</span>, <span class="cm-def">ch</span>) {
  <span class="cm-keyword">this</span>.<span class="cm-property">pos</span> <span class="cm-operator">=</span> <span class="cm-variable-2">pos</span>;
  <span class="cm-keyword">this</span>.<span class="cm-property">size</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Vector</span>(<span class="cm-number">1</span>, <span class="cm-number">1</span>);
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">ch</span> <span class="cm-operator">==</span> <span class="cm-string">"="</span>) {
    <span class="cm-keyword">this</span>.<span class="cm-property">speed</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Vector</span>(<span class="cm-number">2</span>, <span class="cm-number">0</span>);
  } <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">ch</span> <span class="cm-operator">==</span> <span class="cm-string">"|"</span>) {
    <span class="cm-keyword">this</span>.<span class="cm-property">speed</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Vector</span>(<span class="cm-number">0</span>, <span class="cm-number">2</span>);
  } <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">ch</span> <span class="cm-operator">==</span> <span class="cm-string">"v"</span>) {
    <span class="cm-keyword">this</span>.<span class="cm-property">speed</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Vector</span>(<span class="cm-number">0</span>, <span class="cm-number">3</span>);
    <span class="cm-keyword">this</span>.<span class="cm-property">repeatPos</span> <span class="cm-operator">=</span> <span class="cm-variable-2">pos</span>;
  }
}
<span class="cm-variable">Lava</span>.<span class="cm-property">prototype</span>.<span class="cm-property">type</span> <span class="cm-operator">=</span> <span class="cm-string">"lava"</span>;</pre>
<p><a class="p_ident" id="p_h6fsluS1sx" href="./15_game.html#p_h6fsluS1sx"></a><code>Coin</code> актьорите са прости. Те просто стоят на мястото си. Но за да оживим малко играта ще им е дадем леко потрепване, леко движение напред и назад. За да проследим това, обекта на монетата съхранява базова позиция, както и <code>wobble</code> свойство, което следи фазата на трептящото движение. Заедно те определят действителното положение на монетата (съхранено в <code>pos</code> свойството).</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_SwVUgnkT5j" href="./15_game.html#c_SwVUgnkT5j"></a><span class="cm-keyword">function</span> <span class="cm-variable">Coin</span>(<span class="cm-def">pos</span>) {
  <span class="cm-keyword">this</span>.<span class="cm-property">basePos</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">pos</span> <span class="cm-operator">=</span> <span class="cm-variable-2">pos</span>.<span class="cm-property">plus</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Vector</span>(<span class="cm-number">0.2</span>, <span class="cm-number">0.1</span>));
  <span class="cm-keyword">this</span>.<span class="cm-property">size</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Vector</span>(<span class="cm-number">0.6</span>, <span class="cm-number">0.6</span>);
  <span class="cm-keyword">this</span>.<span class="cm-property">wobble</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">random</span>() <span class="cm-operator">*</span> <span class="cm-variable">Math</span>.<span class="cm-property">PI</span> <span class="cm-operator">*</span> <span class="cm-number">2</span>;
}
<span class="cm-variable">Coin</span>.<span class="cm-property">prototype</span>.<span class="cm-property">type</span> <span class="cm-operator">=</span> <span class="cm-string">"coin"</span>;</pre>
<p><a class="p_ident" id="p_sinZPrR05b" href="./15_game.html#p_sinZPrR05b"></a>В <a href="./13_dom.html#sin_cos">Глава 13</a> видяхме, че <code>Math.sin</code> ни два  у-координата на точка от окръжност. С нея можем да координираме местенето назад и на пред в плавната форма на вълна и тъй като ще се движи в кръг, прави задължително функцията да моделира вълнообразно движение.</p>
<p><a class="p_ident" id="p_gQCua74XOk" href="./15_game.html#p_gQCua74XOk"></a>За да се избегне ситуация, в която всички монети се движат нагоре и надолу синхронизирано, началният етап за всяка монета ще бъде рандомизиран. Фазата на <code>Math.sin</code> вълната (ширината на една вълна) е 2π. Ние умножаваме стойността върната от <code>Math.random</code> по това число, за да даде на монетата случайна стартова позиция на вълната.</p>
<p><a class="p_ident" id="p_q4rwQ9GT76" href="./15_game.html#p_q4rwQ9GT76"></a>Сега сме написали всички необходими части за да представим размерите на нивото.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_+UfzWNonW2" href="./15_game.html#c_+UfzWNonW2"></a><span class="cm-keyword">var</span> <span class="cm-variable">simpleLevel</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Level</span>(<span class="cm-variable">simpleLevelPlan</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">simpleLevel</span>.<span class="cm-property">width</span>, <span class="cm-string">"by"</span>, <span class="cm-variable">simpleLevel</span>.<span class="cm-property">height</span>);
<span class="cm-comment">// → 22 by 9</span></pre>
<p><a class="p_ident" id="p_lCdOTin0mI" href="./15_game.html#p_lCdOTin0mI"></a>Задачата напред е да покажем тези нива на екрана и да моделираме движението и времето вътре в тях.</p>
<h2><a class="h_ident" id="h_uCRd57RG2L" href="./15_game.html#h_uCRd57RG2L"></a>Капслулирането  като  бреме</h2>
<p><a class="p_ident" id="p_M65QHGE4qM" href="./15_game.html#p_M65QHGE4qM"></a>Повечето от кода в тази глава не се тревожи за капсулирането по две причини. Първо, капсулирането изисква допълнително усилие. Това прави програмите по-големи и изисква допълнителни концепции и интерфейси, които трябва да бъдат въведени. Понеже може да се създаде толкова много код, който един читател трябва да прочете, докато му се изцъклят очите, съм направил опит да запазя програмата малка.</p>
<p><a class="p_ident" id="p_xjLloHI+Wv" href="./15_game.html#p_xjLloHI+Wv"></a>Второ различните елементи в тази игра са толкова тясно свързани заедно, че ако поведението на един от тях се промени, това е малко вероятно, то другите едва ли ще останат същите. Интерфейсите между елементите ще се окажат пред кодиране на много предположения за начина, по който играта работи. Това ги прави много по-малко ефективни, когато се промени една част от системата и все още трябва да се притесняваме за начина, по който тя влияе на другите части, защото техните интерфейси не биха обхванали новата ситуация.</p>
<p><a class="p_ident" id="p_JXDPJBULIv" href="./15_game.html#p_JXDPJBULIv"></a>Някои отрязани точки в една система се поддават добре на разделяне чрез строги интерфейси, но други не. Опитвайки се да капсулирате нещо, което не е с подходяща граница е сигурен начин да изгубите много енергия. Когато направите тази грешка, обикновено ще забележите, че вашите интерфейси стават опасно големи и подробни и че те трябва да бъдат променяни често, тъй като програмата се развива.</p>
<p><a class="p_ident" id="p_Eajw41C5DX" href="./15_game.html#p_Eajw41C5DX"></a>Има едно нещо, което ние ще капсулираме в тази глава и това е подсистемата за рисуване. Причината за това е, че ще покаже същата игра по различен начин в <a href="./16_canvas.html#canvasdisplay">следващата глава</a>. С пускането на рисунката зад интерфейса, ние просто ще заредим една и съща програма игра, включена в нов дисплей модул.</p>
<h2 id="domdisplay"><a class="h_ident" id="h_neNgUMdlHQ" href="./15_game.html#h_neNgUMdlHQ"></a>Чертеж</h2>
<p><a class="p_ident" id="p_bjlUPfTgQP" href="./15_game.html#p_bjlUPfTgQP"></a>Капсулирането на кода за рисуване се извършва чрез определяне на обекта на дисплея, в който се показва дадено ниво. Типа на дисплея, който определяме в тази глава ще се казва <code>DOMDisplay</code>, защото използва DOM елементи за да покаже нивото.</p>
<p><a class="p_ident" id="p_iqZAywSomZ" href="./15_game.html#p_iqZAywSomZ"></a>Ние ще използваме <code>style</code> за да определим действителните цветове и други фиксирани свойства на елементите, които съставят играта. Също така, би било възможно директно да задаваме на елементите <code>style</code> свойства, когато ги създаваме, но това ще произведе повече многословни програми.</p>
<p><a class="p_ident" id="p_cp0ecVNl6a" href="./15_game.html#p_cp0ecVNl6a"></a>Следната помощна функция осигурява кратък начин за създаване на един елемент и даването му на клас.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_qgpBj12JLo" href="./15_game.html#c_qgpBj12JLo"></a><span class="cm-keyword">function</span> <span class="cm-variable">elt</span>(<span class="cm-def">name</span>, <span class="cm-def">className</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">elt</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">createElement</span>(<span class="cm-variable-2">name</span>);
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">className</span>) <span class="cm-variable-2">elt</span>.<span class="cm-property">className</span> <span class="cm-operator">=</span> <span class="cm-variable-2">className</span>;
  <span class="cm-keyword">return</span> <span class="cm-variable-2">elt</span>;
}</pre>
<p><a class="p_ident" id="p_Xjpq/reXQf" href="./15_game.html#p_Xjpq/reXQf"></a>Дисплея е създаден, като родителски елемент, към който трябва да добави себе си и обект за ниво.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_NXRRW4iUHo" href="./15_game.html#c_NXRRW4iUHo"></a><span class="cm-keyword">function</span> <span class="cm-variable">DOMDisplay</span>(<span class="cm-def">parent</span>, <span class="cm-def">level</span>) {
  <span class="cm-keyword">this</span>.<span class="cm-property">wrap</span> <span class="cm-operator">=</span> <span class="cm-variable-2">parent</span>.<span class="cm-property">appendChild</span>(<span class="cm-variable">elt</span>(<span class="cm-string">"div"</span>, <span class="cm-string">"game"</span>));
  <span class="cm-keyword">this</span>.<span class="cm-property">level</span> <span class="cm-operator">=</span> <span class="cm-variable-2">level</span>;

  <span class="cm-keyword">this</span>.<span class="cm-property">wrap</span>.<span class="cm-property">appendChild</span>(<span class="cm-keyword">this</span>.<span class="cm-property">drawBackground</span>());
  <span class="cm-keyword">this</span>.<span class="cm-property">actorLayer</span> <span class="cm-operator">=</span> <span class="cm-atom">null</span>;
  <span class="cm-keyword">this</span>.<span class="cm-property">drawFrame</span>();
}</pre>
<p><a class="p_ident" id="p_ma7b253RBp" href="./15_game.html#p_ma7b253RBp"></a>Ние използваме факта, че <code>appendChild</code> връща приложения елемент за да създаде обвивка на елемент и го съхранява във <code>wrap</code> свойството в едно изявление.</p>
<p><a class="p_ident" id="p_IMKo7SUQR3" href="./15_game.html#p_IMKo7SUQR3"></a>Фона на нивото никога не се променя и се изготвя веднъж. Актьорите се преначертават всеки път, когато дисплея се актуализира. Свойството <code>actorLayer</code> ще бъде използвано от <code>drawFrame</code> за проследяване на елемента, който държи актьорите, така че те лесно да бъдат премахнати или заменени.</p>
<p><a class="p_ident" id="p_si3+n3Lijy" href="./15_game.html#p_si3+n3Lijy"></a>Нашите координати и размери се проследяват в единици по отношение на размера на мрежата, където размер или разстояние от 1 означава една решетка-единица. При определяне на размера на пикселите, ние ще трябва да мащабираме тези координати нагоре- иначе всичко в играта ще бъде абсурдно малко от едни пиксел на квадрат. Променливата <code>scale</code> дава броят на пикселите, който един единствен елемент заема на екрана.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_3gR9dTLD4N" href="./15_game.html#c_3gR9dTLD4N"></a><span class="cm-keyword">var</span> <span class="cm-variable">scale</span> <span class="cm-operator">=</span> <span class="cm-number">20</span>;

<span class="cm-variable">DOMDisplay</span>.<span class="cm-property">prototype</span>.<span class="cm-property">drawBackground</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>() {
  <span class="cm-keyword">var</span> <span class="cm-def">table</span> <span class="cm-operator">=</span> <span class="cm-variable">elt</span>(<span class="cm-string">"table"</span>, <span class="cm-string">"background"</span>);
  <span class="cm-variable-2">table</span>.<span class="cm-property">style</span>.<span class="cm-property">width</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">level</span>.<span class="cm-property">width</span> <span class="cm-operator">*</span> <span class="cm-variable">scale</span> <span class="cm-operator">+</span> <span class="cm-string">"px"</span>;
  <span class="cm-keyword">this</span>.<span class="cm-property">level</span>.<span class="cm-property">grid</span>.<span class="cm-property">forEach</span>(<span class="cm-keyword">function</span>(<span class="cm-def">row</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">rowElt</span> <span class="cm-operator">=</span> <span class="cm-variable-2">table</span>.<span class="cm-property">appendChild</span>(<span class="cm-variable">elt</span>(<span class="cm-string">"tr"</span>));
    <span class="cm-variable-2">rowElt</span>.<span class="cm-property">style</span>.<span class="cm-property">height</span> <span class="cm-operator">=</span> <span class="cm-variable">scale</span> <span class="cm-operator">+</span> <span class="cm-string">"px"</span>;
    <span class="cm-variable-2">row</span>.<span class="cm-property">forEach</span>(<span class="cm-keyword">function</span>(<span class="cm-def">type</span>) {
      <span class="cm-variable-2">rowElt</span>.<span class="cm-property">appendChild</span>(<span class="cm-variable">elt</span>(<span class="cm-string">"td"</span>, <span class="cm-variable-2">type</span>));
    });
  });
  <span class="cm-keyword">return</span> <span class="cm-variable-2">table</span>;
};</pre>
<p id="game_css"><a class="p_ident" id="p_d+zoai4uXa" href="./15_game.html#p_d+zoai4uXa"></a>Както бе споменато по-рано задният план се съставя, като <code>&lt;table&gt;</code> елемент. Това добре съответства на структурата на <code>grid</code> свойството в нивото - всеки ред на решетката се превръща в табличен ред (<code>&lt;tr&gt;</code> елемент). <em>Strings</em> в мрежата се използват, като имена на класове за клетките от таблицата (<code>&lt;td&gt;</code> елементи). Следния CSS помага получената таблица да изглежда, като желания заден план:</p>
<pre data-language="text/css" class="snippet cm-s-default"><a class="c_ident" id="c_j52CagBKSp" href="./15_game.html#c_j52CagBKSp"></a><span class="cm-qualifier">.background</span>    { <span class="cm-property">background</span>: <span class="cm-atom">rgb</span>(<span class="cm-number">52</span>, <span class="cm-number">166</span>, <span class="cm-number">251</span>);
                 <span class="cm-property">table-layout</span>: <span class="cm-atom">fixed</span>;
                 <span class="cm-property">border-spacing</span>: <span class="cm-number">0</span>;              }
<span class="cm-qualifier">.background</span> <span class="cm-tag">td</span> { <span class="cm-property">padding</span>: <span class="cm-number">0</span>;                     }
<span class="cm-qualifier">.lava</span>          { <span class="cm-property">background</span>: <span class="cm-atom">rgb</span>(<span class="cm-number">255</span>, <span class="cm-number">100</span>, <span class="cm-number">100</span>); }
<span class="cm-qualifier">.wall</span>          { <span class="cm-property">background</span>: <span class="cm-keyword">white</span>;              }</pre>
<p><a class="p_ident" id="p_Fm4CLmRVL5" href="./15_game.html#p_Fm4CLmRVL5"></a>Някои от тях, като (<code>table-layout</code>, <code>border-spacing</code> и <code>padding</code>) са използвани за подтискане на нежелано поведение по подразбиране. Ние не искаме оформлението на таблицата да зависи от съдържанието на неговите клетки, не искаме също пространство между клетките на таблицата или подплънка вътре в тях.</p>
<p><a class="p_ident" id="p_wtigqOBUxT" href="./15_game.html#p_wtigqOBUxT"></a>Правилото <code>background</code> задава цвета на фона. CSS  позволява цветовете да бъдат определени, като думи (<code>white, red </code> и т.н.) и с формат, като <code>rgb(R, G, B)</code>, където червеното, зеленото и синьото са компонентите на цвета разделени в три цифри от 0 до 255. Така че, в <code>rgb(52, 166, 251)</code> червеният компонент е 52, зеленият е 166, а синьото е 251. Синия  компонент е най-големият и полученият цвят ще е синкав. Можете да видите, че в 
<code>.lava</code> правилото, първата цифра (червено) е най-голяма.</p>
<p><a class="p_ident" id="p_EGE24ax3xh" href="./15_game.html#p_EGE24ax3xh"></a>Ние чертаем всеки участник чрез създаване на DOM елемент за него и определяме позиция и размер за този елемент въз основа на свойствата на актьора. Стойностите трябва да бъдат умножени по <code>scale</code> за да преминем от единици към пиксели.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_dh+IKCYnTO" href="./15_game.html#c_dh+IKCYnTO"></a><span class="cm-variable">DOMDisplay</span>.<span class="cm-property">prototype</span>.<span class="cm-property">drawActors</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>() {
  <span class="cm-keyword">var</span> <span class="cm-def">wrap</span> <span class="cm-operator">=</span> <span class="cm-variable">elt</span>(<span class="cm-string">"div"</span>);
  <span class="cm-keyword">this</span>.<span class="cm-property">level</span>.<span class="cm-property">actors</span>.<span class="cm-property">forEach</span>(<span class="cm-keyword">function</span>(<span class="cm-def">actor</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">rect</span> <span class="cm-operator">=</span> <span class="cm-variable-2">wrap</span>.<span class="cm-property">appendChild</span>(<span class="cm-variable">elt</span>(<span class="cm-string">"div"</span>,
                                    <span class="cm-string">"actor "</span> <span class="cm-operator">+</span> <span class="cm-variable-2">actor</span>.<span class="cm-property">type</span>));
    <span class="cm-variable-2">rect</span>.<span class="cm-property">style</span>.<span class="cm-property">width</span> <span class="cm-operator">=</span> <span class="cm-variable-2">actor</span>.<span class="cm-property">size</span>.<span class="cm-property">x</span> <span class="cm-operator">*</span> <span class="cm-variable">scale</span> <span class="cm-operator">+</span> <span class="cm-string">"px"</span>;
    <span class="cm-variable-2">rect</span>.<span class="cm-property">style</span>.<span class="cm-property">height</span> <span class="cm-operator">=</span> <span class="cm-variable-2">actor</span>.<span class="cm-property">size</span>.<span class="cm-property">y</span> <span class="cm-operator">*</span> <span class="cm-variable">scale</span> <span class="cm-operator">+</span> <span class="cm-string">"px"</span>;
    <span class="cm-variable-2">rect</span>.<span class="cm-property">style</span>.<span class="cm-property">left</span> <span class="cm-operator">=</span> <span class="cm-variable-2">actor</span>.<span class="cm-property">pos</span>.<span class="cm-property">x</span> <span class="cm-operator">*</span> <span class="cm-variable">scale</span> <span class="cm-operator">+</span> <span class="cm-string">"px"</span>;
    <span class="cm-variable-2">rect</span>.<span class="cm-property">style</span>.<span class="cm-property">top</span> <span class="cm-operator">=</span> <span class="cm-variable-2">actor</span>.<span class="cm-property">pos</span>.<span class="cm-property">y</span> <span class="cm-operator">*</span> <span class="cm-variable">scale</span> <span class="cm-operator">+</span> <span class="cm-string">"px"</span>;
  });
  <span class="cm-keyword">return</span> <span class="cm-variable-2">wrap</span>;
};</pre>
<p><a class="p_ident" id="p_N1paxjwHY8" href="./15_game.html#p_N1paxjwHY8"></a>За да дадем на един елемент повече от един клас, ние разделяме името на класа с интервали. В кода на CSS показан след малко, <code>actor</code> класа дава на актьорите абсолютно положение. Техният тип име се използва, като допълнителен клас за да им даде цвят. Ние не трябва да дефинираме отново <code>lava</code> класа, защото повторно ще използваме класа за лава квадратите в мрежата, които дефинирахме по-рано.</p>
<pre data-language="text/css" class="snippet cm-s-default"><a class="c_ident" id="c_gIfxpyXJhS" href="./15_game.html#c_gIfxpyXJhS"></a><span class="cm-qualifier">.actor</span>  { <span class="cm-property">position</span>: <span class="cm-atom">absolute</span>;            }
<span class="cm-qualifier">.coin</span>   { <span class="cm-property">background</span>: <span class="cm-atom">rgb</span>(<span class="cm-number">241</span>, <span class="cm-number">229</span>, <span class="cm-number">89</span>); }
<span class="cm-qualifier">.player</span> { <span class="cm-property">background</span>: <span class="cm-atom">rgb</span>(<span class="cm-number">64</span>, <span class="cm-number">64</span>, <span class="cm-number">64</span>);   }</pre>
<p><a class="p_ident" id="p_ee+EdXi5xG" href="./15_game.html#p_ee+EdXi5xG"></a>Когато се актуализира дисплея, <code>drawFrame</code> метода първо премахва старите графики на актьорите, ако има такива и след това начертава нови в новите им позиции. Можем да се изкушим да използваме повторно DOM елементи за актьори, но за да направим тази работа ще ни трябва поток от много допълнителна информация между кода на дисплея и кода на симулацията. Също ще трябва да обединим актьорите с DOM елементи, а кода на чертежа трябва да отстрани елементите, когато техните участници изчезнат. Тъй като, ще има само една шепа участници в играта, преначертаването на всички тях не е скъпо.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_qkPcdGO1jk" href="./15_game.html#c_qkPcdGO1jk"></a><span class="cm-variable">DOMDisplay</span>.<span class="cm-property">prototype</span>.<span class="cm-property">drawFrame</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>() {
  <span class="cm-keyword">if</span> (<span class="cm-keyword">this</span>.<span class="cm-property">actorLayer</span>)
    <span class="cm-keyword">this</span>.<span class="cm-property">wrap</span>.<span class="cm-property">removeChild</span>(<span class="cm-keyword">this</span>.<span class="cm-property">actorLayer</span>);
  <span class="cm-keyword">this</span>.<span class="cm-property">actorLayer</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">wrap</span>.<span class="cm-property">appendChild</span>(<span class="cm-keyword">this</span>.<span class="cm-property">drawActors</span>());
  <span class="cm-keyword">this</span>.<span class="cm-property">wrap</span>.<span class="cm-property">className</span> <span class="cm-operator">=</span> <span class="cm-string">"game "</span> <span class="cm-operator">+</span> (<span class="cm-keyword">this</span>.<span class="cm-property">level</span>.<span class="cm-property">status</span> <span class="cm-operator">||</span> <span class="cm-string">""</span>);
  <span class="cm-keyword">this</span>.<span class="cm-property">scrollPlayerIntoView</span>();
};</pre>
<p><a class="p_ident" id="p_sZEoSNaFbo" href="./15_game.html#p_sZEoSNaFbo"></a>Чрез добавяне на текущото състояние на нивото, като име на класа на обвивката, можем да оформим играчите малко по-различно, когато играча печели или губи чрез добавяне на CSS правило, което влиза в сила само, когато играча има родител елемент с дадения клас.</p>
<pre data-language="text/css" class="snippet cm-s-default"><a class="c_ident" id="c_r6Td1FPyF0" href="./15_game.html#c_r6Td1FPyF0"></a><span class="cm-qualifier">.lost</span> <span class="cm-qualifier">.player</span> {
  <span class="cm-property">background</span>: <span class="cm-atom">rgb</span>(<span class="cm-number">160</span>, <span class="cm-number">64</span>, <span class="cm-number">64</span>);
}
<span class="cm-qualifier">.won</span> <span class="cm-qualifier">.player</span> {
  <span class="cm-property">box-shadow</span>: <span class="cm-number">-4px</span> <span class="cm-number">-7px</span> <span class="cm-number">8px</span> <span class="cm-keyword">white</span>, <span class="cm-number">4px</span> <span class="cm-number">-7px</span> <span class="cm-number">8px</span> <span class="cm-keyword">white</span>;
}</pre>
<p><a class="p_ident" id="p_Ta1z3iQqo1" href="./15_game.html#p_Ta1z3iQqo1"></a>След докосване на лава, цвета на играча се променя в тъмно червено, което предполага изгаряне. Когато и последната монета е събрана, ще използваме две сенки на замъглени бели кутии, една горе в ляво и една горе в дясно, за да създадем ефект на бял ореол.</p>
<p id="viewport"><a class="p_ident" id="p_hU1RuMZZhL" href="./15_game.html#p_hU1RuMZZhL"></a>Ние не можем да приемем, че нивата винаги се побират в демонстрационния прозорец. Ето защо ни е необходим <code>scrollPlayerIntoView</code>, който гарантира, че ако едно ниво излезе извън рамката, скрола на рамката ще се грижи играча да бъде винаги в нейният център. Следният CSS дава на обвивката на играта в DOM елемента, максимален размер и гарантира, че всичко, което е извън тази кутия не се вижда. Ние също така даваме на външния елемент относителна позиция, така че актьорите в него да са позиционирани спрямо горния ляв ъгъл на нивото.</p>
<pre data-language="text/css" class="snippet cm-s-default"><a class="c_ident" id="c_BblQSzixfX" href="./15_game.html#c_BblQSzixfX"></a><span class="cm-qualifier">.game</span> {
  <span class="cm-property">overflow</span>: <span class="cm-atom">hidden</span>;
  <span class="cm-property">max-width</span>: <span class="cm-number">600px</span>;
  <span class="cm-property">max-height</span>: <span class="cm-number">450px</span>;
  <span class="cm-property">position</span>: <span class="cm-atom">relative</span>;
}</pre>
<p><a class="p_ident" id="p_1/wCuAnu9B" href="./15_game.html#p_1/wCuAnu9B"></a>В <code>scrollPlayerIntoView</code> метода, откриваме позицията на играча и актуализираме позицията на скрола на елемента на обвивката. Сменяме позицията на скрола чрез манипулиране на този елемент с <code>scrollLeft</code> и <code>scrollTop</code> свойствата, когато играча е твърде близо до края.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_JpSyU0Vlxc" href="./15_game.html#c_JpSyU0Vlxc"></a><span class="cm-variable">DOMDisplay</span>.<span class="cm-property">prototype</span>.<span class="cm-property">scrollPlayerIntoView</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>() {
  <span class="cm-keyword">var</span> <span class="cm-def">width</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">wrap</span>.<span class="cm-property">clientWidth</span>;
  <span class="cm-keyword">var</span> <span class="cm-def">height</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">wrap</span>.<span class="cm-property">clientHeight</span>;
  <span class="cm-keyword">var</span> <span class="cm-def">margin</span> <span class="cm-operator">=</span> <span class="cm-variable-2">width</span> <span class="cm-operator">/</span> <span class="cm-number">3</span>;

  <span class="cm-comment">// The viewport</span>
  <span class="cm-keyword">var</span> <span class="cm-def">left</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">wrap</span>.<span class="cm-property">scrollLeft</span>, <span class="cm-def">right</span> <span class="cm-operator">=</span> <span class="cm-variable-2">left</span> <span class="cm-operator">+</span> <span class="cm-variable-2">width</span>;
  <span class="cm-keyword">var</span> <span class="cm-def">top</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">wrap</span>.<span class="cm-property">scrollTop</span>, <span class="cm-def">bottom</span> <span class="cm-operator">=</span> <span class="cm-variable-2">top</span> <span class="cm-operator">+</span> <span class="cm-variable-2">height</span>;

  <span class="cm-keyword">var</span> <span class="cm-def">player</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">level</span>.<span class="cm-property">player</span>;
  <span class="cm-keyword">var</span> <span class="cm-def">center</span> <span class="cm-operator">=</span> <span class="cm-variable-2">player</span>.<span class="cm-property">pos</span>.<span class="cm-property">plus</span>(<span class="cm-variable-2">player</span>.<span class="cm-property">size</span>.<span class="cm-property">times</span>(<span class="cm-number">0.5</span>))
                 .<span class="cm-property">times</span>(<span class="cm-variable">scale</span>);

  <span class="cm-keyword">if</span> (<span class="cm-variable-2">center</span>.<span class="cm-property">x</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">left</span> <span class="cm-operator">+</span> <span class="cm-variable-2">margin</span>)
    <span class="cm-keyword">this</span>.<span class="cm-property">wrap</span>.<span class="cm-property">scrollLeft</span> <span class="cm-operator">=</span> <span class="cm-variable-2">center</span>.<span class="cm-property">x</span> <span class="cm-operator">-</span> <span class="cm-variable-2">margin</span>;
  <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">center</span>.<span class="cm-property">x</span> <span class="cm-operator">&gt;</span> <span class="cm-variable-2">right</span> <span class="cm-operator">-</span> <span class="cm-variable-2">margin</span>)
    <span class="cm-keyword">this</span>.<span class="cm-property">wrap</span>.<span class="cm-property">scrollLeft</span> <span class="cm-operator">=</span> <span class="cm-variable-2">center</span>.<span class="cm-property">x</span> <span class="cm-operator">+</span> <span class="cm-variable-2">margin</span> <span class="cm-operator">-</span> <span class="cm-variable-2">width</span>;
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">center</span>.<span class="cm-property">y</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">top</span> <span class="cm-operator">+</span> <span class="cm-variable-2">margin</span>)
    <span class="cm-keyword">this</span>.<span class="cm-property">wrap</span>.<span class="cm-property">scrollTop</span> <span class="cm-operator">=</span> <span class="cm-variable-2">center</span>.<span class="cm-property">y</span> <span class="cm-operator">-</span> <span class="cm-variable-2">margin</span>;
  <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">center</span>.<span class="cm-property">y</span> <span class="cm-operator">&gt;</span> <span class="cm-variable-2">bottom</span> <span class="cm-operator">-</span> <span class="cm-variable-2">margin</span>)
    <span class="cm-keyword">this</span>.<span class="cm-property">wrap</span>.<span class="cm-property">scrollTop</span> <span class="cm-operator">=</span> <span class="cm-variable-2">center</span>.<span class="cm-property">y</span> <span class="cm-operator">+</span> <span class="cm-variable-2">margin</span> <span class="cm-operator">-</span> <span class="cm-variable-2">height</span>;
};</pre>
<p><a class="p_ident" id="p_3qHzB4KoD+" href="./15_game.html#p_3qHzB4KoD+"></a>Начинът, по който центърът на играча е показан, демонстрира как методите на нашия тип <code>Vector</code> позволяват изчисленията с обекти да бъдат писани по четим начин. За да намерим центъра на актьора, ние добавяме неговата позиция (горния ляв ъгъл) и половината му размер. Това е центърът на координатите на нивото, но имаме нужда от него в пиксели-координати, за да можем след това да умножим резултата от вектора по нашия мащаб на дисплея.</p>
<p><a class="p_ident" id="p_nyYhuiyn32" href="./15_game.html#p_nyYhuiyn32"></a>После, поредица проверки проверяват позицията на играча да не е извън допустимия диапазон. Имайте в предвид, че понякога това прави маса глупости с координатите на скрола, под нула или извън скролната зона на елемента. Добре, че DOM ги ограничава до нормални стойности. Настройване на  <code>scrollLeft</code> към -10 ще го превърне в 0.</p>
<p><a class="p_ident" id="p_MFibm1pU7d" href="./15_game.html#p_MFibm1pU7d"></a>Щеше да е малко по-лесно да опитаме да местим играча винаги в центъра на демонстрационния прозорец. Но това създава шокиращ ефект. Когато скача, гледката непрекъснато се мести нагоре и надолу. Ще е по-приятно да има “неутрална” зона в средата на екрана, където можем да се движим без да причиняваме скролване.</p>
<p><a class="p_ident" id="p_5o/NVpkfaU" href="./15_game.html#p_5o/NVpkfaU"></a>И накрая, се нуждаем от начин за изчистване на показаното ниво, за да се използва, когато играта се движи към следващото ниво или нулира нивото.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_MTWKiFt3b3" href="./15_game.html#c_MTWKiFt3b3"></a><span class="cm-variable">DOMDisplay</span>.<span class="cm-property">prototype</span>.<span class="cm-property">clear</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>() {
  <span class="cm-keyword">this</span>.<span class="cm-property">wrap</span>.<span class="cm-property">parentNode</span>.<span class="cm-property">removeChild</span>(<span class="cm-keyword">this</span>.<span class="cm-property">wrap</span>);
};</pre>
<p><a class="p_ident" id="p_LSD2j1d23Y" href="./15_game.html#p_LSD2j1d23Y"></a>В момента сме в състояние да покажем нашето малко ниво.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_RY/T0/6wz3" href="./15_game.html#c_RY/T0/6wz3"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">link</span> <span class="cm-attribute">rel</span>=<span class="cm-string">"stylesheet"</span> <span class="cm-attribute">href</span>=<span class="cm-string">"css/game.css"</span><span class="cm-tag cm-bracket">&gt;</span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">simpleLevel</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Level</span>(<span class="cm-variable">simpleLevelPlan</span>);
  <span class="cm-keyword">var</span> <span class="cm-variable">display</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">DOMDisplay</span>(<span class="cm-variable">document</span>.<span class="cm-property">body</span>, <span class="cm-variable">simpleLevel</span>);
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_CLn8fpSTCw" href="./15_game.html#p_CLn8fpSTCw"></a>The <code>&lt;link&gt;</code> тага, когато се използва с <code>rel="stylesheet"</code> е начин да се зареди CSS файл в страницата. Файла <code>game.css</code> съдържа стиловете необходими за нашата игра.</p>
<h2><a class="h_ident" id="h_zX4xC7JBQU" href="./15_game.html#h_zX4xC7JBQU"></a>Движение  и  сблъсък</h2>
<p><a class="p_ident" id="p_VZl40vezkA" href="./15_game.html#p_VZl40vezkA"></a>Сега сме на мястото, където можем да започнем да добавяме движение, най-интересния аспект от играта. Основният подход, използван в повечето игри, е да се раздели времето на малки стъпки и всяка стъпка премества актьорите на разстояние съответстващо на тяхната скорост (преместване в секунда) умножено по размера на  времето за стъпка (в секунди).</p>
<p><a class="p_ident" id="p_+a3yt6NY8z" href="./15_game.html#p_+a3yt6NY8z"></a>Това е лесно. Трудната част е взаимодействието между елементите. Когато играчът удари стена или под, той не може просто да се движи през тях. Играта трябва да забележи, когато дадено движение причинява удар на един обект с друг и да реагира по съответния начин. За стени движението трябва да бъде спряно. За монети, монетата трябва да бъде взета и т.н.</p>
<p><a class="p_ident" id="p_AidQCfGku0" href="./15_game.html#p_AidQCfGku0"></a>Решаването на тези общи случаи е голяма задача. Можете да намерите библиотеки, обикновено се наричат физични двигатели, които симулират взаимодействие между физически обекти в две или три измерения. Ще използваме по-скромен подход в тази глава, манипулиране единствено сблъсъците между правоъгълни предмети и обработката им по един доста опростен начин.</p>
<p><a class="p_ident" id="p_qnEGluIxK3" href="./15_game.html#p_qnEGluIxK3"></a>Преди да преместим играч или блок от лава, ние тестваме дали движението не идва от вътрешността на не-празна част на фона. Ако е така, просто спираме движението напълно. Отговорът на такъв сблъсък зависи от вида на актьора: играча ще спре, докато блока на лавата се съвземе.</p>
<p><a class="p_ident" id="p_Y/iDVnt+Uc" href="./15_game.html#p_Y/iDVnt+Uc"></a>Този подход изисква стъпките от време да бъдат по-скоро малки, тъй като това ще доведе до движение, което да спре преди обектите да се докоснат. Ако стъпките от време (и по този начин етапите на движение) са твърде големи, играчът ще се окаже в положение да лети на забележимо разстояние над земята. Друг подход, може би по-добър но по-сложен, е да се намери точното място на сблъсъка и да се премести там. Ние ще използваме простия подход и ще скрием проблемите чрез осигуряване на анимация в малки стъпки.</p>
<p><a class="p_ident" id="p_mgrJ3S203s" href="./15_game.html#p_mgrJ3S203s"></a>Този метод ни казва дали един правоъгълник (с посочена позиция и размер) се припокрива с всяко не-празно пространство на фона на мрежата.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_uIS9dqP9so" href="./15_game.html#c_uIS9dqP9so"></a><span class="cm-variable">Level</span>.<span class="cm-property">prototype</span>.<span class="cm-property">obstacleAt</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">pos</span>, <span class="cm-def">size</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">xStart</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">floor</span>(<span class="cm-variable-2">pos</span>.<span class="cm-property">x</span>);
  <span class="cm-keyword">var</span> <span class="cm-def">xEnd</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">ceil</span>(<span class="cm-variable-2">pos</span>.<span class="cm-property">x</span> <span class="cm-operator">+</span> <span class="cm-variable-2">size</span>.<span class="cm-property">x</span>);
  <span class="cm-keyword">var</span> <span class="cm-def">yStart</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">floor</span>(<span class="cm-variable-2">pos</span>.<span class="cm-property">y</span>);
  <span class="cm-keyword">var</span> <span class="cm-def">yEnd</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">ceil</span>(<span class="cm-variable-2">pos</span>.<span class="cm-property">y</span> <span class="cm-operator">+</span> <span class="cm-variable-2">size</span>.<span class="cm-property">y</span>);

  <span class="cm-keyword">if</span> (<span class="cm-variable-2">xStart</span> <span class="cm-operator">&lt;</span> <span class="cm-number">0</span> <span class="cm-operator">||</span> <span class="cm-variable-2">xEnd</span> <span class="cm-operator">&gt;</span> <span class="cm-keyword">this</span>.<span class="cm-property">width</span> <span class="cm-operator">||</span> <span class="cm-variable-2">yStart</span> <span class="cm-operator">&lt;</span> <span class="cm-number">0</span>)
    <span class="cm-keyword">return</span> <span class="cm-string">"wall"</span>;
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">yEnd</span> <span class="cm-operator">&gt;</span> <span class="cm-keyword">this</span>.<span class="cm-property">height</span>)
    <span class="cm-keyword">return</span> <span class="cm-string">"lava"</span>;
  <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">y</span> <span class="cm-operator">=</span> <span class="cm-variable-2">yStart</span>; <span class="cm-variable-2">y</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">yEnd</span>; <span class="cm-variable-2">y</span><span class="cm-operator">++</span>) {
    <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">x</span> <span class="cm-operator">=</span> <span class="cm-variable-2">xStart</span>; <span class="cm-variable-2">x</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">xEnd</span>; <span class="cm-variable-2">x</span><span class="cm-operator">++</span>) {
      <span class="cm-keyword">var</span> <span class="cm-def">fieldType</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">grid</span>[<span class="cm-variable-2">y</span>][<span class="cm-variable-2">x</span>];
      <span class="cm-keyword">if</span> (<span class="cm-variable-2">fieldType</span>) <span class="cm-keyword">return</span> <span class="cm-variable-2">fieldType</span>;
    }
  }
};</pre>
<p><a class="p_ident" id="p_PToDD5K9+0" href="./15_game.html#p_PToDD5K9+0"></a>Този метод изчислява набор от мрежови квадрати, с които тялото се препокрива, като използва <code>Math.floor</code>
и <code>Math.ceil</code> за координатите на тялото. Не забравяйте, че мрежата от квадрати е с размер 1х1 единици. Чрез закръгляне страните на кутията на горе и на долу, ние получаваме обхвата на фоновите квадрати, които кутията докосва.</p>
<div class="image">
  <img src="./media/game-grid.svg" alt="Finding collisions on a grid">
</div>
<p><a class="p_ident" id="p_MZ2cPIh/k/" href="./15_game.html#p_MZ2cPIh/k/"></a>Ако тялото стърчи извън нивото, ние винаги връщаме <code>"wall"</code> за страните и тавана и <code>"lava"</code> за дъното. Това гарантира, че играчът винаги умира, когато падне извън света. Когато тялото е точно в рамката на мрежата, ние циклим над блока от мрежови квадрати определени със закръгляне на координатите и връщаме съдържанието на първия  не-празен квадрат, който открием</p>
<p><a class="p_ident" id="p_oAeaIvbuEY" href="./15_game.html#p_oAeaIvbuEY"></a>Сблъсъка между играча и други динамични актьори (монети, лава) се изпълнява, след като играча се премести. Когато движението на играча продължава навътре в друг актьор, се активира подходящ ефект - събиране на монета или умиране.</p>
<p><a class="p_ident" id="p_9zGn/O3Wbz" href="./15_game.html#p_9zGn/O3Wbz"></a>Този метод сканира масива от участници, като търси актьор, който се  припокрива с този, който е даден, като аргумент.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_WU18TYQa9n" href="./15_game.html#c_WU18TYQa9n"></a><span class="cm-variable">Level</span>.<span class="cm-property">prototype</span>.<span class="cm-property">actorAt</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">actor</span>) {
  <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">i</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">i</span> <span class="cm-operator">&lt;</span> <span class="cm-keyword">this</span>.<span class="cm-property">actors</span>.<span class="cm-property">length</span>; <span class="cm-variable-2">i</span><span class="cm-operator">++</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">other</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">actors</span>[<span class="cm-variable-2">i</span>];
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">other</span> <span class="cm-operator">!=</span> <span class="cm-variable-2">actor</span> <span class="cm-operator">&amp;&amp;</span>
        <span class="cm-variable-2">actor</span>.<span class="cm-property">pos</span>.<span class="cm-property">x</span> <span class="cm-operator">+</span> <span class="cm-variable-2">actor</span>.<span class="cm-property">size</span>.<span class="cm-property">x</span> <span class="cm-operator">&gt;</span> <span class="cm-variable-2">other</span>.<span class="cm-property">pos</span>.<span class="cm-property">x</span> <span class="cm-operator">&amp;&amp;</span>
        <span class="cm-variable-2">actor</span>.<span class="cm-property">pos</span>.<span class="cm-property">x</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">other</span>.<span class="cm-property">pos</span>.<span class="cm-property">x</span> <span class="cm-operator">+</span> <span class="cm-variable-2">other</span>.<span class="cm-property">size</span>.<span class="cm-property">x</span> <span class="cm-operator">&amp;&amp;</span>
        <span class="cm-variable-2">actor</span>.<span class="cm-property">pos</span>.<span class="cm-property">y</span> <span class="cm-operator">+</span> <span class="cm-variable-2">actor</span>.<span class="cm-property">size</span>.<span class="cm-property">y</span> <span class="cm-operator">&gt;</span> <span class="cm-variable-2">other</span>.<span class="cm-property">pos</span>.<span class="cm-property">y</span> <span class="cm-operator">&amp;&amp;</span>
        <span class="cm-variable-2">actor</span>.<span class="cm-property">pos</span>.<span class="cm-property">y</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">other</span>.<span class="cm-property">pos</span>.<span class="cm-property">y</span> <span class="cm-operator">+</span> <span class="cm-variable-2">other</span>.<span class="cm-property">size</span>.<span class="cm-property">y</span>)
      <span class="cm-keyword">return</span> <span class="cm-variable-2">other</span>;
  }
};</pre>
<h2 id="actors"><a class="h_ident" id="h_CK9RMsBUn4" href="./15_game.html#h_CK9RMsBUn4"></a>Актьори  и  действия</h2>
<p><a class="p_ident" id="p_HatfNTrDd5" href="./15_game.html#p_HatfNTrDd5"></a>Метода <code>animate</code> на типа <code>Level</code> дава на всички участници в нивото шанс да се движат. Неговия аргумент <code>step</code> е стъпката на времето в секунди. Обекта <code>keys</code> съдържа информация за клавишите със стрелки  за играча, когато са натиснати.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_qGNXH1TwL8" href="./15_game.html#c_qGNXH1TwL8"></a><span class="cm-keyword">var</span> <span class="cm-variable">maxStep</span> <span class="cm-operator">=</span> <span class="cm-number">0.05</span>;

<span class="cm-variable">Level</span>.<span class="cm-property">prototype</span>.<span class="cm-property">animate</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">step</span>, <span class="cm-def">keys</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-keyword">this</span>.<span class="cm-property">status</span> <span class="cm-operator">!=</span> <span class="cm-atom">null</span>)
    <span class="cm-keyword">this</span>.<span class="cm-property">finishDelay</span> <span class="cm-operator">-=</span> <span class="cm-variable-2">step</span>;

  <span class="cm-keyword">while</span> (<span class="cm-variable-2">step</span> <span class="cm-operator">&gt;</span> <span class="cm-number">0</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">thisStep</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">min</span>(<span class="cm-variable-2">step</span>, <span class="cm-variable">maxStep</span>);
    <span class="cm-keyword">this</span>.<span class="cm-property">actors</span>.<span class="cm-property">forEach</span>(<span class="cm-keyword">function</span>(<span class="cm-def">actor</span>) {
      <span class="cm-variable-2">actor</span>.<span class="cm-property">act</span>(<span class="cm-variable-2">thisStep</span>, <span class="cm-keyword">this</span>, <span class="cm-variable-2">keys</span>);
    }, <span class="cm-keyword">this</span>);
    <span class="cm-variable-2">step</span> <span class="cm-operator">-=</span> <span class="cm-variable-2">thisStep</span>;
  }
};</pre>
<p><a class="p_ident" id="p_3CL3X0Momn" href="./15_game.html#p_3CL3X0Momn"></a>Когато свойството <code>status</code> на нивото не е празна стойност (това е случаят, когато играчът е спечелил или загубил) трябва да отчетем резултата със свойството <code>finishDelay</code>, което е точно момента между точката на преминаване към мястото на победа или загуба и на мястото, където искаме да спре да се показва нивото.</p>
<p><a class="p_ident" id="p_1RlyY9ZKcW" href="./15_game.html#p_1RlyY9ZKcW"></a><code>While</code> цикъла обхожда стъпките от време, които анимираме в подходящи малки парчета. Той гарантира, че няма взета стъпка по-голяма от <code>maxStep</code>. Например, една стъпка от 0.12 секунди ще бъде нарязана на две стъпки от по 0.05 и една стъпка от 0.02 секунди.</p>
<p><a class="p_ident" id="p_AiCSiwkX6Y" href="./15_game.html#p_AiCSiwkX6Y"></a>Обекта на актьорите има метод <code>act</code>, който приема за аргументи стъпка на времето, обекта ниво и <code>keys</code> обекта. Това е обекта на типа <code>Lava</code>, който игнорира <code>keys</code> обекта.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_y3oz8d4Sdf" href="./15_game.html#c_y3oz8d4Sdf"></a><span class="cm-variable">Lava</span>.<span class="cm-property">prototype</span>.<span class="cm-property">act</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">step</span>, <span class="cm-def">level</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">newPos</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">pos</span>.<span class="cm-property">plus</span>(<span class="cm-keyword">this</span>.<span class="cm-property">speed</span>.<span class="cm-property">times</span>(<span class="cm-variable-2">step</span>));
  <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable-2">level</span>.<span class="cm-property">obstacleAt</span>(<span class="cm-variable-2">newPos</span>, <span class="cm-keyword">this</span>.<span class="cm-property">size</span>))
    <span class="cm-keyword">this</span>.<span class="cm-property">pos</span> <span class="cm-operator">=</span> <span class="cm-variable-2">newPos</span>;
  <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-keyword">this</span>.<span class="cm-property">repeatPos</span>)
    <span class="cm-keyword">this</span>.<span class="cm-property">pos</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">repeatPos</span>;
  <span class="cm-keyword">else</span>
    <span class="cm-keyword">this</span>.<span class="cm-property">speed</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">speed</span>.<span class="cm-property">times</span>(<span class="cm-operator">-</span><span class="cm-number">1</span>);
};</pre>
<p><a class="p_ident" id="p_hQ66AcUb17" href="./15_game.html#p_hQ66AcUb17"></a>Той изчислява нова позиция чрез добавяне на продукта на стъпка от времето и сегашната скорост от старата позиция. Ако няма пречка, която да блокира тази нова позиция, тя се движи на там. Ако има препятствие поведението зависи от вида на лава блока - капеща лава, която има свойство <code>repeatPos</code>, с което се връща обратно, когато удари нещо. Изригващата лава просто обръща скоростта (като се умножи по -1), за да започне да се движи в обратна посока.</p>
<p><a class="p_ident" id="p_1RXQ29sidv" href="./15_game.html#p_1RXQ29sidv"></a>Монетите използват своя <code>act</code> метод за да потрепват. Те пренебрегват сблъсъци, тъй като се клатушкат във вътрешноста на собствения си квадрат и сблъсъците ще се обработват от метода <code>act</code> на играча.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_CVksWY2lbJ" href="./15_game.html#c_CVksWY2lbJ"></a><span class="cm-keyword">var</span> <span class="cm-variable">wobbleSpeed</span> <span class="cm-operator">=</span> <span class="cm-number">8</span>, <span class="cm-variable">wobbleDist</span> <span class="cm-operator">=</span> <span class="cm-number">0.07</span>;

<span class="cm-variable">Coin</span>.<span class="cm-property">prototype</span>.<span class="cm-property">act</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">step</span>) {
  <span class="cm-keyword">this</span>.<span class="cm-property">wobble</span> <span class="cm-operator">+=</span> <span class="cm-variable-2">step</span> <span class="cm-operator">*</span> <span class="cm-variable">wobbleSpeed</span>;
  <span class="cm-keyword">var</span> <span class="cm-def">wobblePos</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">sin</span>(<span class="cm-keyword">this</span>.<span class="cm-property">wobble</span>) <span class="cm-operator">*</span> <span class="cm-variable">wobbleDist</span>;
  <span class="cm-keyword">this</span>.<span class="cm-property">pos</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">basePos</span>.<span class="cm-property">plus</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Vector</span>(<span class="cm-number">0</span>, <span class="cm-variable-2">wobblePos</span>));
};</pre>
<p><a class="p_ident" id="p_aXWUL4a4Y+" href="./15_game.html#p_aXWUL4a4Y+"></a>Свойството <code>wobble</code> се актуализира за да следим времето и след това се използва, като аргумент за <code>Math.sin</code> за да създаде вълна, която се използва за изчисляване на нова позиция.</p>
<p><a class="p_ident" id="p_7eSdIMS/wV" href="./15_game.html#p_7eSdIMS/wV"></a>Остана само играча. Движението на играча се обработва отделно за всяка ос, защото когато удря пода, това не трябва да пречи на хоризонталното движение и когато удря стена, това не трябва спира движението на падане или скачане. следващия метод изпълнява хоризонталната част:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_Fx/WuBkAiY" href="./15_game.html#c_Fx/WuBkAiY"></a><span class="cm-keyword">var</span> <span class="cm-variable">playerXSpeed</span> <span class="cm-operator">=</span> <span class="cm-number">7</span>;

<span class="cm-variable">Player</span>.<span class="cm-property">prototype</span>.<span class="cm-property">moveX</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">step</span>, <span class="cm-def">level</span>, <span class="cm-def">keys</span>) {
  <span class="cm-keyword">this</span>.<span class="cm-property">speed</span>.<span class="cm-property">x</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>;
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">keys</span>.<span class="cm-property">left</span>) <span class="cm-keyword">this</span>.<span class="cm-property">speed</span>.<span class="cm-property">x</span> <span class="cm-operator">-=</span> <span class="cm-variable">playerXSpeed</span>;
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">keys</span>.<span class="cm-property">right</span>) <span class="cm-keyword">this</span>.<span class="cm-property">speed</span>.<span class="cm-property">x</span> <span class="cm-operator">+=</span> <span class="cm-variable">playerXSpeed</span>;

  <span class="cm-keyword">var</span> <span class="cm-def">motion</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Vector</span>(<span class="cm-keyword">this</span>.<span class="cm-property">speed</span>.<span class="cm-property">x</span> <span class="cm-operator">*</span> <span class="cm-variable-2">step</span>, <span class="cm-number">0</span>);
  <span class="cm-keyword">var</span> <span class="cm-def">newPos</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">pos</span>.<span class="cm-property">plus</span>(<span class="cm-variable-2">motion</span>);
  <span class="cm-keyword">var</span> <span class="cm-def">obstacle</span> <span class="cm-operator">=</span> <span class="cm-variable-2">level</span>.<span class="cm-property">obstacleAt</span>(<span class="cm-variable-2">newPos</span>, <span class="cm-keyword">this</span>.<span class="cm-property">size</span>);
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">obstacle</span>)
    <span class="cm-variable-2">level</span>.<span class="cm-property">playerTouched</span>(<span class="cm-variable-2">obstacle</span>);
  <span class="cm-keyword">else</span>
    <span class="cm-keyword">this</span>.<span class="cm-property">pos</span> <span class="cm-operator">=</span> <span class="cm-variable-2">newPos</span>;
};</pre>
<p><a class="p_ident" id="p_Tdw21cw9Dq" href="./15_game.html#p_Tdw21cw9Dq"></a>Хоризонталното движение се изчислява на базата на състоянието на левия и десния клавиш със стрелка. Когато едно движение е причина играча да се удари в нещо в нивото, метода <code>playerTouched</code> който се занимава с неща, като умиране в лава и събиране на монети се извиква. В противен случай обекта актуализира своята позиция.</p>
<p><a class="p_ident" id="p_du3894nYAV" href="./15_game.html#p_du3894nYAV"></a>Вертикалното движение работи по подобен начин, но трябва да симулира скок и гравитация.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_G4ZeyHb3zj" href="./15_game.html#c_G4ZeyHb3zj"></a><span class="cm-keyword">var</span> <span class="cm-variable">gravity</span> <span class="cm-operator">=</span> <span class="cm-number">30</span>;
<span class="cm-keyword">var</span> <span class="cm-variable">jumpSpeed</span> <span class="cm-operator">=</span> <span class="cm-number">17</span>;

<span class="cm-variable">Player</span>.<span class="cm-property">prototype</span>.<span class="cm-property">moveY</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">step</span>, <span class="cm-def">level</span>, <span class="cm-def">keys</span>) {
  <span class="cm-keyword">this</span>.<span class="cm-property">speed</span>.<span class="cm-property">y</span> <span class="cm-operator">+=</span> <span class="cm-variable-2">step</span> <span class="cm-operator">*</span> <span class="cm-variable">gravity</span>;
  <span class="cm-keyword">var</span> <span class="cm-def">motion</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Vector</span>(<span class="cm-number">0</span>, <span class="cm-keyword">this</span>.<span class="cm-property">speed</span>.<span class="cm-property">y</span> <span class="cm-operator">*</span> <span class="cm-variable-2">step</span>);
  <span class="cm-keyword">var</span> <span class="cm-def">newPos</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">pos</span>.<span class="cm-property">plus</span>(<span class="cm-variable-2">motion</span>);
  <span class="cm-keyword">var</span> <span class="cm-def">obstacle</span> <span class="cm-operator">=</span> <span class="cm-variable-2">level</span>.<span class="cm-property">obstacleAt</span>(<span class="cm-variable-2">newPos</span>, <span class="cm-keyword">this</span>.<span class="cm-property">size</span>);
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">obstacle</span>) {
    <span class="cm-variable-2">level</span>.<span class="cm-property">playerTouched</span>(<span class="cm-variable-2">obstacle</span>);
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">keys</span>.<span class="cm-property">up</span> <span class="cm-operator">&amp;&amp;</span> <span class="cm-keyword">this</span>.<span class="cm-property">speed</span>.<span class="cm-property">y</span> <span class="cm-operator">&gt;</span> <span class="cm-number">0</span>)
      <span class="cm-keyword">this</span>.<span class="cm-property">speed</span>.<span class="cm-property">y</span> <span class="cm-operator">=</span> <span class="cm-operator">-</span><span class="cm-variable">jumpSpeed</span>;
    <span class="cm-keyword">else</span>
      <span class="cm-keyword">this</span>.<span class="cm-property">speed</span>.<span class="cm-property">y</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>;
  } <span class="cm-keyword">else</span> {
    <span class="cm-keyword">this</span>.<span class="cm-property">pos</span> <span class="cm-operator">=</span> <span class="cm-variable-2">newPos</span>;
  }
};</pre>
<p><a class="p_ident" id="p_n3f+aTx4m7" href="./15_game.html#p_n3f+aTx4m7"></a>В началото на метода, играча ускорява вертикално за отчитане на гравитацията. Гравитацията, скоростта на скока и почти всички останали константи в тази игра са определени с метода опит - грешка. Тествах различни стойности, докато открих комбинация, която да ми хареса.</p>
<p><a class="p_ident" id="p_Vtbh5elQbX" href="./15_game.html#p_Vtbh5elQbX"></a>След това проверяваме за пречки отново. Ако се ударим в нещо има два възможни изхода. Когато стрелката за нагоре е натисната и ние се движим надолу (което, означава, че нещото в което сме се ударили е под нас), скоростта е настроена към сравнително по-голяма отрицателна стойност. Това причинява скок на играча. Ако това не е така, той просто се е блъснал в нещо и скоростта се нулира.</p>
<p><a class="p_ident" id="p_YCAh/Cx+MG" href="./15_game.html#p_YCAh/Cx+MG"></a>Действителния <code>act</code> метод изглежда така:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_xxPyq2OH/6" href="./15_game.html#c_xxPyq2OH/6"></a><span class="cm-variable">Player</span>.<span class="cm-property">prototype</span>.<span class="cm-property">act</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">step</span>, <span class="cm-def">level</span>, <span class="cm-def">keys</span>) {
  <span class="cm-keyword">this</span>.<span class="cm-property">moveX</span>(<span class="cm-variable-2">step</span>, <span class="cm-variable-2">level</span>, <span class="cm-variable-2">keys</span>);
  <span class="cm-keyword">this</span>.<span class="cm-property">moveY</span>(<span class="cm-variable-2">step</span>, <span class="cm-variable-2">level</span>, <span class="cm-variable-2">keys</span>);

  <span class="cm-keyword">var</span> <span class="cm-def">otherActor</span> <span class="cm-operator">=</span> <span class="cm-variable-2">level</span>.<span class="cm-property">actorAt</span>(<span class="cm-keyword">this</span>);
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">otherActor</span>)
    <span class="cm-variable-2">level</span>.<span class="cm-property">playerTouched</span>(<span class="cm-variable-2">otherActor</span>.<span class="cm-property">type</span>, <span class="cm-variable-2">otherActor</span>);

  <span class="cm-comment">// Losing animation</span>
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">level</span>.<span class="cm-property">status</span> <span class="cm-operator">==</span> <span class="cm-string">"lost"</span>) {
    <span class="cm-keyword">this</span>.<span class="cm-property">pos</span>.<span class="cm-property">y</span> <span class="cm-operator">+=</span> <span class="cm-variable-2">step</span>;
    <span class="cm-keyword">this</span>.<span class="cm-property">size</span>.<span class="cm-property">y</span> <span class="cm-operator">-=</span> <span class="cm-variable-2">step</span>;
  }
};</pre>
<p><a class="p_ident" id="p_4WJ+6ygCcZ" href="./15_game.html#p_4WJ+6ygCcZ"></a>След като се премести, следват проверките на метода за други участници, с които играча се сблъсква и отново извиква <code>playerTouched</code>, ако намери един. Този път той приема обекта на актьора, като втори аргумент, защото ако другия участник е монета, <code>playerTouched</code> трябва да знае, че монетите се събират.</p>
<p><a class="p_ident" id="p_ZvTlzr2mKf" href="./15_game.html#p_ZvTlzr2mKf"></a>И накрая, когато играчът умира (докосва лава), ще създадем малко анимация, която го кара да се “свие” или ”потъне”, като намалим височината на обекта на играча.</p>
<p><a class="p_ident" id="p_ax6pc274qT" href="./15_game.html#p_ax6pc274qT"></a>Тук е метода, който обработва сблъсъци между играча и други обекти:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_2WmUjFnyOX" href="./15_game.html#c_2WmUjFnyOX"></a><span class="cm-variable">Level</span>.<span class="cm-property">prototype</span>.<span class="cm-property">playerTouched</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">type</span>, <span class="cm-def">actor</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">type</span> <span class="cm-operator">==</span> <span class="cm-string">"lava"</span> <span class="cm-operator">&amp;&amp;</span> <span class="cm-keyword">this</span>.<span class="cm-property">status</span> <span class="cm-operator">==</span> <span class="cm-atom">null</span>) {
    <span class="cm-keyword">this</span>.<span class="cm-property">status</span> <span class="cm-operator">=</span> <span class="cm-string">"lost"</span>;
    <span class="cm-keyword">this</span>.<span class="cm-property">finishDelay</span> <span class="cm-operator">=</span> <span class="cm-number">1</span>;
  } <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">type</span> <span class="cm-operator">==</span> <span class="cm-string">"coin"</span>) {
    <span class="cm-keyword">this</span>.<span class="cm-property">actors</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">actors</span>.<span class="cm-property">filter</span>(<span class="cm-keyword">function</span>(<span class="cm-def">other</span>) {
      <span class="cm-keyword">return</span> <span class="cm-variable-2">other</span> <span class="cm-operator">!=</span> <span class="cm-variable-2">actor</span>;
    });
    <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-keyword">this</span>.<span class="cm-property">actors</span>.<span class="cm-property">some</span>(<span class="cm-keyword">function</span>(<span class="cm-def">actor</span>) {
      <span class="cm-keyword">return</span> <span class="cm-variable-2">actor</span>.<span class="cm-property">type</span> <span class="cm-operator">==</span> <span class="cm-string">"coin"</span>;
    })) {
      <span class="cm-keyword">this</span>.<span class="cm-property">status</span> <span class="cm-operator">=</span> <span class="cm-string">"won"</span>;
      <span class="cm-keyword">this</span>.<span class="cm-property">finishDelay</span> <span class="cm-operator">=</span> <span class="cm-number">1</span>;
    }
  }
};</pre>
<p><a class="p_ident" id="p_2TZ51jE0Cq" href="./15_game.html#p_2TZ51jE0Cq"></a>Когато се докосне лава, статуса на играта е настроен на “загуба”. Когато се докосне до монета, тя се отстранява от масива с участници и ако тя е последна, статуса на играта е настроен на “победа”.</p>
<p><a class="p_ident" id="p_Tb0QFBJu6P" href="./15_game.html#p_Tb0QFBJu6P"></a>Това ни дава ниво, което действително може да бъде анимирано. Всичко, което липсва в момента е кодът, който задвижва анимацията.</p>
<h2><a class="h_ident" id="h_zKch6Si/SS" href="./15_game.html#h_zKch6Si/SS"></a>Клавиши за проследяване</h2>
<p><a class="p_ident" id="p_6qSDIbEzkh" href="./15_game.html#p_6qSDIbEzkh"></a>За игра, като тази ние не искаме действие на клавиши с еднократно натискане. Напротив, техният ефект (преместване на фигурата на играча) да продължи да се случва толкова дълго, докато те са натиснати.</p>
<p><a class="p_ident" id="p_kKDop4NY9B" href="./15_game.html#p_kKDop4NY9B"></a>Трябва да създадем основен манипулатор, който съхранява текущото състояние на стрелката за на ляво, на дясно и на горе. Също ще трябва да извикаме <code>preventDefault</code> за тези клавиши, така че да не останат натиснати при скролване на страницата.</p>
<p><a class="p_ident" id="p_oH4kiTyM1E" href="./15_game.html#p_oH4kiTyM1E"></a>Следната функция и е даден обект с клавишни кодове, като свойство с имена и клавишни имена, като стойности, въръща обект, който следи текущото положение на тези клавиши. Тя регистрира манипулатори на събития за събитията <code>"keydown"</code> и <code>"keyup"</code>, когато клавишния код присъства в набора от кодове, които се проследяват и актуализира обекта.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_cppQQkFO50" href="./15_game.html#c_cppQQkFO50"></a><span class="cm-keyword">var</span> <span class="cm-variable">arrowCodes</span> <span class="cm-operator">=</span> {<span class="cm-number cm-property">37</span>: <span class="cm-string">"left"</span>, <span class="cm-number cm-property">38</span>: <span class="cm-string">"up"</span>, <span class="cm-number cm-property">39</span>: <span class="cm-string">"right"</span>};

<span class="cm-keyword">function</span> <span class="cm-variable">trackKeys</span>(<span class="cm-def">codes</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">pressed</span> <span class="cm-operator">=</span> <span class="cm-variable">Object</span>.<span class="cm-property">create</span>(<span class="cm-atom">null</span>);
  <span class="cm-keyword">function</span> <span class="cm-def">handler</span>(<span class="cm-def">event</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">codes</span>.<span class="cm-property">hasOwnProperty</span>(<span class="cm-variable-2">event</span>.<span class="cm-property">keyCode</span>)) {
      <span class="cm-keyword">var</span> <span class="cm-def">down</span> <span class="cm-operator">=</span> <span class="cm-variable-2">event</span>.<span class="cm-property">type</span> <span class="cm-operator">==</span> <span class="cm-string">"keydown"</span>;
      <span class="cm-variable-2">pressed</span>[<span class="cm-variable-2">codes</span>[<span class="cm-variable-2">event</span>.<span class="cm-property">keyCode</span>]] <span class="cm-operator">=</span> <span class="cm-variable-2">down</span>;
      <span class="cm-variable-2">event</span>.<span class="cm-property">preventDefault</span>();
    }
  }
  <span class="cm-variable">addEventListener</span>(<span class="cm-string">"keydown"</span>, <span class="cm-variable-2">handler</span>);
  <span class="cm-variable">addEventListener</span>(<span class="cm-string">"keyup"</span>, <span class="cm-variable-2">handler</span>);
  <span class="cm-keyword">return</span> <span class="cm-variable-2">pressed</span>;
}</pre>
<p><a class="p_ident" id="p_ijH6rqUGtM" href="./15_game.html#p_ijH6rqUGtM"></a>Забележете, че една и съща функция манипулатор се използва и за двата вида събития. Тя преглежда <code>type</code> свойството на обекта на събитието, за да определи дали клавишното състояние трябва да се актуализира с <code>true</code> за (<code>"keydown"</code>) или с <code>false</code> за (<code>"keyup"</code>).</p>
<h2 id="runAnimation"><a class="h_ident" id="h_/jwYTlYjAy" href="./15_game.html#h_/jwYTlYjAy"></a>Стартиране  на  играта</h2>
<p><a class="p_ident" id="p_3fS5a/SYfz" href="./15_game.html#p_3fS5a/SYfz"></a>Функцията 
<code>requestAnimationFrame</code>, която видяхме в <a href="./13_dom.html#animationFrame">Глава 13</a>, осигурява един добър начин за анимиране на играта. Но нейният интерфейс е доста примитивен - ако го използваме трябва да следим времето, в което нашата функция е била извикана последно и да я извикваме отново <code>requestAnimationFrame</code> след всеки кадър.</p>
<p><a class="p_ident" id="p_6blpyw8yI3" href="./15_game.html#p_6blpyw8yI3"></a>Нека да дефинираме помощна функция, която обвива тези скучни части в удобен интерфейс и ни позволява да я извикаме просто, като <code>runAnimation</code>, като и дадем функция, която очаква времевата разлика, като аргумент и връща един кадър. Когато функцията <em>frame</em> върне <code>false</code>, анимацията спира.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_1AHi38WBun" href="./15_game.html#c_1AHi38WBun"></a><span class="cm-keyword">function</span> <span class="cm-variable">runAnimation</span>(<span class="cm-def">frameFunc</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">lastTime</span> <span class="cm-operator">=</span> <span class="cm-atom">null</span>;
  <span class="cm-keyword">function</span> <span class="cm-def">frame</span>(<span class="cm-def">time</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">stop</span> <span class="cm-operator">=</span> <span class="cm-atom">false</span>;
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">lastTime</span> <span class="cm-operator">!=</span> <span class="cm-atom">null</span>) {
      <span class="cm-keyword">var</span> <span class="cm-def">timeStep</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">min</span>(<span class="cm-variable-2">time</span> <span class="cm-operator">-</span> <span class="cm-variable-2">lastTime</span>, <span class="cm-number">100</span>) <span class="cm-operator">/</span> <span class="cm-number">1000</span>;
      <span class="cm-variable-2">stop</span> <span class="cm-operator">=</span> <span class="cm-variable-2">frameFunc</span>(<span class="cm-variable-2">timeStep</span>) <span class="cm-operator">===</span> <span class="cm-atom">false</span>;
    }
    <span class="cm-variable-2">lastTime</span> <span class="cm-operator">=</span> <span class="cm-variable-2">time</span>;
    <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable-2">stop</span>)
      <span class="cm-variable">requestAnimationFrame</span>(<span class="cm-variable-2">frame</span>);
  }
  <span class="cm-variable">requestAnimationFrame</span>(<span class="cm-variable-2">frame</span>);
}</pre>
<p><a class="p_ident" id="p_qaBaJbkLcb" href="./15_game.html#p_qaBaJbkLcb"></a>Аз поставих максимална стъпка на кадъра от 100 милисекунди(една десета от секундата). Когато раздела на браузъра или прозореца с нашата страница е скрит, извикванията на <code>requestAnimationFrame</code> ще бъдат спрени, докато раздела или прозореца се появят отново. В този случай разликата между <code>lastTime</code> и <code>time</code>ще бъде цялото време, през което страницата е била скрита. Напредъка на играта с много единични стъпки ще изглежда глупаво и много натоварващо (не забравяйте, времевите отрязъци  в метода на <a href="./15_game.html#actors"><code>анимацията</code></a>).</p>
<p><a class="p_ident" id="p_jKakPLUmwL" href="./15_game.html#p_jKakPLUmwL"></a>Функцията също превръща стъпките на времето в секунди, които са по-лесни, като величина, отколкото милисекунди.</p>
<p><a class="p_ident" id="p_e8mbmQ7w8j" href="./15_game.html#p_e8mbmQ7w8j"></a>Функцията <code>runLevel</code> взема от <code>Level</code> обекта, конструктора за дисплей и евентуално функция. Тя показва нивото(в <code>document.body</code>) и позволява на потребителя да играе в него. Когато нивото е завършено (с победа или загуба), <code>runLevel</code> изчиства дисплея, спира анимацията и ако <code>andThen</code> е дадената функция, извиква тази функция със статус на ниво.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_x5O5o5qg7u" href="./15_game.html#c_x5O5o5qg7u"></a><span class="cm-keyword">var</span> <span class="cm-variable">arrows</span> <span class="cm-operator">=</span> <span class="cm-variable">trackKeys</span>(<span class="cm-variable">arrowCodes</span>);

<span class="cm-keyword">function</span> <span class="cm-variable">runLevel</span>(<span class="cm-def">level</span>, <span class="cm-def">Display</span>, <span class="cm-def">andThen</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">display</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable-2">Display</span>(<span class="cm-variable">document</span>.<span class="cm-property">body</span>, <span class="cm-variable-2">level</span>);
  <span class="cm-variable">runAnimation</span>(<span class="cm-keyword">function</span>(<span class="cm-def">step</span>) {
    <span class="cm-variable-2">level</span>.<span class="cm-property">animate</span>(<span class="cm-variable-2">step</span>, <span class="cm-variable">arrows</span>);
    <span class="cm-variable-2">display</span>.<span class="cm-property">drawFrame</span>(<span class="cm-variable-2">step</span>);
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">level</span>.<span class="cm-property">isFinished</span>()) {
      <span class="cm-variable-2">display</span>.<span class="cm-property">clear</span>();
      <span class="cm-keyword">if</span> (<span class="cm-variable-2">andThen</span>)
        <span class="cm-variable-2">andThen</span>(<span class="cm-variable-2">level</span>.<span class="cm-property">status</span>);
      <span class="cm-keyword">return</span> <span class="cm-atom">false</span>;
    }
  });
}</pre>
<p><a class="p_ident" id="p_eyKzVe0sIB" href="./15_game.html#p_eyKzVe0sIB"></a>Една игра е поредица от нива. Всеки път, когато играча умре сегашното ниво се рестартира. Когато нивото е завършено с победа, преминава към следващото ниво. Това може да се изрази със следната функция, която взема масив от планове на нива (масив от <em>strings</em>) и дисплей конструктор.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_ok+t8qqv5E" href="./15_game.html#c_ok+t8qqv5E"></a><span class="cm-keyword">function</span> <span class="cm-variable">runGame</span>(<span class="cm-def">plans</span>, <span class="cm-def">Display</span>) {
  <span class="cm-keyword">function</span> <span class="cm-def">startLevel</span>(<span class="cm-def">n</span>) {
    <span class="cm-variable">runLevel</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Level</span>(<span class="cm-variable-2">plans</span>[<span class="cm-variable-2">n</span>]), <span class="cm-variable-2">Display</span>, <span class="cm-keyword">function</span>(<span class="cm-def">status</span>) {
      <span class="cm-keyword">if</span> (<span class="cm-variable-2">status</span> <span class="cm-operator">==</span> <span class="cm-string">"lost"</span>)
        <span class="cm-variable-2">startLevel</span>(<span class="cm-variable-2">n</span>);
      <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">n</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">plans</span>.<span class="cm-property">length</span> <span class="cm-operator">-</span> <span class="cm-number">1</span>)
        <span class="cm-variable-2">startLevel</span>(<span class="cm-variable-2">n</span> <span class="cm-operator">+</span> <span class="cm-number">1</span>);
      <span class="cm-keyword">else</span>
        <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"You win!"</span>);
    });
  }
  <span class="cm-variable-2">startLevel</span>(<span class="cm-number">0</span>);
}</pre>
<p><a class="p_ident" id="p_Btjn/eg/VT" href="./15_game.html#p_Btjn/eg/VT"></a>Тази функция показва особен стил на програмиране. И двете <code>runAnimation</code> и <code>runLevel</code> са по-високо ниво функции, но не са в стила, който разгледахме в <a href="./05_higher_order.html#higher_order">Глава 5</a>. Функцията - аргумент се използва за да организира нещата да се случат някъде в бъдещето и нито една от функциите не връща нещо полезно. Тяхната задача е, в известен смисъл, да планират действията. Опаковането на тези действия във функции ни дава начин да ги съхраним, като стойност, така че да можем да ги извикаме в най-подходящия момент.</p>
<p><a class="p_ident" id="p_HC69jX9E3n" href="./15_game.html#p_HC69jX9E3n"></a>Този стил на програмиране обикновено се нарича асинхронно програмиране. Обработката на  събития също е модел на този стил и ще видим много повече от това, когато работим със задачи, които могат да вземат произволно количество време, както например мрежови  заявки в <a href="./17_http.html#http">Глава 17</a> и вход и изход-генерално в <a href="./20_node.html#node">Глава 20</a>.</p>
<p><a class="p_ident" id="p_/6dLhjN2fB" href="./15_game.html#p_/6dLhjN2fB"></a>Има набор от планове за нива на разположение в <code>GAME_LEVELS</code> променливата. Тази страница подържа  <code>runGame</code>, действителния старт на играта.</p>
<pre data-language="text/html" class="snippet cm-s-default" data-sandbox="null" data-focus="true"><a class="c_ident" id="c_gt8VjDAEg8" href="./15_game.html#c_gt8VjDAEg8"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">link</span> <span class="cm-attribute">rel</span>=<span class="cm-string">"stylesheet"</span> <span class="cm-attribute">href</span>=<span class="cm-string">"css/game.css"</span><span class="cm-tag cm-bracket">&gt;</span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">body</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
    <span class="cm-variable">runGame</span>(<span class="cm-variable">GAME_LEVELS</span>, <span class="cm-variable">DOMDisplay</span>);
  <span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">body</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_MkrZ67rFcA" href="./15_game.html#p_MkrZ67rFcA"></a>Вижте дали можете да победите. Беше ми доста забавно да я изградя.</p>
<h2><a class="h_ident" id="h_TcUD2vzyMe" href="./15_game.html#h_TcUD2vzyMe"></a>Упражнения</h2>
<h3><a class="h_ident" id="h_tFsh86eaJC" href="./15_game.html#h_tFsh86eaJC"></a>Game over</h3>
<p><a class="p_ident" id="p_JkKGPYeFzA" href="./15_game.html#p_JkKGPYeFzA"></a>Традиционна платформа за игри е играча да започне с ограничен брой животи и те се намалят всеки път, когато той умира. Когато му свършат животите играта се рестартира от начало.</p>
<p><a class="p_ident" id="p_oYENd6hUVn" href="./15_game.html#p_oYENd6hUVn"></a>Регулирайте <code>runGame</code> да приложи животите, като стартирате играча с три живота.</p>
<pre data-language="text/html" class="snippet cm-s-default" data-focus="true"><a class="c_ident" id="c_rB2X2oyycK" href="./15_game.html#c_rB2X2oyycK"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">link</span> <span class="cm-attribute">rel</span>=<span class="cm-string">"stylesheet"</span> <span class="cm-attribute">href</span>=<span class="cm-string">"css/game.css"</span><span class="cm-tag cm-bracket">&gt;</span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">body</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-comment">// The old runGame function. Modify it...</span>
  <span class="cm-keyword">function</span> <span class="cm-variable">runGame</span>(<span class="cm-def">plans</span>, <span class="cm-def">Display</span>) {
    <span class="cm-keyword">function</span> <span class="cm-def">startLevel</span>(<span class="cm-def">n</span>) {
      <span class="cm-variable">runLevel</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Level</span>(<span class="cm-variable-2">plans</span>[<span class="cm-variable-2">n</span>]), <span class="cm-variable-2">Display</span>, <span class="cm-keyword">function</span>(<span class="cm-def">status</span>) {
        <span class="cm-keyword">if</span> (<span class="cm-variable-2">status</span> <span class="cm-operator">==</span> <span class="cm-string">"lost"</span>)
          <span class="cm-variable-2">startLevel</span>(<span class="cm-variable-2">n</span>);
        <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">n</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">plans</span>.<span class="cm-property">length</span> <span class="cm-operator">-</span> <span class="cm-number">1</span>)
          <span class="cm-variable-2">startLevel</span>(<span class="cm-variable-2">n</span> <span class="cm-operator">+</span> <span class="cm-number">1</span>);
        <span class="cm-keyword">else</span>
          <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"You win!"</span>);
      });
    }
    <span class="cm-variable-2">startLevel</span>(<span class="cm-number">0</span>);
  }
  <span class="cm-variable">runGame</span>(<span class="cm-variable">GAME_LEVELS</span>, <span class="cm-variable">DOMDisplay</span>);
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">body</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<div class="solution"><div class="solution-text">
<p><a class="p_ident" id="p_n7botbYRDO" href="./15_game.html#p_n7botbYRDO"></a>Най-очевидното решение би било да се направи <code>lives</code> променлива, която живее в <code>runGame</code> и по този начин е видима за <code>startLevel</code> закриването.</p>
<p><a class="p_ident" id="p_PlMiAVziM0" href="./15_game.html#p_PlMiAVziM0"></a>Друг подход, който се вписва добре в духа на останалата част от функцията, ще бъде да се добави втори параметър, така че <code>startLevel</code>, който дава брой животи. Когато цялото състояние на системата се съхранява в аргументите на функцията, извикването на тази функция осигурява елегантен начин за преход към ново състояние.</p>
<p><a class="p_ident" id="p_2xJcBQOfjW" href="./15_game.html#p_2xJcBQOfjW"></a>Във всеки случай, когато нивото е загубено трябва да има два възможни изхода. Ако това е последният живот, трябва да се върнем към ниво нула с първоначален размер на живота. Ако не е, повтаряме сегашното ниво с един живот по-малко.</p>
</div></div>
<h3><a class="h_ident" id="h_cNfzuXtVqI" href="./15_game.html#h_cNfzuXtVqI"></a>Пауза на играта</h3>
<p><a class="p_ident" id="p_GkkSB/bDtt" href="./15_game.html#p_GkkSB/bDtt"></a>Направете възможно да има пауза (спиране) и отменяне на паузата на играта, чрез натискане на клавиш Esc.</p>
<p><a class="p_ident" id="p_FpramcVlTZ" href="./15_game.html#p_FpramcVlTZ"></a>Това може да стане чрез промяна на функцията <code>runLevel</code> да използва манипулатор за друго клавишно събитие и да прекъсва и възобновява анимацията, когато клавишът Esc е натиснат.</p>
<p><a class="p_ident" id="p_vlGSY83Wnl" href="./15_game.html#p_vlGSY83Wnl"></a>Интерфейса <code>runAnimation</code> не изглежда подходящ на пръв поглед за тази задача, но може да стане ако се промени начина му на извикване от <code>runLevel</code>.</p>
<p><a class="p_ident" id="p_0zF8rh7TLp" href="./15_game.html#p_0zF8rh7TLp"></a>Когато имате работещ начин, има нещо друго, което може да се опита. Начинът, по който са регистрирани манипулаторите на клавишните събития е малко проблемен. Обекта <code>arrows</code> в момента е глобална променлива и неговите манипулатори на събития се съхраняват дори, когато играта не се изпълнява. Може да се каже, че има изтичане от нашата система. Разширете <code>trackKeys</code> за да осигури начин да отпише своите манипулатори и след това променете <code>runLevel</code> да регистрира своите манипулатори, когато се стартира и да ги отписва отново, когато е завършена.</p>
<pre data-language="text/html" class="snippet cm-s-default" data-focus="true"><a class="c_ident" id="c_Yc5WbvNGlk" href="./15_game.html#c_Yc5WbvNGlk"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">link</span> <span class="cm-attribute">rel</span>=<span class="cm-string">"stylesheet"</span> <span class="cm-attribute">href</span>=<span class="cm-string">"css/game.css"</span><span class="cm-tag cm-bracket">&gt;</span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">body</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-comment">// The old runLevel function. Modify this...</span>
  <span class="cm-keyword">function</span> <span class="cm-variable">runLevel</span>(<span class="cm-def">level</span>, <span class="cm-def">Display</span>, <span class="cm-def">andThen</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">display</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable-2">Display</span>(<span class="cm-variable">document</span>.<span class="cm-property">body</span>, <span class="cm-variable-2">level</span>);
    <span class="cm-variable">runAnimation</span>(<span class="cm-keyword">function</span>(<span class="cm-def">step</span>) {
      <span class="cm-variable-2">level</span>.<span class="cm-property">animate</span>(<span class="cm-variable-2">step</span>, <span class="cm-variable">arrows</span>);
      <span class="cm-variable-2">display</span>.<span class="cm-property">drawFrame</span>(<span class="cm-variable-2">step</span>);
      <span class="cm-keyword">if</span> (<span class="cm-variable-2">level</span>.<span class="cm-property">isFinished</span>()) {
        <span class="cm-variable-2">display</span>.<span class="cm-property">clear</span>();
        <span class="cm-keyword">if</span> (<span class="cm-variable-2">andThen</span>)
          <span class="cm-variable-2">andThen</span>(<span class="cm-variable-2">level</span>.<span class="cm-property">status</span>);
        <span class="cm-keyword">return</span> <span class="cm-atom">false</span>;
      }
    });
  }
  <span class="cm-variable">runGame</span>(<span class="cm-variable">GAME_LEVELS</span>, <span class="cm-variable">DOMDisplay</span>);
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">body</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<div class="solution"><div class="solution-text">
<p><a class="p_ident" id="p_83gTFxcRTB" href="./15_game.html#p_83gTFxcRTB"></a>Една анимация може да се прекъсне чрез връщане на <code>false</code> от функция дадена към <code>runAnimation</code>. И може да бъде продължена, като се извика <code>runAnimation</code> отново.</p>
<p><a class="p_ident" id="p_m7CtgKwkDs" href="./15_game.html#p_m7CtgKwkDs"></a>За да комуникират, че анимацията трябва да се прекъсне към функцията подадена към <code>runAnimation</code>, така че тя да може да върне <code>false</code>, можете да използвате променлива, като манипулатор на събитие и тази функция, която има достъп.</p>
<p><a class="p_ident" id="p_FDlbFLVUQ7" href="./15_game.html#p_FDlbFLVUQ7"></a>При търсенето на начин за отписване на манипулатори регистрирани от <code>trackKeys</code>, не забравяйте, че точно същата стойност на функция, която се подава на <code>addEventListener</code> трябва се подаде на <code>removeEventListener</code> за да премахне успешно манипулатор. По този начин <code>handler</code> стойността на функцията, създадена в <code>trackKeys</code> трябва да бъде на разположение на кода, който отписва манипулаторите.</p>
<p><a class="p_ident" id="p_mn/dvab7i4" href="./15_game.html#p_mn/dvab7i4"></a>Можете да добавите свойство към обекта, върнат от <code>trackKeys</code> съдържащ тази стойност на функцията или метод, който обработва отписването директно.</p>
</div></div>
<nav>
  <a href="./14_event.html" title="previous chapter">◀</a>
  <a href="./index.html" title="cover">◆</a>
  <a href="./16_canvas.html" title="next chapter">▶</a>
</nav>
</article>
</body></html>
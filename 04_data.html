<!DOCTYPE html>
<!-- saved from url=(0042)./04_data.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <title>Data Structures: Objects and Arrays :: Eloquent JavaScript</title>
  <link rel="stylesheet" href="./media/codemirror.css">
  <script src="./media/acorn_codemirror.js"></script>
  <link rel="stylesheet" href="./media/ejs.css">
  <script src="./media/sandbox.js"></script>
  <script src="./media/ejs.js"></script>
  <script>var chapNum = 4;var sandboxLoadFiles = ["code/jacques_journal.js", "code/chapter/04_data.js"];</script>
</head>

<body><article>
<nav>
  <a href="./03_functions.html" title="previous chapter">◀</a>
  <a href="./index.html" title="cover">◆</a>
  <a href="./05_higher_order.html" title="next chapter">▶</a>
</nav>

<h1><div class="chap_num">Глава 4</div>Структури от данни: Обекти и масиви</h1>
<blockquote>
<p><a class="p_ident" id="p_3DGxnMhaad" href="./04_data.html#p_3DGxnMhaad"></a>На два пъти съм бил питан, „Кажете моля г-н Бабидж, ако поставите грешните данни в машината, ще излязат ли правилните отговори? […]“ Аз не съм в състояние правилно да схвана вида на обърканите идеи, които биха могли да провокират такъв въпрос”</p>
 <footer>Charles Babbage, <cite>Пасажи от живота на един философ(1864)</cite></footer>
</blockquote>
<p><a class="p_ident" id="p_j/UjCN3npi" href="./04_data.html#p_j/UjCN3npi"></a><em>Numbers, Booleans</em> и <em>strings</em> са тухлите, от които структурите от данни са изградени. Но не можем да построим цяла къща с една- единствена тухла. <em>Objects</em> ни позволяват да групираме стойности - включително и други обекти заедно и по този начин да изградим по-сложни структури.</p>
<p><a class="p_ident" id="p_TT9r8Cr1W0" href="./04_data.html#p_TT9r8Cr1W0"></a>Програмите, които правихме досега бяха сериозно затруднени от факта, че действат само върху прости типове данни. Тази глава ще добави основно разбиране на структури от данни към нашия инструментариум. До края на тази глава вие ще знаете достатъчно, за да започнете да пишете някои полезни програми.</p>
<p><a class="p_ident" id="p_vL8agXHSiL" href="./04_data.html#p_vL8agXHSiL"></a>Ще работим преминавайки през повече или по-малко реалистично програмиране, въвеждане на понятия, които се отнасят към разглежданите проблеми. Например кодът, често ще се основава на функции и променливи, които бяха въведени по-рано в книгата.</p>
<h2><a class="h_ident" id="h_NvjtahQLlw" href="./04_data.html#h_NvjtahQLlw"></a>The weresquirrel</h2>
<p><a class="p_ident" id="p_2uQlDOT3CH" href="./04_data.html#p_2uQlDOT3CH"></a>Винаги, сега и тогава, обикновено между осем и десет вечерта, Жак се озоваваше трансформиран в малък космат гризач с пухкава опашка.</p>
<p><a class="p_ident" id="p_EIDMzKWaqr" href="./04_data.html#p_EIDMzKWaqr"></a>От една страна, Жак беше доста доволен, че няма класическа ликантропия. Превъплащението в катерица имаше тенденцията да предизвиква по-малко проблеми, отколкото да се превърне във вълк, например. Вместо да се налага да се притеснява за случайно изяждане на съседа(това би било неловко), той се притесняваше да не бъде изяден от котката на съседа. След два случая, когато той се събуди върху несигурно тънък клон в короната на един дъб, гол и дезориентриран, той предприе да заключва вратите и прозорците на стаята си през нощта и пускаше няколко ореха на пода, за да държи себе си зает.</p>
<div class="image">
  <img src="./media/weresquirrel.png" alt="The weresquirrel">
</div>
<p><a class="p_ident" id="p_mMWZqiA+i1" href="./04_data.html#p_mMWZqiA+i1"></a>Това трябваше да се погрижи за проблемите с котката и дъба. Но Жак все още страдаше от състоянието си. Нередовните случаи на трансформация го караха да се съмнява, че тя може да се задейства от нещо. За известно време той вярваше, че това се случва само в дните, когато е докосвал дървета. Така че, той спря изцяло да докосва дървета и дори избягваше случайна близост със тях. Но проблемът продължаваше да съществува.</p>
<p><a class="p_ident" id="p_I4RF6opRCC" href="./04_data.html#p_I4RF6opRCC"></a>Преминавайки към по-научен подход, Жак възнамеряваше да започне воденето на дневник за всичко, което той е правил този ден и дали това променя формата. С тази информация, се надяваше да стесни условията, които задействат трансформациите.</p>
<p><a class="p_ident" id="p_WERwFzJu93" href="./04_data.html#p_WERwFzJu93"></a>Първото нещо, което направи - проектира структура от данни, за да съхранява тази информация.</p>
<h2><a class="h_ident" id="h_HjL/otjEJn" href="./04_data.html#h_HjL/otjEJn"></a>Набор от данни</h2>
<p><a class="p_ident" id="p_HFLfyQFSDp" href="./04_data.html#p_HFLfyQFSDp"></a>За да можете да работите с парче цифрови данни, първо трябва да намерите начин да ги представите в паметта на вашата машина. Кажете един прост пример, с който искате да представите колекция от цифри: 2, 3, 5, 7 и 11.</p>
<p><a class="p_ident" id="p_cnzv4pg+Wz" href="./04_data.html#p_cnzv4pg+Wz"></a>Бихме могли да ги представим творчески със <em>strings</em>, в края на краищата, <em>strings</em> могат да бъдат с всякаква дължина, така че можем да поставим много данни в тях и да ги представим по следния начин <code>"2 3 5 7 11"</code>. Но това е неудобно. Ще трябва някак да извлечем цифрите и да ги конвертираме обратно в номера за да имаме достъп до тях.</p>
<p><a class="p_ident" id="p_/aFILq7bDn" href="./04_data.html#p_/aFILq7bDn"></a>За щастие, JavaScript  осигурява начин специално за съхранение на поредици от стойности. Той се нарича масив (array) и е написан, като списък от стойности между квадратни скоби, разделени със запетаи.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_WrRipN2I5z" href="./04_data.html#c_WrRipN2I5z"></a><span class="cm-keyword">var</span> <span class="cm-variable">listOfNumbers</span> <span class="cm-operator">=</span> [<span class="cm-number">2</span>, <span class="cm-number">3</span>, <span class="cm-number">5</span>, <span class="cm-number">7</span>, <span class="cm-number">11</span>];
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">listOfNumbers</span>[<span class="cm-number">1</span>]);
<span class="cm-comment">// → 3</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">listOfNumbers</span>[<span class="cm-number">1</span> <span class="cm-operator">-</span> <span class="cm-number">1</span>]);
<span class="cm-comment">// → 2</span></pre>
<p><a class="p_ident" id="p_xu5bhsrvS2" href="./04_data.html#p_xu5bhsrvS2"></a>Означението за получаване на елементите вътре в масива също използва квадратни скоби. Чифт квадратни скоби веднага след израз с друг израз вътре в тях, вижда елементите в израза от лявата страна, които съответстват на индекса даден от израза в скобите.</p>
<p id="array_indexing"><a class="p_ident" id="p_i4f1iEZJFW" href="./04_data.html#p_i4f1iEZJFW"></a>Първият индекс в масива е нула, не едно. Така че, първият елемент може да се прочете с <code>listOfNumbers[0]</code>. Ако нямате познания в програмирането, тази конвенция може да отнеме известно време за привикване. Нулевата база за преброяване има дълга традиция в областта на технологиите и стига да бъде следвана последователно (както в JavaScript ) то тя работи добре.</p>
<h2 id="properties"><a class="h_ident" id="h_vGyI2y8HA6" href="./04_data.html#h_vGyI2y8HA6"></a>Свойства</h2>
<p><a class="p_ident" id="p_N/KiJ+p6sy" href="./04_data.html#p_N/KiJ+p6sy"></a>Видяхме няколко подозрително изглеждащи израза, като <code>myString.length</code> (за да получим дължината на <em>string</em>) и <code>Math.max</code> функцията в последните примери. Това са изрази, които имат достъп до свойствата на някаква стойност. В първия случай имаме достъп до свойството <code>length</code> на стойността в <code>myString</code>. Във втория, достъп до свойството  <code>max</code> в <code>Math</code> обекта (който е колекция от математически свързани стойности и функции).</p>
<p><a class="p_ident" id="p_dTOk+Nu/lR" href="./04_data.html#p_dTOk+Nu/lR"></a>Почти всички стойности на JavaScript имат свойства. Изключение правят <code>null</code> и <code>undefined</code>. Ако се опитате да получите достъп до свойствата на една от тези <em>nonvalues</em>, ще получите съобщение за грешка.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_ZEvFsOQLc8" href="./04_data.html#c_ZEvFsOQLc8"></a><span class="cm-atom">null</span>.<span class="cm-property">length</span>;
<span class="cm-comment">// → TypeError: Cannot read property 'length' of null</span></pre>
<p><a class="p_ident" id="p_etK6gD7WXZ" href="./04_data.html#p_etK6gD7WXZ"></a>Двата най-често срещани начина за достъп до свойства в JavaScript са точка или квадратни скоби. И двете <code>value.x</code> и <code>value[x]</code> са достъп до свойството <code>value</code> - но не са непременно едно и също свойство. Разликата е в това, как се тълкува <code>x</code>. При израза с точка, частта след точката трябва да е валидно име на променлива и получавате директно името на свойството. При ползване на квадратни скоби, изразът между скобите се оценява, за да получите името на свойството. Какво имам в предвид, <code>value.x</code> извлича свойството <code>value</code> с име  “x”, а <code>value[x]</code> се опитва да направи оценка на израза <code>x</code> и използва резултата, като име на свойство.</p>
<p><a class="p_ident" id="p_tcrruPP6JD" href="./04_data.html#p_tcrruPP6JD"></a>Така че ако знаете, че свойството, което ви интересува се нарича “length” вие казвате <code>value.length</code>. Ако искате да извлечете свойство с името на стойността съдържана в променливата <code>i</code>, вие казвате <code>value[i]</code>. И тъй като, името на свойството може да бъде всеки <em>string</em>, ако искате да получите достъп до името на свойството “2” или “John Doe”, трябва да използвате квадратни скоби: <code>value[2]</code> или <code>value["John Doe"]</code>. Така се прави, въпреки, че знаете името на свойството предварително, защото нито “2”, нито “John Doe” са валидно име на променлива и за това не могат да бъдат достъпни чрез точкова нотация.</p>
<p><a class="p_ident" id="p_d0vwHo1UJ1" href="./04_data.html#p_d0vwHo1UJ1"></a>Елементите в масив се съхраняват в свойства. Тъй като, имената на тези свойства са числа, а ние често трябва да получим техните имена от една променлива, трябва да използваме синтаксиса на скобите, за да имаме достъп до тях. Свойството <code>length</code> на масив ни казва колко елемента съдържа. Това име на свойство е валидно име на променлива, а ние знаем това име от по-рано, така че за да се намери дължината на масив, обикновено пишем <code>array.length</code> защото това е по-лесно да се напише, отколкото <code>array["length"]</code>.</p>
<h2 id="methods"><a class="h_ident" id="h_fkrGgDyRWc" href="./04_data.html#h_fkrGgDyRWc"></a>Методи</h2>
<p><a class="p_ident" id="p_1Q3NM3X6G3" href="./04_data.html#p_1Q3NM3X6G3"></a>И двата - <em>strings</em> и масиви обекти, съдържат в допълнение към свойството <code>length</code>, редица свойства, които се отнасят за функционирането на стойностите.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_Crc8UwFnzX" href="./04_data.html#c_Crc8UwFnzX"></a><span class="cm-keyword">var</span> <span class="cm-variable">doh</span> <span class="cm-operator">=</span> <span class="cm-string">"Doh"</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-keyword">typeof</span> <span class="cm-variable">doh</span>.<span class="cm-property">toUpperCase</span>);
<span class="cm-comment">// → function</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">doh</span>.<span class="cm-property">toUpperCase</span>());
<span class="cm-comment">// → DOH</span></pre>
<p><a class="p_ident" id="p_EmYOwg/BO9" href="./04_data.html#p_EmYOwg/BO9"></a>Всеки <em>string</em> има <code>toUpperCase</code> свойство. Когато се извика, то ще върне копие на <em>string</em>-а, в което всички букви ще са превърнати в главни букви. Също така има и <code>toLowerCase</code>. Може да се досетите,  какво значи това.</p>
<p><a class="p_ident" id="p_lNzNM3PoU4" href="./04_data.html#p_lNzNM3PoU4"></a>Интересно е, че въпреки извикването на <code>toUpperCase</code>, то не минава през всички аргументи, функцията по някакъв начин има достъп до стойността на <code>string ”Doh”</code>, чието свойство извикахме. Как става това е описано в <a href="./06_object.html#obj_methods">Глава 6</a>.</p>
<p><a class="p_ident" id="p_gvO150ZgOs" href="./04_data.html#p_gvO150ZgOs"></a>Свойства, които съдържат функции обикновено се наричат методи на стойността, към която принадлежат. Както “<code>toUpperCase</code> е метод на <em>string</em>”.</p>
<p id="array_methods"><a class="p_ident" id="p_FALcpD+CSn" href="./04_data.html#p_FALcpD+CSn"></a>Този пример показва някои методи за масиви, които имат:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_Ymu7GdxtdT" href="./04_data.html#c_Ymu7GdxtdT"></a><span class="cm-keyword">var</span> <span class="cm-variable">mack</span> <span class="cm-operator">=</span> [];
<span class="cm-variable">mack</span>.<span class="cm-property">push</span>(<span class="cm-string">"Mack"</span>);
<span class="cm-variable">mack</span>.<span class="cm-property">push</span>(<span class="cm-string">"the"</span>, <span class="cm-string">"Knife"</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">mack</span>);
<span class="cm-comment">// → ["Mack", "the", "Knife"]</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">mack</span>.<span class="cm-property">join</span>(<span class="cm-string">" "</span>));
<span class="cm-comment">// → Mack the Knife</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">mack</span>.<span class="cm-property">pop</span>());
<span class="cm-comment">// → Knife</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">mack</span>);
<span class="cm-comment">// → ["Mack", "the"]</span></pre>
<p><a class="p_ident" id="p_du5uQ2te7B" href="./04_data.html#p_du5uQ2te7B"></a>Метода <code>push</code>, може да се използва за добавяне на стойност в края на масива. Метода <code>pop</code> прави точно обратното: премахва стойност от края на масива и я връща. Масив от <em>strings</em>, може да бъде обединен в един string с метода <code>join</code>. Аргумента даден на <code>join</code> определя текста за залепяне, който е между елементите на масива.</p>
<h2><a class="h_ident" id="h_cqg63Sxe3o" href="./04_data.html#h_cqg63Sxe3o"></a>Обекти</h2>
<p><a class="p_ident" id="p_D8cm1kz0P8" href="./04_data.html#p_D8cm1kz0P8"></a>Обратно към <em>weresquirrel</em>. Набор от ежедневните записки може да бъде представен, като масив. Но записите не се състоят от само номер или <em>string</em> - всеки запис трябва да съхранява списък от дейности и булева стойност, която показва дали Жак се превърнал в катерица. В идеалния случай, бихме могли да групираме тези стойности заедно в една стойност и след това да пуснем тези групирани стойности в масив от записи.</p>
<p><a class="p_ident" id="p_aZEa6qyMum" href="./04_data.html#p_aZEa6qyMum"></a>Стойности на типа обект са произволни колекции от свойства и ние можем да добавяме или премахваме тези свойства, както преценим. Един от начините  за създаване на обект е с помощта на фигурни скоби.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_pSAc4ib983" href="./04_data.html#c_pSAc4ib983"></a><span class="cm-keyword">var</span> <span class="cm-variable">day1</span> <span class="cm-operator">=</span> {
  <span class="cm-property">squirrel</span>: <span class="cm-atom">false</span>,
  <span class="cm-property">events</span>: [<span class="cm-string">"work"</span>, <span class="cm-string">"touched tree"</span>, <span class="cm-string">"pizza"</span>, <span class="cm-string">"running"</span>,
           <span class="cm-string">"television"</span>]
};
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">day1</span>.<span class="cm-property">squirrel</span>);
<span class="cm-comment">// → false</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">day1</span>.<span class="cm-property">wolf</span>);
<span class="cm-comment">// → undefined</span>
<span class="cm-variable">day1</span>.<span class="cm-property">wolf</span> <span class="cm-operator">=</span> <span class="cm-atom">false</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">day1</span>.<span class="cm-property">wolf</span>);
<span class="cm-comment">// → false</span></pre>
<p><a class="p_ident" id="p_hxTCt8woA9" href="./04_data.html#p_hxTCt8woA9"></a>Вътре във фигурните скоби, може да дадем списък от свойства, разделени със запетаи. Всяко свойство е написано като име, следвано от двуточие, следвано от израз, който осигурява стойност на свойството. Интервали и нови редове не са от значение. Когато даден обект обхваща, няколко линии, както в предишния пример, новите редове подобряват четимоста. Информациите чиито имена не са валидни имена на променливи или валидни номера, трябва да бъдат цитирани.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_7B49gkBNPX" href="./04_data.html#c_7B49gkBNPX"></a><span class="cm-keyword">var</span> <span class="cm-variable">descriptions</span> <span class="cm-operator">=</span> {
  <span class="cm-property">work</span>: <span class="cm-string">"Went to work"</span>,
  <span class="cm-string cm-property">"touched tree"</span>: <span class="cm-string">"Touched a tree"</span>
};</pre>
<p><a class="p_ident" id="p_muKvKdGc+G" href="./04_data.html#p_muKvKdGc+G"></a>Това означава, че фигурните скоби имат две значения в JavaScript. В началото на изявлението, те започват блок от твърдения. В друга позиция, те описват обект. За щастие, почти никога не е полезно да се започне изявление, като обект с къдрави скоби и в типични програми няма двусмислие между тези две цели.</p>
<p><a class="p_ident" id="p_04jR2jxhZ9" href="./04_data.html#p_04jR2jxhZ9"></a>Четене на свойство, което не съществува генерира стойност <code>undefined</code>, както се случи с опита да прочетем <code>wolf</code> в предишния пример.</p>
<p><a class="p_ident" id="p_oxubJ4TSX5" href="./04_data.html#p_oxubJ4TSX5"></a>Възможно е да се присвои стойност на свойство с оператора <code>=</code>. Това ще замени стойността на свойството, ако тя вече съществува или ще създаде ново свойство в обекта, ако той не го е направил.</p>
<p><a class="p_ident" id="p_FolCMJfte3" href="./04_data.html#p_FolCMJfte3"></a>Да се върнем за кратко към нашия пример с пипалата от модела за обвързване на променливите, модела за обвързване на свойствата е подобен. Те хващат стойности, но може да има други променливи и свойства, които държат същите стойности. Може да мислите за обекти, като октоподи с произволен брой пипала, всяко от които има име изписано върху него.</p>
<div class="image">
  <img src="./media/octopus-object.jpg" alt="Artist&#39;s representation of an object">
</div>
<p><a class="p_ident" id="p_0r+HcrZzZJ" href="./04_data.html#p_0r+HcrZzZJ"></a>Оператора <code>delete</code> отрязва пипалото на такъв октопод. Това е унарен оператор, който когато се прилага, ще премахне името на свойството от обекта. Това не е често срещано, но е възможно да се направи.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_vYNsoXd+S5" href="./04_data.html#c_vYNsoXd+S5"></a><span class="cm-keyword">var</span> <span class="cm-variable">anObject</span> <span class="cm-operator">=</span> {<span class="cm-property">left</span>: <span class="cm-number">1</span>, <span class="cm-property">right</span>: <span class="cm-number">2</span>};
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">anObject</span>.<span class="cm-property">left</span>);
<span class="cm-comment">// → 1</span>
<span class="cm-keyword">delete</span> <span class="cm-variable">anObject</span>.<span class="cm-property">left</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">anObject</span>.<span class="cm-property">left</span>);
<span class="cm-comment">// → undefined</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"left"</span> <span class="cm-keyword">in</span> <span class="cm-variable">anObject</span>);
<span class="cm-comment">// → false</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"right"</span> <span class="cm-keyword">in</span> <span class="cm-variable">anObject</span>);
<span class="cm-comment">// → true</span></pre>
<p><a class="p_ident" id="p_CuN7Z7VCcF" href="./04_data.html#p_CuN7Z7VCcF"></a>Бинарния оператор <code>in</code>, когато се прилага в <em>string</em> и обект, връща булева стойност, която показва дали този обект има това свойство. Разликата между настройване на свойството към <code>undefined</code> и действителното му изтриване, е че в първия случай, обекта все още има свойството (то просто не разполага с определена стойност), докато във втория случай свойството вече не е налично и <code>in</code> ще върне <code>false</code>.</p>
<p><a class="p_ident" id="p_Rl8msr9DUz" href="./04_data.html#p_Rl8msr9DUz"></a>Масивите, а това са само един вид обект, са специализирани за съхранение на последователности от неща. Ако оцените <code>typeof [1, 2]</code>, това ще произведе <code>"object"</code>. Можете да си ги представите, като дълги, плоски октоподи с всичките си пипала по ред, етикетирани с номера.</p>
<div class="image">
  <img src="./media/octopus-array.jpg" alt="Artist&#39;s representation of an array">
</div>
<p><a class="p_ident" id="p_/qn/Ibmvdm" href="./04_data.html#p_/qn/Ibmvdm"></a>Така можем да представим дневника на Жак, като масив от обекти.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_hO78QsnSY4" href="./04_data.html#c_hO78QsnSY4"></a><span class="cm-keyword">var</span> <span class="cm-variable">journal</span> <span class="cm-operator">=</span> [
  {<span class="cm-property">events</span>: [<span class="cm-string">"work"</span>, <span class="cm-string">"touched tree"</span>, <span class="cm-string">"pizza"</span>,
            <span class="cm-string">"running"</span>, <span class="cm-string">"television"</span>],
   <span class="cm-property">squirrel</span>: <span class="cm-atom">false</span>},
  {<span class="cm-property">events</span>: [<span class="cm-string">"work"</span>, <span class="cm-string">"ice cream"</span>, <span class="cm-string">"cauliflower"</span>,
            <span class="cm-string">"lasagna"</span>, <span class="cm-string">"touched tree"</span>, <span class="cm-string">"brushed teeth"</span>],
   <span class="cm-property">squirrel</span>: <span class="cm-atom">false</span>},
  {<span class="cm-property">events</span>: [<span class="cm-string">"weekend"</span>, <span class="cm-string">"cycling"</span>, <span class="cm-string">"break"</span>,
            <span class="cm-string">"peanuts"</span>, <span class="cm-string">"beer"</span>],
   <span class="cm-property">squirrel</span>: <span class="cm-atom">true</span>},
  <span class="cm-comment">/* and so on... */</span>
];</pre>
<h2><a class="h_ident" id="h_C3n45IkMhg" href="./04_data.html#h_C3n45IkMhg"></a>Изменчивост</h2>
<p><a class="p_ident" id="p_HZ50qDRWmj" href="./04_data.html#p_HZ50qDRWmj"></a>Ще стигнем до реалното програмиране скоро. Но първо има едно последно парче теория за разбиране.</p>
<p><a class="p_ident" id="p_zvnMtK4gE8" href="./04_data.html#p_zvnMtK4gE8"></a>Видяхме, че стойностите на обекта могат да бъдат променяни. Типовете стойности, разгледани в предишните глави, като например номера, <em>string</em> и булев тип, са неизменни - невъзможно е да се промени съществуваща стойност на тези типове. Можете да ги комбинирате и да извличате нови стойности от тях, но когато вземете специфична <em>string</em> стойност, тази стойност винаги ще си остане същата. Текстът в нея не може да се променя. Ако имате референция към <em>string</em>, който съдържа <code>"cat"</code> е невъзможно друг код да го промени в <em>string</em> <code>"rat"</code>, например.</p>
<p><a class="p_ident" id="p_pwnQ1xNUOh" href="./04_data.html#p_pwnQ1xNUOh"></a>В обектите, от друга страна, съдържащата се стойност може да се промени, като се промнят нейните свойства.</p>
<p><a class="p_ident" id="p_fVZ1xXAqW5" href="./04_data.html#p_fVZ1xXAqW5"></a>Когато имаме две числа, 120 и 120, ние можем да ги разглеждаме по техния номер, независимо дали се отнасят до едни и същи физически бит. Но с обектите има разлика между двете препратки към същия обект, като има два различни обекта, които съдържат едни и същи свойства. Да разгледаме следния код:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_WVXvnjG5+i" href="./04_data.html#c_WVXvnjG5+i"></a><span class="cm-keyword">var</span> <span class="cm-variable">object1</span> <span class="cm-operator">=</span> {<span class="cm-property">value</span>: <span class="cm-number">10</span>};
<span class="cm-keyword">var</span> <span class="cm-variable">object2</span> <span class="cm-operator">=</span> <span class="cm-variable">object1</span>;
<span class="cm-keyword">var</span> <span class="cm-variable">object3</span> <span class="cm-operator">=</span> {<span class="cm-property">value</span>: <span class="cm-number">10</span>};

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">object1</span> <span class="cm-operator">==</span> <span class="cm-variable">object2</span>);
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">object1</span> <span class="cm-operator">==</span> <span class="cm-variable">object3</span>);
<span class="cm-comment">// → false</span>

<span class="cm-variable">object1</span>.<span class="cm-property">value</span> <span class="cm-operator">=</span> <span class="cm-number">15</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">object2</span>.<span class="cm-property">value</span>);
<span class="cm-comment">// → 15</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">object3</span>.<span class="cm-property">value</span>);
<span class="cm-comment">// → 10</span></pre>
<p><a class="p_ident" id="p_RhD+qPB3F0" href="./04_data.html#p_RhD+qPB3F0"></a>Променливите <code>object1</code> и
<code>object2</code> държат един и същи обект и когато се промени <code>object1</code> също се променя стойността на <code>object2</code>. Променливата <code>object3</code> сочи към друг обект, който първоначално съдържа същите свойства като <code>object1</code>, но живее отделен живот.</p>
<p><a class="p_ident" id="p_S6PAaKQoFH" href="./04_data.html#p_S6PAaKQoFH"></a>Оператора <code>==</code> в JavaScript се използва, когато се сравняват обекти и ще върне <code>true</code> само ако и двата обекта са точно с една и съща стойност. Сравнявайки различни обекти, ще върне <code>false</code>, дори ако те имат идентично съдържание. Няма оператор за "дълбоко" сравнение, вграден в JavaScript, който разглежда съдържанието на обекта, но е възможно да го напишем сами (което ще бъде едно от <a href="./04_data.html#exercise_deep_compare">упражненията</a> в края на тази глава).</p>
<h2><a class="h_ident" id="h_+q4Ck0/tFV" href="./04_data.html#h_+q4Ck0/tFV"></a>The lycanthrope’s log</h2>
<p><a class="p_ident" id="p_z1vPsL0dwv" href="./04_data.html#p_z1vPsL0dwv"></a>И така Жак, стартира JavaScript интерпретатора си и създаде средата, от която се нуждаеше за да запази своя дневник.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_TfYH6uEY6i" href="./04_data.html#c_TfYH6uEY6i"></a><span class="cm-keyword">var</span> <span class="cm-variable">journal</span> <span class="cm-operator">=</span> [];

<span class="cm-keyword">function</span> <span class="cm-variable">addEntry</span>(<span class="cm-def">events</span>, <span class="cm-def">didITurnIntoASquirrel</span>) {
  <span class="cm-variable">journal</span>.<span class="cm-property">push</span>({
    <span class="cm-property">events</span>: <span class="cm-variable-2">events</span>,
    <span class="cm-property">squirrel</span>: <span class="cm-variable-2">didITurnIntoASquirrel</span>
  });
}</pre>
<p><a class="p_ident" id="p_6o6Q7TaG26" href="./04_data.html#p_6o6Q7TaG26"></a>След това, всяка вечер в десет или понякога на следващата сутрин, след като се спусне от най-горния рафт на своята библиотека, той записваше случилото се през деня.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_FvNHZMxEXr" href="./04_data.html#c_FvNHZMxEXr"></a><span class="cm-variable">addEntry</span>([<span class="cm-string">"work"</span>, <span class="cm-string">"touched tree"</span>, <span class="cm-string">"pizza"</span>, <span class="cm-string">"running"</span>,
          <span class="cm-string">"television"</span>], <span class="cm-atom">false</span>);
<span class="cm-variable">addEntry</span>([<span class="cm-string">"work"</span>, <span class="cm-string">"ice cream"</span>, <span class="cm-string">"cauliflower"</span>, <span class="cm-string">"lasagna"</span>,
          <span class="cm-string">"touched tree"</span>, <span class="cm-string">"brushed teeth"</span>], <span class="cm-atom">false</span>);
<span class="cm-variable">addEntry</span>([<span class="cm-string">"weekend"</span>, <span class="cm-string">"cycling"</span>, <span class="cm-string">"break"</span>, <span class="cm-string">"peanuts"</span>,
          <span class="cm-string">"beer"</span>], <span class="cm-atom">true</span>);</pre>
<p><a class="p_ident" id="p_+Ih1dpMwEH" href="./04_data.html#p_+Ih1dpMwEH"></a>След като разполага с достатъчно точки от данни, той възнамеряваше да изчисли съотношението между неговата кетерицо-фикация и всяко от събитията през деня, и в идеалния случай да научи нещо полезно от тези корелации.</p>
<p><a class="p_ident" id="p_EedDVNQ30H" href="./04_data.html#p_EedDVNQ30H"></a>Корелация е мярка за зависимостта между променливите (променливи в статистическия смисъл, а не в смисъл на JavaScript). Тя обикновено се изразява, като коефициент, който варира между -1 и 1. Нулевата корелация означава, че променливите не са свързани, като се има в предвид, че съответствието на единия показва, че двата са напълно свързани и ако знаете единия, то знаете и другия. Отрицателната означава, че променливите са напълно свързани, но са противоположни - когато едното е <em>true</em>, другото е <em>false</em>.</p>
<p><a class="p_ident" id="p_4Rv6gGntx7" href="./04_data.html#p_4Rv6gGntx7"></a>За бинарни (булеви) променливи, коефициента на <em>phi</em> (<em>ϕ</em>) дава добра мярка за корелация и е относително лесно да се изчисли. За да се изчисли <em>ϕ</em>, имаме нужда от една таблица <em>n</em>, която съдържа броя пъти, когато са наблюдавани различни комбинации на двете променливи. Например, може да разгледаме случаите с ядене на пица и ги отбележим в таблица, като тази:</p>
<div class="image">
  <img src="./media/pizza-squirrel.svg" alt="Eating pizza versus turning into a squirrel">
</div>
<p><a class="p_ident" id="p_82L/EowL1c" href="./04_data.html#p_82L/EowL1c"></a><em>ϕ</em> може да се изчисли по следната формула, където <em>n</em> се отнася за  таблицата.</p>
<div>
<style scoped="scoped">sub { font-size: 60%; }</style>
<table style="border-collapse: collapse; margin-left: 1em;"><tbody><tr>
  <td style="vertical-align: middle"><em>ϕ</em> =</td>
  <td style="padding-left: .5em">
    <div style="border-bottom: 1px solid black; padding: 0 7px;">n<sub>11</sub>n<sub>00</sub> - n<sub>10</sub>n<sub>01</sub></div>
    <div style="padding: 0 7px;">√<span style="border-top: 1px solid black; position: relative; top: 2px;">
      <span style="position: relative; top: -4px">n<sub>1•</sub>n<sub>0•</sub>n<sub>•1</sub>n<sub>•0</sub></span>
    </span></div>
  </td>
</tr></tbody></table>
</div>
<p><a class="p_ident" id="p_WPl/XNNv2K" href="./04_data.html#p_WPl/XNNv2K"></a>Нотацията <em>n</em><sub>01</sub> показва броя на измерванията, където първата променлива (<em>squirrelness</em>) е <em>false</em>(0), а втората променлива (пица) е <em>true</em>(1) . В този пример <em>n</em><sub>01</sub> е 9.</p>
<p><a class="p_ident" id="p_pweIXp0GRF" href="./04_data.html#p_pweIXp0GRF"></a>Стойноста <em>n</em><sub>1•</sub> се отнася  за сумата от всички измервания, където първата променлива е  <em>true</em> , като например 5 в таблицата. По същия начин <em>n</em><sub>•0</sub> се отнася за сумата от измервания, където втората променлива е <em>false</em>.</p>
<p><a class="p_ident" id="p_ACMn7uvFzz" href="./04_data.html#p_ACMn7uvFzz"></a>Така че, таблицата за пица, от горната страна над-линията за разделяне (дивидента) ще бъде 1 х 76 - 4 х 9 = 40, а частта под нея(делителя) ще бъде корен квадратен от 5 х 85 х 10 х 80 или √340000. От това излиза, че <em>ϕ</em> ≈ 0.069, което е малко. Яденето на пица не изглежда да има влияние върху трансформациите.</p>
<h2><a class="h_ident" id="h_YwedOm6SqZ" href="./04_data.html#h_YwedOm6SqZ"></a>Изчисляване на корелации</h2>
<p><a class="p_ident" id="p_jn2nhCXEpR" href="./04_data.html#p_jn2nhCXEpR"></a>Можем да представим таблица с две от две в JavaScript с масив от четири елемента (<code>[76, 9,
4, 1]</code>). Можем също да използваме и други представяния, като масив съдържащ два масива с елементи (<code>[[76, 9], [4, 1]]</code>) или обект с имена, като <code>"11"</code> и <code>"01"</code>, но масивът е семпъл и прави изразите за достъп до таблицата приятно кратки. Ние ще интерпретираме индексите на масива, като дву-битов бинарен номер, където най-лявата (най-значимата) цифра се отнася до променливата на катерицата и най-дясната (най-маловажната) цифра се отнася до променливата на събитията. Например бинарния номер <code>10</code> се отнася за случаите, когато Жак се превръща в катерица, но събитието (пица) не се е случвало. Това се случвало четири пъти. И тъй като бинарно <code>10</code> е 2 в десетична бройна система, ние ще съхраняваме този номер на индекс 2 в масива.</p>
<p><a class="p_ident" id="p_napfsNS5sk" href="./04_data.html#p_napfsNS5sk"></a>Това е функция, която изчислява коефициента на <em>ϕ</em>, като масив от:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_S1PE4hukUi" href="./04_data.html#c_S1PE4hukUi"></a><span class="cm-keyword">function</span> <span class="cm-variable">phi</span>(<span class="cm-def">table</span>) {
  <span class="cm-keyword">return</span> (<span class="cm-variable-2">table</span>[<span class="cm-number">3</span>] <span class="cm-operator">*</span> <span class="cm-variable-2">table</span>[<span class="cm-number">0</span>] <span class="cm-operator">-</span> <span class="cm-variable-2">table</span>[<span class="cm-number">2</span>] <span class="cm-operator">*</span> <span class="cm-variable-2">table</span>[<span class="cm-number">1</span>]) <span class="cm-operator">/</span>
    <span class="cm-variable">Math</span>.<span class="cm-property">sqrt</span>((<span class="cm-variable-2">table</span>[<span class="cm-number">2</span>] <span class="cm-operator">+</span> <span class="cm-variable-2">table</span>[<span class="cm-number">3</span>]) <span class="cm-operator">*</span>
              (<span class="cm-variable-2">table</span>[<span class="cm-number">0</span>] <span class="cm-operator">+</span> <span class="cm-variable-2">table</span>[<span class="cm-number">1</span>]) <span class="cm-operator">*</span>
              (<span class="cm-variable-2">table</span>[<span class="cm-number">1</span>] <span class="cm-operator">+</span> <span class="cm-variable-2">table</span>[<span class="cm-number">3</span>]) <span class="cm-operator">*</span>
              (<span class="cm-variable-2">table</span>[<span class="cm-number">0</span>] <span class="cm-operator">+</span> <span class="cm-variable-2">table</span>[<span class="cm-number">2</span>]));
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">phi</span>([<span class="cm-number">76</span>, <span class="cm-number">9</span>, <span class="cm-number">4</span>, <span class="cm-number">1</span>]));
<span class="cm-comment">// → 0.068599434</span></pre>
<p><a class="p_ident" id="p_25QRmcB8ci" href="./04_data.html#p_25QRmcB8ci"></a>Това е просто един директен превод на формулата <em>ϕ</em> в JavaScript. <code>Math.sqrt</code> е функция за корен квадратен, която е предвидена от <code>Math</code> обекта в стандартна JavaScript среда. Ние трябва да сумираме две полета от таблицата, за да получим области, като n<sub>1•</sub>, защото сумите от редовете и колоните не се съхраняват директно в нашата структура от данни.</p>
<p><a class="p_ident" id="p_0u/DATumDu" href="./04_data.html#p_0u/DATumDu"></a>Жак води дневника си в продължение три месеца. Полученият набор от данни е на разположение в пясъчника за кодиране на тази глава, където той се съхранява в променливата <code>JOURNAL</code> и в достъпен <a href="./code/jacques_journal.js">файл</a> за теглене.
.</p>
<p><a class="p_ident" id="p_sM+4QT8FKs" href="./04_data.html#p_sM+4QT8FKs"></a>За да се извлече две по две таблица за конкретно събитие от този журнал, ние трябва да поставим всички записи в цикъл и да видим колко пъти дадено събитие се случва по отношение на трансформацията в катерица.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_eFskSRBd2j" href="./04_data.html#c_eFskSRBd2j"></a><span class="cm-keyword">function</span> <span class="cm-variable">hasEvent</span>(<span class="cm-def">event</span>, <span class="cm-def">entry</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable-2">entry</span>.<span class="cm-property">events</span>.<span class="cm-property">indexOf</span>(<span class="cm-variable-2">event</span>) <span class="cm-operator">!=</span> <span class="cm-operator">-</span><span class="cm-number">1</span>;
}

<span class="cm-keyword">function</span> <span class="cm-variable">tableFor</span>(<span class="cm-def">event</span>, <span class="cm-def">journal</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">table</span> <span class="cm-operator">=</span> [<span class="cm-number">0</span>, <span class="cm-number">0</span>, <span class="cm-number">0</span>, <span class="cm-number">0</span>];
  <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">i</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">i</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">journal</span>.<span class="cm-property">length</span>; <span class="cm-variable-2">i</span><span class="cm-operator">++</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">entry</span> <span class="cm-operator">=</span> <span class="cm-variable-2">journal</span>[<span class="cm-variable-2">i</span>], <span class="cm-def">index</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>;
    <span class="cm-keyword">if</span> (<span class="cm-variable">hasEvent</span>(<span class="cm-variable-2">event</span>, <span class="cm-variable-2">entry</span>)) <span class="cm-variable-2">index</span> <span class="cm-operator">+=</span> <span class="cm-number">1</span>;
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">entry</span>.<span class="cm-property">squirrel</span>) <span class="cm-variable-2">index</span> <span class="cm-operator">+=</span> <span class="cm-number">2</span>;
    <span class="cm-variable-2">table</span>[<span class="cm-variable-2">index</span>] <span class="cm-operator">+=</span> <span class="cm-number">1</span>;
  }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">table</span>;
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">tableFor</span>(<span class="cm-string">"pizza"</span>, <span class="cm-variable">JOURNAL</span>));
<span class="cm-comment">// → [76, 9, 4, 1]</span></pre>
<p><a class="p_ident" id="p_3pgyJn7mEy" href="./04_data.html#p_3pgyJn7mEy"></a>Функцията <code>hasEvent</code> тества дали даден запис съдържа дадено събитие. Масивите имат <code>indexOf</code> метод, който се опитва да намери дадена стойност (в този случай име на събитие) в масива и връща индекса, при който е установено или -1 ако не е намерено. Така че, ако метода <code>indexOf</code> не връща -1, тогава знаем, че събитието е намерено в записа.</p>
<p><a class="p_ident" id="p_6jCcm4ltfJ" href="./04_data.html#p_6jCcm4ltfJ"></a>Тялото на цикъла в <code>tableFor</code> преценява в коя кутия на таблицата попада при всяко влизане, чрез проверка дали записа съдържа конкретно събитие от което се интересува и дали събитието съвпада с инцидента с катерицата. След това, цикъла добавя едно към броя в масива, който съответства на това поле в таблицата.</p>
<p><a class="p_ident" id="p_PId7X0fpkS" href="./04_data.html#p_PId7X0fpkS"></a>Сега имаме инструментите, които трябва да изчислят индивидуалните корелации. Единствената стъпка, която остава е да се намери съответствието за всеки тип събитие, което е записано и да видим дали нещо се откроява. Но как трябва да се съхраняват тези корелации, след като сме ги изчислили?</p>
<h2><a class="h_ident" id="h_mrW9RQxlGk" href="./04_data.html#h_mrW9RQxlGk"></a>Обекти като карти (map)</h2>
<p><a class="p_ident" id="p_IdpwDMsKm8" href="./04_data.html#p_IdpwDMsKm8"></a>Един възможен начин е да се съхраняват всички корелации в масив, използвайки обекти с <code>name</code> и <code>value</code> свойства. Но това прави търсенето на корелация за дадено събитие тромаво: ще трябва да мине цикъл през целия масив, за да намери обекта с правилното <code>name</code>. Ние можем да приключим това търсене във функция, но щяхме да пишем повече код и компютъра щеше да върши повече работа, отколкото е необходимо.</p>
<p id="object_map"><a class="p_ident" id="p_cZSsd9wDlN" href="./04_data.html#p_cZSsd9wDlN"></a>По-добър начин е да се използва обектното свойство, кръстено на видовете събития <em>event</em>. Можем да използваме квадратни скоби за достъп при създаването и четенето на свойствата и да използваме оператора <code>in</code>, за да провери дали съществува дадено свойство.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_+2/ib0YcAS" href="./04_data.html#c_+2/ib0YcAS"></a><span class="cm-keyword">var</span> <span class="cm-variable">map</span> <span class="cm-operator">=</span> {};
<span class="cm-keyword">function</span> <span class="cm-variable">storePhi</span>(<span class="cm-def">event</span>, <span class="cm-def">phi</span>) {
  <span class="cm-variable">map</span>[<span class="cm-variable-2">event</span>] <span class="cm-operator">=</span> <span class="cm-variable-2">phi</span>;
}

<span class="cm-variable">storePhi</span>(<span class="cm-string">"pizza"</span>, <span class="cm-number">0.069</span>);
<span class="cm-variable">storePhi</span>(<span class="cm-string">"touched tree"</span>, <span class="cm-operator">-</span><span class="cm-number">0.081</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"pizza"</span> <span class="cm-keyword">in</span> <span class="cm-variable">map</span>);
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">map</span>[<span class="cm-string">"touched tree"</span>]);
<span class="cm-comment">// → -0.081</span></pre>
<p><a class="p_ident" id="p_OlrE0O0+IT" href="./04_data.html#p_OlrE0O0+IT"></a>Картата (<em>map</em>) е начин да се премине от стойности в дадена област ( в този случай, имена на събития) в съответните стойности в друга област (в този случай, <em>ϕ</em> коефициенти).</p>
<p><a class="p_ident" id="p_Geo6ELctAH" href="./04_data.html#p_Geo6ELctAH"></a>Има няколко потенциални проблема при използването на обекти по този начин, които ще обсъдим в <a href="./06_object.html#prototypes">Глава 6</a>, но за момента няма да се притесняваме за това.</p>
<p><a class="p_ident" id="p_esSmj3VTX0" href="./04_data.html#p_esSmj3VTX0"></a>Какво става, ако искаме да намерим всички събития, за които съхраняваме коефициент? Свойствата не образуват предвидима серия, когато ако са в масив, така че не можем да използваме нормален <code>for</code> цикъл. JavaScript осигурява специален цикъл за преминаване през свойствата на даден обект. Той изглежда, като нормален <code>for</code> цикъл, но се отличава с използването на думата <code>in</code>.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_fVra/BEVfu" href="./04_data.html#c_fVra/BEVfu"></a><span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-variable">event</span> <span class="cm-keyword">in</span> <span class="cm-variable">map</span>)
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"The correlation for '"</span> <span class="cm-operator">+</span> <span class="cm-variable">event</span> <span class="cm-operator">+</span>
              <span class="cm-string">"' is "</span> <span class="cm-operator">+</span> <span class="cm-variable">map</span>[<span class="cm-variable">event</span>]);
<span class="cm-comment">// → The correlation for 'pizza' is 0.069</span>
<span class="cm-comment">// → The correlation for 'touched tree' is -0.081</span></pre>
<h2 id="analysis"><a class="h_ident" id="h_Lg5n7mjqw/" href="./04_data.html#h_Lg5n7mjqw/"></a>Финален анализ</h2>
<p><a class="p_ident" id="p_o0qm2V9nGm" href="./04_data.html#p_o0qm2V9nGm"></a>За да намерим всички видове събития, които се намират в набора от данни, ние просто обработваме всеки запис в ред от данните и след това минаваме с цикъл над събитията в този запис. Ние поддържаме обект <code>phis</code>, който съдържа коефициентите на корелациите за всички видове събития, които сме видяли досега. Всеки път, когато попаднем на тип, който още не е в обекта <code>phis</code>, ние изчисляваме неговата корелация и го добавяме към обекта.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_NNtQBmsHS2" href="./04_data.html#c_NNtQBmsHS2"></a><span class="cm-keyword">function</span> <span class="cm-variable">gatherCorrelations</span>(<span class="cm-def">journal</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">phis</span> <span class="cm-operator">=</span> {};
  <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">entry</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">entry</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">journal</span>.<span class="cm-property">length</span>; <span class="cm-variable-2">entry</span><span class="cm-operator">++</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">events</span> <span class="cm-operator">=</span> <span class="cm-variable-2">journal</span>[<span class="cm-variable-2">entry</span>].<span class="cm-property">events</span>;
    <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">i</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">i</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">events</span>.<span class="cm-property">length</span>; <span class="cm-variable-2">i</span><span class="cm-operator">++</span>) {
      <span class="cm-keyword">var</span> <span class="cm-def">event</span> <span class="cm-operator">=</span> <span class="cm-variable-2">events</span>[<span class="cm-variable-2">i</span>];
      <span class="cm-keyword">if</span> (<span class="cm-operator">!</span>(<span class="cm-variable-2">event</span> <span class="cm-keyword">in</span> <span class="cm-variable-2">phis</span>))
        <span class="cm-variable-2">phis</span>[<span class="cm-variable-2">event</span>] <span class="cm-operator">=</span> <span class="cm-variable">phi</span>(<span class="cm-variable">tableFor</span>(<span class="cm-variable-2">event</span>, <span class="cm-variable-2">journal</span>));
    }
  }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">phis</span>;
}

<span class="cm-keyword">var</span> <span class="cm-variable">correlations</span> <span class="cm-operator">=</span> <span class="cm-variable">gatherCorrelations</span>(<span class="cm-variable">JOURNAL</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">correlations</span>.<span class="cm-property">pizza</span>);
<span class="cm-comment">// → 0.068599434</span></pre>
<p><a class="p_ident" id="p_XUj02Go7DR" href="./04_data.html#p_XUj02Go7DR"></a>Да видим какво ще излезе:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_9AY4PathBr" href="./04_data.html#c_9AY4PathBr"></a><span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-variable">event</span> <span class="cm-keyword">in</span> <span class="cm-variable">correlations</span>)
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">event</span> <span class="cm-operator">+</span> <span class="cm-string">": "</span> <span class="cm-operator">+</span> <span class="cm-variable">correlations</span>[<span class="cm-variable">event</span>]);
<span class="cm-comment">// → carrot:   0.0140970969</span>
<span class="cm-comment">// → exercise: 0.0685994341</span>
<span class="cm-comment">// → weekend:  0.1371988681</span>
<span class="cm-comment">// → bread:   -0.0757554019</span>
<span class="cm-comment">// → pudding: -0.0648203724</span>
<span class="cm-comment">// and so on...</span></pre>
<p><a class="p_ident" id="p_TiI6dIjE18" href="./04_data.html#p_TiI6dIjE18"></a>Повечето корелации изглеждат близки до нула. Яденето на моркови, хляб или пудинг очевидно не задействат катерицо-трансформацията. Тя изглежда се появява малко по-често в събота и неделя обаче. Нека филтрираме резултатите, за да се покажат само корелации по-големи от 0.1 или по-малки от - 0.1.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_TLJ4VeMVj7" href="./04_data.html#c_TLJ4VeMVj7"></a><span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-variable">event</span> <span class="cm-keyword">in</span> <span class="cm-variable">correlations</span>) {
  <span class="cm-keyword">var</span> <span class="cm-variable">correlation</span> <span class="cm-operator">=</span> <span class="cm-variable">correlations</span>[<span class="cm-variable">event</span>];
  <span class="cm-keyword">if</span> (<span class="cm-variable">correlation</span> <span class="cm-operator">&gt;</span> <span class="cm-number">0.1</span> <span class="cm-operator">||</span> <span class="cm-variable">correlation</span> <span class="cm-operator">&lt;</span> <span class="cm-operator">-</span><span class="cm-number">0.1</span>)
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">event</span> <span class="cm-operator">+</span> <span class="cm-string">": "</span> <span class="cm-operator">+</span> <span class="cm-variable">correlation</span>);
}
<span class="cm-comment">// → weekend:        0.1371988681</span>
<span class="cm-comment">// → brushed teeth: -0.3805211953</span>
<span class="cm-comment">// → candy:          0.1296407447</span>
<span class="cm-comment">// → work:          -0.1371988681</span>
<span class="cm-comment">// → spaghetti:      0.2425356250</span>
<span class="cm-comment">// → reading:        0.1106828054</span>
<span class="cm-comment">// → peanuts:        0.5902679812</span></pre>
<p><a class="p_ident" id="p_V2ZEhvkhz3" href="./04_data.html#p_V2ZEhvkhz3"></a>А - ха! Има два фактора, чието съотношение е по-ясно изразено от другите. Яденето на фъстъци има силен, положителен ефект върху шанса да се превърне в катерица, докато миенето на зъби има значителен отрицателен ефект.</p>
<p><a class="p_ident" id="p_xpRHDuufcX" href="./04_data.html#p_xpRHDuufcX"></a>Интересно нека опитаме нещо.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_xlu1nixXWv" href="./04_data.html#c_xlu1nixXWv"></a><span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-variable">i</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable">i</span> <span class="cm-operator">&lt;</span> <span class="cm-variable">JOURNAL</span>.<span class="cm-property">length</span>; <span class="cm-variable">i</span><span class="cm-operator">++</span>) {
  <span class="cm-keyword">var</span> <span class="cm-variable">entry</span> <span class="cm-operator">=</span> <span class="cm-variable">JOURNAL</span>[<span class="cm-variable">i</span>];
  <span class="cm-keyword">if</span> (<span class="cm-variable">hasEvent</span>(<span class="cm-string">"peanuts"</span>, <span class="cm-variable">entry</span>) <span class="cm-operator">&amp;&amp;</span>
     <span class="cm-operator">!</span><span class="cm-variable">hasEvent</span>(<span class="cm-string">"brushed teeth"</span>, <span class="cm-variable">entry</span>))
    <span class="cm-variable">entry</span>.<span class="cm-property">events</span>.<span class="cm-property">push</span>(<span class="cm-string">"peanut teeth"</span>);
}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">phi</span>(<span class="cm-variable">tableFor</span>(<span class="cm-string">"peanut teeth"</span>, <span class="cm-variable">JOURNAL</span>)));
<span class="cm-comment">// → 1</span></pre>
<p><a class="p_ident" id="p_WUlOiYWV3C" href="./04_data.html#p_WUlOiYWV3C"></a>Well, няма грешка! Явлението се случва само когато Жак яде фъстъци и не си мие зъбите. Ако той не беше такъв мърляч на зъбната хигиена, нямаше никога да се сблъска с нещастието си.</p>
<p><a class="p_ident" id="p_tPNATV9wwS" href="./04_data.html#p_tPNATV9wwS"></a>Знаейки това, Жак просто спря да яде фъстъци и установи, че това напълно слага край на неговите трансформации.</p>
<p><a class="p_ident" id="p_DXAwHKoLIY" href="./04_data.html#p_DXAwHKoLIY"></a>Сега с Жак всичко е на ред за известно време. Но няколко години по-късно, той губи работата си и в крайна сметка е принуден да работи в един цирк, където изпълнява номера - Невероятната Катерицо-трансформация, тъпчейки устата си фъстъчено масло преди всяко шоу. Един ден, отвратен от това жалко съществуване, Жак не успя да се върне в неговата човешка форма и през една цепнатина в цирковата шатра, изчезна в гората. Никой никога не го е виждал отново.</p>
<h2><a class="h_ident" id="h_GFaxee4PuU" href="./04_data.html#h_GFaxee4PuU"></a>Допълнителна масиво-логия</h2>
<p><a class="p_ident" id="p_U0+LZH9g+H" href="./04_data.html#p_U0+LZH9g+H"></a>Преди да завършим тази глава, искам да ви запозная с още няколко понятия свързани с обекти. Ще започнем с въвеждането на някои по принцип полезни методи за масиви.</p>
<p><a class="p_ident" id="p_Wl9gXY97xi" href="./04_data.html#p_Wl9gXY97xi"></a>Видяхме <code>push</code> и <code>pop</code>, които добавят и премахват елементи в края на масива, <a href="./04_data.html#array_methods">по-рано</a> в тази глава. Съответните методи за добавяне и премахване на елементи в началото на масива се наричат <code>unshift</code> и <code>shift</code>.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_9It3VS5zI/" href="./04_data.html#c_9It3VS5zI/"></a><span class="cm-keyword">var</span> <span class="cm-variable">todoList</span> <span class="cm-operator">=</span> [];
<span class="cm-keyword">function</span> <span class="cm-variable">rememberTo</span>(<span class="cm-def">task</span>) {
  <span class="cm-variable">todoList</span>.<span class="cm-property">push</span>(<span class="cm-variable-2">task</span>);
}
<span class="cm-keyword">function</span> <span class="cm-variable">whatIsNext</span>() {
  <span class="cm-keyword">return</span> <span class="cm-variable">todoList</span>.<span class="cm-property">shift</span>();
}
<span class="cm-keyword">function</span> <span class="cm-variable">urgentlyRememberTo</span>(<span class="cm-def">task</span>) {
  <span class="cm-variable">todoList</span>.<span class="cm-property">unshift</span>(<span class="cm-variable-2">task</span>);
}</pre>
<p><a class="p_ident" id="p_msNR9KyjFO" href="./04_data.html#p_msNR9KyjFO"></a>Тази програма управлява списъци от задачи. Можете да добавите задачи в края на списъка, като извикате <code>rememberTo("eat")</code> и когато сте готови да направите нещо, извикайте <code>whatIsNext()</code> за да вземете( и премахнете) предния елемент от списъка. Функцията <code>urgentlyRememberTo</code> добавя задача, но я добавя към предната вместо към задната част на списъка.</p>
<p><a class="p_ident" id="p_V9yB5Z4xWA" href="./04_data.html#p_V9yB5Z4xWA"></a>Метода <code>indexOf</code> има братче, наречено <code>lastIndexOf</code>, който започва да търси дадения елемент от края на масива вместо отпред.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_li2m9Gen8Q" href="./04_data.html#c_li2m9Gen8Q"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>([<span class="cm-number">1</span>, <span class="cm-number">2</span>, <span class="cm-number">3</span>, <span class="cm-number">2</span>, <span class="cm-number">1</span>].<span class="cm-property">indexOf</span>(<span class="cm-number">2</span>));
<span class="cm-comment">// → 1</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>([<span class="cm-number">1</span>, <span class="cm-number">2</span>, <span class="cm-number">3</span>, <span class="cm-number">2</span>, <span class="cm-number">1</span>].<span class="cm-property">lastIndexOf</span>(<span class="cm-number">2</span>));
<span class="cm-comment">// → 3</span></pre>
<p><a class="p_ident" id="p_hZ181L7UrW" href="./04_data.html#p_hZ181L7UrW"></a>И двата <code>indexOf</code> и <code>lastIndexOf</code> вземат втори не задължителен аргумент, който показва от къде да започне да търси.</p>
<p><a class="p_ident" id="p_wxgx//Le/b" href="./04_data.html#p_wxgx//Le/b"></a>Друг основен метод е <code>slice</code>, който взема индекс за начало и индекс за край, и връща масив, който съдържа елементите между тези индекси. Стартовия индекс е включващ, крайният индекс е изключващ.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_uRogoaHL4B" href="./04_data.html#c_uRogoaHL4B"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>([<span class="cm-number">0</span>, <span class="cm-number">1</span>, <span class="cm-number">2</span>, <span class="cm-number">3</span>, <span class="cm-number">4</span>].<span class="cm-property">slice</span>(<span class="cm-number">2</span>, <span class="cm-number">4</span>));
<span class="cm-comment">// → [2, 3]</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>([<span class="cm-number">0</span>, <span class="cm-number">1</span>, <span class="cm-number">2</span>, <span class="cm-number">3</span>, <span class="cm-number">4</span>].<span class="cm-property">slice</span>(<span class="cm-number">2</span>));
<span class="cm-comment">// → [2, 3, 4]</span></pre>
<p><a class="p_ident" id="p_Z01yQe26G8" href="./04_data.html#p_Z01yQe26G8"></a>Когато крайният индекс не е зададен, <code>slice</code> ще вземе всички елементи, след стартовия индекс. <em>Strings</em> също имат <code>slice</code> метод, който има подобен ефект.</p>
<p><a class="p_ident" id="p_1mS9LYSSFD" href="./04_data.html#p_1mS9LYSSFD"></a>Метода <code>concat</code> може да се използва за залепване на масиви заедно, подобно на това, което оператора <code>+</code> прави със <em>strings</em>. Следващия пример показва <code>concat</code> и <code>slice</code> в действие. Те вземат <em>array</em> и <em>index</em> и връщат нов масив, който е копие на оригиналния масив с елемента премахнат от дадения индекс.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_ai2SwbDs5w" href="./04_data.html#c_ai2SwbDs5w"></a><span class="cm-keyword">function</span> <span class="cm-variable">remove</span>(<span class="cm-def">array</span>, <span class="cm-def">index</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable-2">array</span>.<span class="cm-property">slice</span>(<span class="cm-number">0</span>, <span class="cm-variable-2">index</span>)
    .<span class="cm-property">concat</span>(<span class="cm-variable-2">array</span>.<span class="cm-property">slice</span>(<span class="cm-variable-2">index</span> <span class="cm-operator">+</span> <span class="cm-number">1</span>));
}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">remove</span>([<span class="cm-string">"a"</span>, <span class="cm-string">"b"</span>, <span class="cm-string">"c"</span>, <span class="cm-string">"d"</span>, <span class="cm-string">"e"</span>], <span class="cm-number">2</span>));
<span class="cm-comment">// → ["a", "b", "d", "e"]</span></pre>
<h2><a class="h_ident" id="h_mT4YQfwHp6" href="./04_data.html#h_mT4YQfwHp6"></a>Strings и техните свойства</h2>
<p><a class="p_ident" id="p_ZbMq0Cy4Fu" href="./04_data.html#p_ZbMq0Cy4Fu"></a>Можем да четем свойства, като <code>length</code> и <code>toUpperCase</code> от <em>strings</em> стойности. Но ако се опитате да добавите ново свойство, то не се добавя.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_kuUv1PH55x" href="./04_data.html#c_kuUv1PH55x"></a><span class="cm-keyword">var</span> <span class="cm-variable">myString</span> <span class="cm-operator">=</span> <span class="cm-string">"Fido"</span>;
<span class="cm-variable">myString</span>.<span class="cm-property">myProperty</span> <span class="cm-operator">=</span> <span class="cm-string">"value"</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">myString</span>.<span class="cm-property">myProperty</span>);
<span class="cm-comment">// → undefined</span></pre>
<p><a class="p_ident" id="p_B+oSPYAIbV" href="./04_data.html#p_B+oSPYAIbV"></a>Стойности на <em>strings, nuber</em> и <em>Boolean</em> не са обекти и въпреки, че езикът не се оплаква, ако се опитате да им зададете нови свойства, те всъщност не съхраняват тези свойства. Стойностите са неизменни и не могат да бъдат променяни.</p>
<p><a class="p_ident" id="p_8L2ib2beYN" href="./04_data.html#p_8L2ib2beYN"></a>Но тези видове имат някои вградени свойства. Всяка стойност на <em>string</em> има редица методи. Най-полезните от тях вероятно са <code>slice</code> и <code>indexOf</code>, които приличат на методите на масива със същото име.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_rZojswAQFV" href="./04_data.html#c_rZojswAQFV"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"coconuts"</span>.<span class="cm-property">slice</span>(<span class="cm-number">4</span>, <span class="cm-number">7</span>));
<span class="cm-comment">// → nut</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"coconut"</span>.<span class="cm-property">indexOf</span>(<span class="cm-string">"u"</span>));
<span class="cm-comment">// → 5</span></pre>
<p><a class="p_ident" id="p_RUd6q+Q4dc" href="./04_data.html#p_RUd6q+Q4dc"></a>Една от разликите е, че <em>string</em>-а на <code>indexOf</code> може да е <em>string</em> съдържащ повече от един характер, докато съответния метод за масив е само за един единствен елемент.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_sW/DJiLrM1" href="./04_data.html#c_sW/DJiLrM1"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"one two three"</span>.<span class="cm-property">indexOf</span>(<span class="cm-string">"ee"</span>));
<span class="cm-comment">// → 11</span></pre>
<p><a class="p_ident" id="p_iSAQfJDhu8" href="./04_data.html#p_iSAQfJDhu8"></a>Метода <code>trim</code> премахва празното пространство (интервали, нови редове, раздели и др. подобни характери) от началото и края на <em>string</em>-a.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_Bm4kTTYcF2" href="./04_data.html#c_Bm4kTTYcF2"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"  okay \n "</span>.<span class="cm-property">trim</span>());
<span class="cm-comment">// → okay</span></pre>
<p><a class="p_ident" id="p_J4kiFmHyRO" href="./04_data.html#p_J4kiFmHyRO"></a>Вече видяхме, свойството <code>length</code> на типа <em>string</em>. Достъп до характерите на отделните елементи в <em>string</em>-a може да се направи с метода <code>charAt</code>, но също и като просто се четат цифровите свойства, както бихме направили в масив.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_+uFPZG6blX" href="./04_data.html#c_+uFPZG6blX"></a><span class="cm-keyword">var</span> <span class="cm-variable">string</span> <span class="cm-operator">=</span> <span class="cm-string">"abc"</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">string</span>.<span class="cm-property">length</span>);
<span class="cm-comment">// → 3</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">string</span>.<span class="cm-property">charAt</span>(<span class="cm-number">0</span>));
<span class="cm-comment">// → a</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">string</span>[<span class="cm-number">1</span>]);
<span class="cm-comment">// → b</span></pre>
<h2 id="arguments_object"><a class="h_ident" id="h_GstIcsgxyb" href="./04_data.html#h_GstIcsgxyb"></a>Обекта на аргументите</h2>
<p><a class="p_ident" id="p_8jQc6BP3jE" href="./04_data.html#p_8jQc6BP3jE"></a>Всеки път, когато дадена функция се извиква, специална променлива наречена <code>arguments</code> се добавя към средата, в която тялото на функцията се изпълнява. Тази променлива се отнася към обект, който притежава всички аргументи подадени на функцията. Не забравяйте, че в JavaScript ви е позволено да подадете повече (или по-малко ) аргументи към функция от броя на параметрите, които функцията обявява.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_vGR3ohSBVO" href="./04_data.html#c_vGR3ohSBVO"></a><span class="cm-keyword">function</span> <span class="cm-variable">noArguments</span>() {}
<span class="cm-variable">noArguments</span>(<span class="cm-number">1</span>, <span class="cm-number">2</span>, <span class="cm-number">3</span>); <span class="cm-comment">// This is okay</span>
<span class="cm-keyword">function</span> <span class="cm-variable">threeArguments</span>(<span class="cm-def">a</span>, <span class="cm-def">b</span>, <span class="cm-def">c</span>) {}
<span class="cm-variable">threeArguments</span>(); <span class="cm-comment">// And so is this</span></pre>
<p><a class="p_ident" id="p_X05+xpRc+j" href="./04_data.html#p_X05+xpRc+j"></a>Обекта <code>arguments</code> има свойство <code>length</code>, което ни казва броят на аргументите, които се подават на функцията. Тя също има свойство за всеки аргумент, 0, 1, 2 и т.н.</p>
<p><a class="p_ident" id="p_r7f/a3/GFP" href="./04_data.html#p_r7f/a3/GFP"></a>Ако това ви прилича на масив сте прави, това много прилича на масив. Но този обект за съжаление, няма никакви методи, като масиви (като <code>slice</code> или
<code>indexOf</code>), така че е малко по-труден за използване от истински масив.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_MLV9gPSdx9" href="./04_data.html#c_MLV9gPSdx9"></a><span class="cm-keyword">function</span> <span class="cm-variable">argumentCounter</span>() {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"You gave me"</span>, <span class="cm-variable-2">arguments</span>.<span class="cm-property">length</span>, <span class="cm-string">"arguments."</span>);
}
<span class="cm-variable">argumentCounter</span>(<span class="cm-string">"Straw man"</span>, <span class="cm-string">"Tautology"</span>, <span class="cm-string">"Ad hominem"</span>);
<span class="cm-comment">// → You gave me 3 arguments.</span></pre>
<p><a class="p_ident" id="p_MIxvg5Tzop" href="./04_data.html#p_MIxvg5Tzop"></a>Някои функции могат да имат произволен брой аргументи, като <code>console.log</code>. Те обикновено циклят над стойностите в техния <code>arguments</code> обект и могат да бъдат използвани за създаване на много приятни интерфейси. Например да си спомним как създадохме вписванията в журнала на Жак.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_HkIRWLvq7y" href="./04_data.html#c_HkIRWLvq7y"></a><span class="cm-variable">addEntry</span>([<span class="cm-string">"work"</span>, <span class="cm-string">"touched tree"</span>, <span class="cm-string">"pizza"</span>, <span class="cm-string">"running"</span>,
          <span class="cm-string">"television"</span>], <span class="cm-atom">false</span>);</pre>
<p><a class="p_ident" id="p_2WHMCXaaIn" href="./04_data.html#p_2WHMCXaaIn"></a>Тъй като, ще трябва да извикваме тази функция много пъти, бихме могли да създадем алтернатива , която е по-лесна за извикване.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_mJiHtSVFDT" href="./04_data.html#c_mJiHtSVFDT"></a><span class="cm-keyword">function</span> <span class="cm-variable">addEntry</span>(<span class="cm-def">squirrel</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">entry</span> <span class="cm-operator">=</span> {<span class="cm-property">events</span>: [], <span class="cm-property">squirrel</span>: <span class="cm-variable-2">squirrel</span>};
  <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">i</span> <span class="cm-operator">=</span> <span class="cm-number">1</span>; <span class="cm-variable-2">i</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">arguments</span>.<span class="cm-property">length</span>; <span class="cm-variable-2">i</span><span class="cm-operator">++</span>)
    <span class="cm-variable-2">entry</span>.<span class="cm-property">events</span>.<span class="cm-property">push</span>(<span class="cm-variable-2">arguments</span>[<span class="cm-variable-2">i</span>]);
  <span class="cm-variable">journal</span>.<span class="cm-property">push</span>(<span class="cm-variable-2">entry</span>);
}
<span class="cm-variable">addEntry</span>(<span class="cm-atom">true</span>, <span class="cm-string">"work"</span>, <span class="cm-string">"touched tree"</span>, <span class="cm-string">"pizza"</span>,
         <span class="cm-string">"running"</span>, <span class="cm-string">"television"</span>);</pre>
<p><a class="p_ident" id="p_o3+Bq1M1pm" href="./04_data.html#p_o3+Bq1M1pm"></a>Тази версия чете първия си аргумент (<code>squirrel</code>) по нормален начин, а след това минава над останалата част от аргументите (цикъла започва от индекс 1, като прескача първия), за да ги събере в масив.</p>
<h2><a class="h_ident" id="h_C51DnYk8WZ" href="./04_data.html#h_C51DnYk8WZ"></a>Math обект</h2>
<p><a class="p_ident" id="p_9S5JZybGFD" href="./04_data.html#p_9S5JZybGFD"></a>Както видяхме, <code>Math</code> e пакет от свързани с цифри полезни функции, като например <code>Math.max</code> (максимум), <code>Math.min</code> (минимум) и <code>Math.sqrt</code> (корен квадратен).</p>
<p id="namespace_pollution"><a class="p_ident" id="p_YvGRywRVYj" href="./04_data.html#p_YvGRywRVYj"></a>Обекта <code>Math</code> се ползва просто, като контейнер за група от свързана функционалност. Има само един обект <code>Math</code> и почти никога полезен, само като стойност. Вместо това, той осигурява пространство от имена (<code>namespace</code>), така че всички тези стойности на функции, да не трябва да бъдат глобални променливи. </p>
<p><a class="p_ident" id="p_fGEMziAXhp" href="./04_data.html#p_fGEMziAXhp"></a>Имайки твърде много глобални променливи се “замърсява” пространството от имена. Колкото повече имена са въведени, толкова по вероятно е случайно презаписване на стойността на някоя променлива. Например, не е малко вероятно да искате да назовете нещо с <code>max</code> във вашата програма. Тъй като <code>max</code> е вградена функция в JavaScript, прибрана на сигурно вътре в <code>Math</code> обекта, не трябва да се притеснявате за това презаписване.</p>
<p><a class="p_ident" id="p_tEjnm+nh21" href="./04_data.html#p_tEjnm+nh21"></a>Много езици ще ви спрат или поне предупредят, когато дефинирате променлива с име, което вече е заето, JavaScript не го прави, така че бъдете внимателни.</p>
<p><a class="p_ident" id="p_zWXQRNgLI/" href="./04_data.html#p_zWXQRNgLI/"></a>Обратно към <code>Math</code> обекта. Ако правите някаква тригонометрия, <code>Math</code> може да помогне. Той съдържа <code>cos</code> (косинус), <code>sin</code> (синус) и <code>tan</code> (тангенс), както и техните обратни функции <code>acos</code>, <code>asin</code>, и <code>atan</code> респективно. Числото π (пи) - или поне най-близкото приближение, което се вписва в JavaScript, като номер е на разположение с <code>Math.PI</code>. (Има една стара традиция за писане на програмни имена на постоянни стойности (константи) с главни букви.)</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_2uZIZgWSsu" href="./04_data.html#c_2uZIZgWSsu"></a><span class="cm-keyword">function</span> <span class="cm-variable">randomPointOnCircle</span>(<span class="cm-def">radius</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">angle</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">random</span>() <span class="cm-operator">*</span> <span class="cm-number">2</span> <span class="cm-operator">*</span> <span class="cm-variable">Math</span>.<span class="cm-property">PI</span>;
  <span class="cm-keyword">return</span> {<span class="cm-property">x</span>: <span class="cm-variable-2">radius</span> <span class="cm-operator">*</span> <span class="cm-variable">Math</span>.<span class="cm-property">cos</span>(<span class="cm-variable-2">angle</span>),
          <span class="cm-property">y</span>: <span class="cm-variable-2">radius</span> <span class="cm-operator">*</span> <span class="cm-variable">Math</span>.<span class="cm-property">sin</span>(<span class="cm-variable-2">angle</span>)};
}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">randomPointOnCircle</span>(<span class="cm-number">2</span>));
<span class="cm-comment">// → {x: 0.3667, y: 1.966}</span></pre>
<p><a class="p_ident" id="p_4kTWFGWGMm" href="./04_data.html#p_4kTWFGWGMm"></a>Ако <em>sin</em> и <em>cos</em> са нещо, с което не сте много добре запознати, не се притеснявайте. Когато се използват в <a href="./13_dom.html#sin_cos">Глава 13</a>, аз ще ги обясня.</p>
<p><a class="p_ident" id="p_a6xMq73yCc" href="./04_data.html#p_a6xMq73yCc"></a>Предишният пример използва <code>Math.random</code>. Това е функция, която връща нов случаен номер, между нула (включително) и едно, всеки път когато се извика.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_wJKP6sIzSp" href="./04_data.html#c_wJKP6sIzSp"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">Math</span>.<span class="cm-property">random</span>());
<span class="cm-comment">// → 0.36993729369714856</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">Math</span>.<span class="cm-property">random</span>());
<span class="cm-comment">// → 0.727367032552138</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">Math</span>.<span class="cm-property">random</span>());
<span class="cm-comment">// → 0.40180766698904335</span></pre>
<p><a class="p_ident" id="p_LqSZpx/sgf" href="./04_data.html#p_LqSZpx/sgf"></a>Въпреки, че компютрите са детерминирани машини - те винаги реагират по един и същи начин, ако се подават едни и същи входни данни - е възможно да произвеждат номера на случаен принцип. За да направи това, устройството поддържа редица номера във вътрешното си състояние. След това, всеки път, когато се искат случайни числа, тя изпълнява някои сложни детерминирани изчисления във вътрешността си и връща част от резултата на тези изчисления. Машината използва резултата  за да промени вътрешното си състояние, така че произведените следващи случайни числа да бъдат различни.</p>
<p><a class="p_ident" id="p_WnBKL1c/CF" href="./04_data.html#p_WnBKL1c/CF"></a>Ако искаме цели случайни числа вместо дробни, можем да използваме <code>Math.floor</code> (която закръгля на долу към най-близкото цяло число) преди резултата на <code>Math.random</code>.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_bBGTtB+AvR" href="./04_data.html#c_bBGTtB+AvR"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">Math</span>.<span class="cm-property">floor</span>(<span class="cm-variable">Math</span>.<span class="cm-property">random</span>() <span class="cm-operator">*</span> <span class="cm-number">10</span>));
<span class="cm-comment">// → 2</span></pre>
<p><a class="p_ident" id="p_52aDRkOsyH" href="./04_data.html#p_52aDRkOsyH"></a>Умножаването на случайни числа по 10, ни дава число по-голямо или равно на нула, но по-малко от 10. Тъй като <code>Math.floor</code> закръгля на долу, този израз ще произведе с равен шанс всяко число от 0 до 9.</p>
<p><a class="p_ident" id="p_1pKvkjRw0T" href="./04_data.html#p_1pKvkjRw0T"></a>Също има функция <code>Math.ceil</code> (която закръгля на горе до цяло число), както и <code>Math.round</code> (закръгля до най-близкото цяло число).</p>
<h2><a class="h_ident" id="h_lRBZxXmo93" href="./04_data.html#h_lRBZxXmo93"></a>Глобален  обект</h2>
<p><a class="p_ident" id="p_+IF2SIC4YV" href="./04_data.html#p_+IF2SIC4YV"></a>Глобален обхват е пространство, в което живеят глобални променливи и към него може да се подхожда, като към всеки обект в JavaScript. Всяка глобална променлива присъства, като свойство на този обект. В браузърите, глобалния обхват на обекта се съхранява в <code>window</code> променлива.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_3k/DIzi9mB" href="./04_data.html#c_3k/DIzi9mB"></a><span class="cm-keyword">var</span> <span class="cm-variable">myVar</span> <span class="cm-operator">=</span> <span class="cm-number">10</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"myVar"</span> <span class="cm-keyword">in</span> <span class="cm-variable">window</span>);
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">window</span>.<span class="cm-property">myVar</span>);
<span class="cm-comment">// → 10</span></pre>
<h2><a class="h_ident" id="h_ErccPg/l98" href="./04_data.html#h_ErccPg/l98"></a>Резюме</h2>
<p><a class="p_ident" id="p_78ZfHX5x1B" href="./04_data.html#p_78ZfHX5x1B"></a>Обекти и масиви (които са специфични видове обекти) осигуряват начини за групиране на няколко стойности в една единствена стойност. Концептуално, това ни позволява да сложим един куп свързани неща в един пакет, вместо да се опитваме да приключим всички отделни неща и да ги ползваме по отделно.</p>
<p><a class="p_ident" id="p_ayhyxvWlMH" href="./04_data.html#p_ayhyxvWlMH"></a>Повечето стойности в JavaScript имат свойства с изключение на <code>null</code> и <code>undefined</code>.  Информацията се достига чрез <code>value.propName</code> или <code>value["propName"]</code>. Обектите са склонни да използват имена за техните свойства и съхранение на повече или по-малко фиксиран набор от тях. Масивите, от друга страна, обикновено съдържат различен брой концептуално идентични стойности и използват номера(започвайки от 0) за имена на техните свойства.</p>
<p><a class="p_ident" id="p_1lcitbawCQ" href="./04_data.html#p_1lcitbawCQ"></a>Има някои именувани свойства за масиви, като <code>length</code> и както и редица методи. Методите са функции, които живеят в свойства и (обикновено) действат на стойността, на която са свойство.</p>
<p><a class="p_ident" id="p_ZtRACiqRCK" href="./04_data.html#p_ZtRACiqRCK"></a>Обектите могат да служат и като карти, за асоцииране на стойностти с имена. Оператора <code>in</code> може да се използва , за да се разбере, дали даден обект съдържа свойство с дадено име. Същата ключова дума може да се използва и за цикъл (<code>for (var name in object)</code>), който минава над свойствата на даден обект.</p>
<h2><a class="h_ident" id="h_TcUD2vzyMe" href="./04_data.html#h_TcUD2vzyMe"></a>Упражнения</h2>
<h3><a class="h_ident" id="h_8ZspxiCEC/" href="./04_data.html#h_8ZspxiCEC/"></a>Сумата на редица</h3>
<p><a class="p_ident" id="p_fpyyiv/hm1" href="./04_data.html#p_fpyyiv/hm1"></a>В <a href="./00_intro.html#intro">увода</a> на тази книга, споменах за следния добър начин да се изчисли сумата на обхвата от номера:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_OULOwD7HOm" href="./04_data.html#c_OULOwD7HOm"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">sum</span>(<span class="cm-variable">range</span>(<span class="cm-number">1</span>, <span class="cm-number">10</span>)));</pre>
<p><a class="p_ident" id="p_PkFb/61ecP" href="./04_data.html#p_PkFb/61ecP"></a>Напишете функция <code>range</code>, която използва два аргумента <code>start</code> и <code>end</code> и връща масив, който съдържа всички цифри от <code>start</code> до <code>end</code>(включително).</p>
<p><a class="p_ident" id="p_0GiJNcBSop" href="./04_data.html#p_0GiJNcBSop"></a>На следващо място, напишете функция <code>sum</code>, която използва масива от числа и връща сумата от тези числа. Стартирайте предишната програма и вижте дали наистина връща 55.</p>
<p><a class="p_ident" id="p_T5lVUHvYnd" href="./04_data.html#p_T5lVUHvYnd"></a>Като бонус задача, модифицирайте обхвата на функция да взима по желание трети аргумент - “step”, който показва стойността на стъпката, която се използва за изграждане на масива. Ако не е дадена стъпка елементите на масива вървят на горе със стъпка едно, съответстващо на старото поведение. Извикването на функция <code>range(1, 10, 2)</code>, трябва да върне [1, 3, 5, 7, 9]. Уверете се, че тя също работи и с отрицателни стойности на стъпката, така че <code>range(5, 2, -1)</code> произвежда [5, 4, 3, 2].</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_BUhKzmRiGU" href="./04_data.html#c_BUhKzmRiGU"></a><span class="cm-comment">// Your code here.</span>

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">range</span>(<span class="cm-number">1</span>, <span class="cm-number">10</span>));
<span class="cm-comment">// → [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">range</span>(<span class="cm-number">5</span>, <span class="cm-number">2</span>, <span class="cm-operator">-</span><span class="cm-number">1</span>));
<span class="cm-comment">// → [5, 4, 3, 2]</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">sum</span>(<span class="cm-variable">range</span>(<span class="cm-number">1</span>, <span class="cm-number">10</span>)));
<span class="cm-comment">// → 55</span></pre>
<div class="solution"><div class="solution-text">
<p><a class="p_ident" id="p_AzWVqPrlre" href="./04_data.html#p_AzWVqPrlre"></a>Изграждането на масив най-лесно може да се направи, като първо се инициализира променлива с <code>[]</code> (празен масив) и многократно извиква своя <code>push</code> метод за добавяне на стойност. Не забравяйте да върнете масива в края на функцията.</p>
<p><a class="p_ident" id="p_eu6MUPwjEb" href="./04_data.html#p_eu6MUPwjEb"></a>За край на границата включително, ще трябва да използвате оператора <code>&lt;=</code>, вместо <code>&lt;</code> при проверката за край на цикъла.</p>
<p><a class="p_ident" id="p_gp8gSa5PFL" href="./04_data.html#p_gp8gSa5PFL"></a>Трябва също да проверите дали е даден аргумент за стъпката, да проверите <code>arguments.length</code> и да сравните стойността на аргумента с <code>undefined</code>. Ако не е даден, просто го настройте към стойност по подразбиране (1) в горната част на функцията.</p>
<p><a class="p_ident" id="p_xfC3xdBYBn" href="./04_data.html#p_xfC3xdBYBn"></a>Когато знаете, че имате в <code>range</code> отрицателни стойности на стъпката, най-добре е да напишете два отделни цикъла - един за броене на горе и един за броене на долу, защото сравнението, което проверява дали цикълът е завършен трябва да бъде по-скоро <code>&gt;=</code>, отколкото <code>&lt;=</code>, когато се бори на долу.</p>
<p><a class="p_ident" id="p_kHSmZmF/0k" href="./04_data.html#p_kHSmZmF/0k"></a>Може също така да бъде полезно да се използва различна стъпка по подразбиране, а именно -1, когато края на обхвата е по-малък, отколкото началото. По този начин <code>range(5, 2)</code> връща нещо смислено, а не става един безкраен цикъл.</p>
</div></div>
<h3><a class="h_ident" id="h_6xTmjj4Rf5" href="./04_data.html#h_6xTmjj4Rf5"></a>Обръщане на масив</h3>
<p><a class="p_ident" id="p_0ysB6LgssH" href="./04_data.html#p_0ysB6LgssH"></a>Масивите имат метод <code>reverse</code>, който променя масива, като обръща реда, в който се появяват неговите елементи. За това упражнение напишете две функции, <code>reverseArray</code> и <code>reverseArrayInPlace</code>. Първата, <code>reverseArray</code>, взема масива, като аргумент и произвежда нов масив, който има същите елементи в обратен ред. Втората <code>reverseArrayInPlace</code>, прави това, което метода <code>reverse</code> прави: променя масива, даден като аргумент, за да обърне неговите елементи. Не може да се използва стандартния метод <code>reverse</code>.</p>
<p><a class="p_ident" id="p_0WdqLyJAyQ" href="./04_data.html#p_0WdqLyJAyQ"></a>Мисля си за бележките за страничните ефекти и чистите функции в <a href="./03_functions.html#pure">предишната глава</a>, кой вариант очаквате да бъде по-полезен в повечето ситуации? Кой е по-ефективен?</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_F3JsLaIs+m" href="./04_data.html#c_F3JsLaIs+m"></a><span class="cm-comment">// Your code here.</span>

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">reverseArray</span>([<span class="cm-string">"A"</span>, <span class="cm-string">"B"</span>, <span class="cm-string">"C"</span>]));
<span class="cm-comment">// → ["C", "B", "A"];</span>
<span class="cm-keyword">var</span> <span class="cm-variable">arrayValue</span> <span class="cm-operator">=</span> [<span class="cm-number">1</span>, <span class="cm-number">2</span>, <span class="cm-number">3</span>, <span class="cm-number">4</span>, <span class="cm-number">5</span>];
<span class="cm-variable">reverseArrayInPlace</span>(<span class="cm-variable">arrayValue</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">arrayValue</span>);
<span class="cm-comment">// → [5, 4, 3, 2, 1]</span></pre>
<div class="solution"><div class="solution-text">
<p><a class="p_ident" id="p_pyY1QGL0wk" href="./04_data.html#p_pyY1QGL0wk"></a>Има два очевидни начина за изпълнение на <code>reverseArray</code>. Първият е просто да минем през входящия масив отпред назад и използваме <code>unshift</code> метода върху новия масив, за да вмъкнем всеки елемент в неговото начало. Вторият е да минем с цикъл над входящия масив назад и използваме <code>push</code> метода. Итерациите над масива назад изискват (донякъде неудобна) <code>for</code> спецификация, като <code>(var i =
array.length - 1; i &gt;= 0; i--)</code>.</p>
<p><a class="p_ident" id="p_Y08sN3Yej5" href="./04_data.html#p_Y08sN3Yej5"></a>Обръщането на масива на място е по-трудно. Вие трябва да внимавате да не презапишете елементи, от които ще се нуждаете по-късно. Използването на <code>reverseArray</code> или друго копиране на целия масив (като <code>array.slice(0)</code> е един добър начин за копиране на масиви) работи, но е измама.</p>
<p><a class="p_ident" id="p_hzYSkS4zzl" href="./04_data.html#p_hzYSkS4zzl"></a>Номерът е да се смени първия с последния елемент, а след това втория с пред последния и т.н. Можете да направите това с цикъл над половината от дължината на масива (използвайте <code>Math.floor</code> за да закръгляте надолу - не е нужно да се достига средата на елементите в масив с нечетна дължина) и смяна на елемент на позиция <code>i</code> с един от позиция при положение на <code>array.length - 1 - i</code>. Можете да използвате локална променлива да държи за кратко един от елементите, презаписвайки го с неговия огледален образ и след това пускане на стойността от локалната променлива в мястото, където огледалния образ да бъде използван.</p>
</div></div>
<h3 id="list"><a class="h_ident" id="h_nSTX34CM1M" href="./04_data.html#h_nSTX34CM1M"></a>Списък</h3>
<p><a class="p_ident" id="p_7AnSuS26HF" href="./04_data.html#p_7AnSuS26HF"></a>Обектите, като широко приложение за стойности, могат да бъдат използвани за изграждане на всички видове структури от данни. Една обща структура от данни е списък (да не се бърка с масив). Списъкът е вложен набор от обекти, като първия обект се позовава на втория , втория - третия и т.н.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_WcmR7ylTJy" href="./04_data.html#c_WcmR7ylTJy"></a><span class="cm-keyword">var</span> <span class="cm-variable">list</span> <span class="cm-operator">=</span> {
  <span class="cm-property">value</span>: <span class="cm-number">1</span>,
  <span class="cm-property">rest</span>: {
    <span class="cm-property">value</span>: <span class="cm-number">2</span>,
    <span class="cm-property">rest</span>: {
      <span class="cm-property">value</span>: <span class="cm-number">3</span>,
      <span class="cm-property">rest</span>: <span class="cm-atom">null</span>
    }
  }
};</pre>
<p><a class="p_ident" id="p_2un5u6U14Q" href="./04_data.html#p_2un5u6U14Q"></a>Получените обекти образуват верига, подобна на тази:</p>
<div class="image">
  <img src="./media/linked-list.svg" alt="A linked list">
</div>
<p><a class="p_ident" id="p_NaI0fhp38z" href="./04_data.html#p_NaI0fhp38z"></a>Хубавото на списъците е, че те могат да споделят част от своята структура. Например, ако аз създам две нови стойности <code>{value: 0, rest: list}</code> и <code>{value: -1, rest: list}</code> (с <code>list</code> позоваващ се на променлива, определена по-рано) и двата списъка са независими, но те споделят структура, която прави техните последни три елемента. В допълнение, първоначалният списък също е все още валиден списък с три елемента.</p>
<p><a class="p_ident" id="p_iPlgVCeZGh" href="./04_data.html#p_iPlgVCeZGh"></a>Напишете функция <code>arrayToList</code>, която изгражда структура от данни, като предишната, на която се дава <code>[1, 2, 3]</code>, като аргумент и напишете функция <code>listToArray</code>, която създава масив от списък. Също напишете помощни функции - <code>prepend</code>, която взема елемент и списък, и създава нов списък, като добавя елемент към  предната част на входа списъка и <code>nth</code>, която взема списък и номер, и връща елемент от дадена позиция в списъка или <code>undefined</code>, когато няма такъв елемент.</p>
<p><a class="p_ident" id="p_IZMCvYT0l2" href="./04_data.html#p_IZMCvYT0l2"></a>Още не сте готови, напишете също и рекурсивна версия на <code>nth</code>.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_F73m7OkLk8" href="./04_data.html#c_F73m7OkLk8"></a><span class="cm-comment">// Your code here.</span>

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">arrayToList</span>([<span class="cm-number">10</span>, <span class="cm-number">20</span>]));
<span class="cm-comment">// → {value: 10, rest: {value: 20, rest: null}}</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">listToArray</span>(<span class="cm-variable">arrayToList</span>([<span class="cm-number">10</span>, <span class="cm-number">20</span>, <span class="cm-number">30</span>])));
<span class="cm-comment">// → [10, 20, 30]</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">prepend</span>(<span class="cm-number">10</span>, <span class="cm-variable">prepend</span>(<span class="cm-number">20</span>, <span class="cm-atom">null</span>)));
<span class="cm-comment">// → {value: 10, rest: {value: 20, rest: null}}</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">nth</span>(<span class="cm-variable">arrayToList</span>([<span class="cm-number">10</span>, <span class="cm-number">20</span>, <span class="cm-number">30</span>]), <span class="cm-number">1</span>));
<span class="cm-comment">// → 20</span></pre>
<div class="solution"><div class="solution-text">
<p><a class="p_ident" id="p_gUGYq9Tjlx" href="./04_data.html#p_gUGYq9Tjlx"></a>Изграждане на списък е най-добре отзад напред. Така <code>arrayToList</code> може да обхожда масива назад (виж предишното упражнение) и за всеки елемент да добавя един обект в списъка. Можете да използвате локална променлива да държи част от списъка, който е направен досега, като използвате модела <code>list = {value: X, rest: list}</code> за да добавя елемент.</p>
<p><a class="p_ident" id="p_+rJULr60CD" href="./04_data.html#p_+rJULr60CD"></a>За да обработите списъка (в  <code>listToArray</code> и <code>nth</code>), може да използвате <code>for</code> цикъл, като този:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_ozaUfY2r+R" href="./04_data.html#c_ozaUfY2r+R"></a><span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-variable">node</span> <span class="cm-operator">=</span> <span class="cm-variable">list</span>; <span class="cm-variable">node</span>; <span class="cm-variable">node</span> <span class="cm-operator">=</span> <span class="cm-variable">node</span>.<span class="cm-property">rest</span>) {}</pre>
<p><a class="p_ident" id="p_LnwEAnSmsp" href="./04_data.html#p_LnwEAnSmsp"></a>Можете ли да видите как става това? Във всяка итерация на цикъла, <code>node</code> сочи към текущия под-списък и тялото му може да чете свойството <code>value</code>, за да получите текущия елемент. В края на итерацията <code>node</code> преминава към следващия под-списък. Когато това е <em>null</em>, то сме достигнали края на списъка и цикъла е завършен.</p>
<p><a class="p_ident" id="p_vwViRUdBme" href="./04_data.html#p_vwViRUdBme"></a>Рекурсивна версия на <code>nth</code> по същия начин ще погледне все по-малката част от "опашката" на списъка и в същото време ще брои за определяне на индекса, докато достигне нула, при което може да върне свойството <code>value</code> на <em>node</em>, където той да търси. За да получите нулевият елемент от списъка, можете просто да вземете свойството <code>value</code> от неговия главен <em>node</em>. За да получите елемент <em>N</em> + 1 вземете <em>N</em>-тия елемент от списъка, който е в списъка на <code>rest</code> свойството.</p>
</div></div>
<h3 id="exercise_deep_compare"><a class="h_ident" id="h_IJBU+aXOIC" href="./04_data.html#h_IJBU+aXOIC"></a>Дълбоко сравнение</h3>
<p><a class="p_ident" id="p_xTwbRlqHNJ" href="./04_data.html#p_xTwbRlqHNJ"></a>Оператора <code>==</code> сравнява обекти за идентичност. Но понякога, бихме предпочели да сравним стойностите по действителните им свойства.</p>
<p><a class="p_ident" id="p_gndt0hmgga" href="./04_data.html#p_gndt0hmgga"></a>Напишете функция <code>deepEqual</code>, кято взема две стойности и връща true, само ако те са една и съща стойност или обекти със същите свойства, чиито стойности също са равни, когато се сравнят с рекурсивното извикване на <code>deepEqual</code>.</p>
<p><a class="p_ident" id="p_kFIc5gkwlo" href="./04_data.html#p_kFIc5gkwlo"></a>За да разберете дали се сравняват две неща по идентичност (използвайте оператора <code>===</code> за това) или за да видите техните свойства, използвайте оператора <code>typeof</code>. Ако той произвежда "object" и за двете стойности, трябва да направите дълбоко сравнение. Но трябва да вземете едно глупаво изключение в предвид: от една историческа случайност, <code>typeof null</code> също произвежда "object".</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_JMI8a18DSU" href="./04_data.html#c_JMI8a18DSU"></a><span class="cm-comment">// Your code here.</span>

<span class="cm-keyword">var</span> <span class="cm-variable">obj</span> <span class="cm-operator">=</span> {<span class="cm-property">here</span>: {<span class="cm-property">is</span>: <span class="cm-string">"an"</span>}, <span class="cm-property">object</span>: <span class="cm-number">2</span>};
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">deepEqual</span>(<span class="cm-variable">obj</span>, <span class="cm-variable">obj</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">deepEqual</span>(<span class="cm-variable">obj</span>, {<span class="cm-property">here</span>: <span class="cm-number">1</span>, <span class="cm-property">object</span>: <span class="cm-number">2</span>}));
<span class="cm-comment">// → false</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">deepEqual</span>(<span class="cm-variable">obj</span>, {<span class="cm-property">here</span>: {<span class="cm-property">is</span>: <span class="cm-string">"an"</span>}, <span class="cm-property">object</span>: <span class="cm-number">2</span>}));
<span class="cm-comment">// → true</span></pre>
<div class="solution"><div class="solution-text">
<p><a class="p_ident" id="p_t3z+oosxP9" href="./04_data.html#p_t3z+oosxP9"></a>Вашият тест за това дали се занимавате с реален обект ще изглежда нещо подобно на <code>typeof x == "object" &amp;&amp; x != null</code>. Бъдете внимателни при сравняване на свойства, когато и двата аргумента са обекти. Във всички други случаи може просто да върнете незабавно резултата от прилагането на <code>===</code>.</p>
<p><a class="p_ident" id="p_fyoBIInROR" href="./04_data.html#p_fyoBIInROR"></a>Използвайте <code>for</code>/<code>in</code> цикъл да минете над свойствата. Трябва да се провери дали двата обекта са с едни и същи набори от имена на свойства и дали тези свойства имат еднакви стойности. Първият тест може да се направи чрез преброяване на свойствата на двата обекта и връщане на <em>false</em>, ако номерата на свойствата са различни. Ако те са едни и същи, след това отидете на свойствата на единия обект и за всяко от тях потвърдете, че другия обект също има това свойство. Стойностите на свойствата се сравняват с рекурсивно извикване на <code>deepEqual</code>.</p>
<p><a class="p_ident" id="p_ECXa1sWg6+" href="./04_data.html#p_ECXa1sWg6+"></a>Връщането на правилната стойност от функцията се прави най-добре, когато незабавно върне <em>false</em>, ако забележи разминаване и върне true в края на функцията.</p>
</div></div>
<nav>
  <a href="./03_functions.html" title="previous chapter">◀</a>
  <a href="./index.html" title="cover">◆</a>
  <a href="./05_higher_order.html" title="next chapter">▶</a>
</nav>
</article>
</body></html>